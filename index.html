<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>theinternetisdead.org - Home</title>
  <style>
    html, body { height: 100%; }
    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: "Courier New", system-ui, sans-serif;
      color: white;
    }

    /* Canvas layers */
    canvas#grid {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      filter: contrast(115%) saturate(115%);
      z-index: 0;
    }
    .grain {
      pointer-events: none;
      position: fixed;
      inset: 0;
      opacity: .3;
      mix-blend-mode: overlay;
      z-index: 2;
      background-image: repeating-conic-gradient(from 0deg, rgba(255,255,255,.02) 0 15deg, rgba(0,0,0,.02) 15deg 30deg);
      animation: twinkle 9s linear infinite;
    }
    @keyframes twinkle { to { transform: rotate(360deg); } }

    /* Centered Big Red Button */
    .center-wrap {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      z-index: 3;
      pointer-events: none; /* enable only the button itself */
    }
    .press-btn {
      pointer-events: auto;
      appearance: none;
      border: 0;
      outline: none;
      background: radial-gradient(circle at 30% 30%, #ff7272, #ff1b1b 45%, #b60000 70%);
      color: #fff;
      font-weight: 900;
      letter-spacing: .02em;
      text-transform: none;
      font-size: clamp(18px, 3.7vw, 42px);
      width: clamp(180px, 34vmin, 420px);
      height: clamp(180px, 34vmin, 420px);
      border-radius: 999px;
      box-shadow: 0 14px 38px rgba(255, 32, 32, .35), inset 0 10px 24px rgba(255,255,255,.2), inset 0 -10px 24px rgba(0,0,0,.35);
      cursor: pointer;
      transform: translateZ(0) scale(1);
      transition: transform .12s ease, filter .12s ease, box-shadow .12s ease;
      position: relative;
      isolation: isolate;
    }
    .press-btn::after{
      content:"";
      position:absolute; inset:-8%; border-radius:999px;
      filter: blur(28px);
      background: conic-gradient(from 0deg, rgba(255,0,0,.0), rgba(255,0,0,.45), rgba(255,0,0,.0) 60%);
      opacity:.5; z-index:-1;
      animation: spin 6s linear infinite;
    }
    @keyframes spin{ to{ transform: rotate(360deg);} }
    .press-btn:active { transform: scale(.96); filter: brightness(1.05); }
    .press-btn .label { display:block; line-height:1.15; text-align:center; padding: 0 1rem; }

    /* CRT-ish frame + chroma aberration during blast */
    .fx-wrap {
      position: fixed; inset: 0; z-index: 4; pointer-events:none;
    }
    .scanlines::before {
      content:""; position:absolute; inset:0; pointer-events:none; mix-blend-mode:soft-light;
      background: repeating-linear-gradient(0deg, rgba(255,255,255,.02) 0 2px, rgba(0,0,0,.02) 2px 4px);
    }

    .shake { animation: shake .45s cubic-bezier(.3,.07,.19,.97) 1; }
    @keyframes shake{
      0%{ transform: translate(0,0) }
      20%{ transform: translate(-6px,2px) }
      40%{ transform: translate(5px,-3px) }
      60%{ transform: translate(-3px,2px) }
      80%{ transform: translate(3px,-2px) }
      100%{ transform: translate(0,0) }
    }

    .rgb-split { filter: none; }
    .rgb-split.active {
      filter: drop-shadow(2px 0 rgba(255,0,0,.6)) drop-shadow(-2px 0 rgba(0,255,255,.6));
    }

    /* White flash */
    .flash {
      position: fixed; inset: 0; background: #fff; opacity: 0; pointer-events:none; z-index: 5;
      transition: opacity .12s ease;
    }

    /* Minimal helper text */
    .hint { position: fixed; left: 50%; bottom: 2.2rem; transform: translateX(-50%); font-size: .9rem; opacity: .7; z-index: 3; }

  </style>
</head>
<body>
  <canvas id="grid" aria-hidden="true"></canvas>
  <div class="grain scanlines" aria-hidden="true"></div>

  <div class="center-wrap">
    <button id="pressF" class="press-btn rgb-split" aria-label="Press F to Pay Respect">
      <span class="label">Press F to Pay Respect</span>
    </button>
  </div>

  <div class="fx-wrap">
    <div id="flash" class="flash" aria-hidden="true"></div>
  </div>

  <div class="hint">Press the button or hit the <strong>F</strong> key</div>

  <script>
    // === backdrop particles (ported and extended) ===
    const DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    const canvas = document.getElementById('grid');
    const ctx = canvas.getContext('2d');
    let W = 0, H = 0;
    let hexR = 10;
    const points = [];
    let t = 0;
    const timeScale = 0.00035;
    const fieldScale = 0.013;
    const pointer = { x: 0, y: 0, active: false };

    // explosion state
    let phase = 'idle'; // idle | collapse | blast | fade
    let phaseT = 0;     // ms since phase start

    function palette(v) {
      const u = (v + 1) * 0.5;
      if (u < 0.33) return 'rgba(255,0,0,0.8)';
      else if (u < 0.66) return 'rgba(0,255,0,0.8)';
      else return 'rgba(0,0,255,0.8)';
    }

    function resize() {
      W = Math.floor(window.innerWidth);
      H = Math.floor(window.innerHeight);
      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      const targetCols = Math.max(24, Math.round(W / 36));
      hexR = Math.max(6, Math.min(22, Math.round(W / targetCols)));
      buildGrid();
    }

    function buildGrid() {
      points.length = 0;
      const r = hexR;
      const hexW = r * 2;
      const hexH = Math.sqrt(3) * r;
      const margin = Math.max(40, r * 3);
      for (let y = -margin, row = 0; y < H + margin; y += hexH, row++) {
        const offsetX = (row % 2) ? hexW * 0.5 : 0;
        for (let x = -margin + offsetX; x < W + margin; x += hexW) {
          points.push({ x, y, vx: 0, vy: 0, life: 1 });
        }
      }
    }

    function setPointer(e) {
      const rect = canvas.getBoundingClientRect();
      pointer.x = (e.clientX - rect.left);
      pointer.y = (e.clientY - rect.top);
      pointer.active = true;
    }
    window.addEventListener('pointermove', setPointer);
    window.addEventListener('pointerdown', setPointer);
    window.addEventListener('pointerleave', () => (pointer.active = false));
    window.addEventListener('blur', () => (pointer.active = false));

    let lastTS = 0;
    function frame(ts) {
      const dt = Math.min(32, ts - lastTS || 16.7);
      lastTS = ts;
      t += dt;
      phaseT += dt;
      draw(dt);
      requestAnimationFrame(frame);
    }

    function draw(dt) {
      // subtle trail unless flash
      if (phase === 'blast') {
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
      } else {
        ctx.fillStyle = 'rgba(5,8,12,0.16)';
      }
      ctx.fillRect(0, 0, W, H);

      const rBase = Math.max(1.2, Math.min(3.2, hexR * 0.18));
      const inflRad = Math.max(W, H) * 0.18;
      const inflRad2 = inflRad * inflRad;
      const cx = W * 0.5, cy = H * 0.5;

      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        const n = snoise3(p.x * fieldScale, p.y * fieldScale, t * timeScale);
        const ang = n * Math.PI * 2;
        const ox = Math.cos(ang) * hexR * 0.15;
        const oy = Math.sin(ang) * hexR * 0.15;
        let x = p.x + ox;
        let y = p.y + oy;

        // interactive pull
        if (pointer.active && phase === 'idle') {
          const dx = pointer.x - x; const dy = pointer.y - y; const d2 = dx*dx + dy*dy;
          if (d2 < inflRad2) {
            const d = Math.sqrt(d2) || 1; const g = 1 - d / inflRad; const pull = g * g * hexR * 0.9;
            x += (dx / d) * pull; y += (dy / d) * pull;
          }
        }

        // explosion choreography
        if (phase === 'collapse') {
          const dx = cx - x; const dy = cy - y; const d = Math.hypot(dx, dy) || 1;
          const pull = Math.min(18, 0.19 * d) * easeOutCubic(clamp(phaseT/700, 0, 1));
          p.vx += (dx/d) * pull * 0.06; p.vy += (dy/d) * pull * 0.06;
        } else if (phase === 'blast') {
          // outward push once
          if (!p.blasted) {
            const ax = x - cx; const ay = y - cy; const d = Math.hypot(ax, ay) + 0.0001;
            const spread = 2.2 + Math.random() * 1.8;
            p.vx = (ax / d) * spread * (0.6 + Math.random()*0.8) + (Math.random()-0.5)*0.9;
            p.vy = (ay / d) * spread * (0.6 + Math.random()*0.8) + (Math.random()-0.5)*0.9;
            p.life = 1;
            p.blasted = true;
          }
        }

        // integrate motion
        p.x += p.vx; p.y += p.vy;
        p.vx *= 0.985; p.vy *= 0.985;

        // draw
        const lifeFade = (phase === 'blast' || phase === 'fade') ? Math.max(0, 1 - phaseT/1400) : 1;
        let r = rBase + Math.max(0, n) * rBase * 1.4;
        r *= 1 + (phase === 'blast' ? 0.6 : 0);
        ctx.fillStyle = phase === 'blast' ? `rgba(${200+Math.floor(55*Math.random())},${200+Math.floor(55*Math.random())},${200+Math.floor(55*Math.random())},${0.8*lifeFade})` : palette(n);
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        ctx.fill();
      }

      // phase transitions
      if (phase === 'collapse' && phaseT > 750) {
        startBlast();
      } else if (phase === 'blast' && phaseT > 1200) {
        startFade();
      } else if (phase === 'fade' && phaseT > 900) {
        resetScene();
      }
    }

    // noise (Simplex 3D)
    const grad3 = [ [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1] ];
    const pPerm = new Uint8Array(256);
    for (let i = 0; i < 256; i++) pPerm[i] = i;
    (function(){ let seed = (performance.now() * 1000)|0; function rnd(){ seed ^= seed<<13; seed ^= seed>>>17; seed ^= seed<<5; return (seed>>>0)/4294967296; } for (let i=255;i>0;i--){ const j=Math.floor(rnd()*(i+1)); const t=pPerm[i]; pPerm[i]=pPerm[j]; pPerm[j]=t; } })();
    const perm = new Uint8Array(512);
    const permMod12 = new Uint8Array(512);
    for (let i = 0; i < 512; i++) { perm[i] = pPerm[i & 255]; permMod12[i] = perm[i] % 12; }
    function dot(g, x, y, z){ return g[0]*x + g[1]*y + g[2]*z; }
    function snoise3(xin, yin, zin) {
      const F3=1/3, G3=1/6; let n0,n1,n2,n3;
      const s=(xin+yin+zin)*F3; const i=Math.floor(xin+s); const j=Math.floor(yin+s); const k=Math.floor(zin+s);
      const t=(i+j+k)*G3; const X0=i-t, Y0=j-t, Z0=k-t;
      const x0=xin-X0, y0=yin-Y0, z0=zin-Z0;
      let i1,j1,k1,i2,j2,k2;
      if(x0>=y0){ if(y0>=z0){i1=1;j1=0;k1=0;i2=1;j2=1;k2=0;} else if(x0>=z0){i1=1;j1=0;k1=0;i2=1;j2=0;k2=1;} else {i1=0;j1=0;k1=1;i2=1;j2=0;k2=1;} } else { if(y0<z0){i1=0;j1=0;k1=1;i2=0;j2=1;k2=1;} else if(x0<z0){i1=0;j1=1;k1=0;i2=0;j2=1;k2=1;} else {i1=0;j1=1;k1=0;i2=1;j2=1;k2=0;} }
      const x1=x0-i1+G3, y1=y0-j1+G3, z1=z0-k1+G3;
      const x2=x0-i2+2*G3, y2=y0-j2+2*G3, z2=z0-k2+2*G3;
      const x3=x0-1+3*G3, y3=y0-1+3*G3, z3=z0-1+3*G3;
      const ii=i&255, jj=j&255, kk=k&255;
      const gi0=grad3[permMod12[ii+perm[jj+perm[kk]]]];
      const gi1=grad3[permMod12[ii+i1+perm[jj+j1+perm[kk+k1]]]];
      const gi2=grad3[permMod12[ii+i2+perm[jj+j2+perm[kk+k2]]]];
      const gi3=grad3[permMod12[ii+1+perm[jj+1+perm[kk+1]]]];
      let t0=0.6-x0*x0-y0*y0-z0*z0; if(t0<0)n0=0; else {t0*=t0;n0=t0*t0*dot(gi0,x0,y0,z0);} let t1=0.6-x1*x1-y1*y1-z1*z1; if(t1<0)n1=0; else {t1*=t1;n1=t1*t1*dot(gi1,x1,y1,z1);} let t2=0.6-x2*x2-y2*y2-z2*z2; if(t2<0)n2=0; else {t2*=t2;n2=t2*t2*dot(gi2,x2,y2,z2);} let t3=0.6-x3*x3-y3*y3-z3*z3; if(t3<0)n3=0; else {t3*=t3;n3=t3*t3*dot(gi3,x3,y3,z3);} return 32*(n0+n1+n2+n3);
    }

    // helpers
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function easeOutCubic(x){ return 1 - Math.pow(1 - x, 3); }

    // FX hooks
    const pressBtn = document.getElementById('pressF');
    const flash = document.getElementById('flash');
    const btnWrap = document.querySelector('.center-wrap');

    function startCollapse(){
      phase = 'collapse'; phaseT = 0;
      canvas.classList.add('shake');
      pressBtn.classList.add('active');
    }
    function startBlast(){
      phase = 'blast'; phaseT = 0;
      flash.style.opacity = 1; // instant flash
      setTimeout(()=> flash.style.opacity = 0, 120); // fade back quickly
      document.querySelector('.grain').style.opacity = .45;
      document.querySelector('.rgb-split').classList.add('active');
      canvas.classList.add('shake');
      btnWrap.style.opacity = 0; // hide button during blast
      // center everything for dramatic blast
      for (const p of points){ p.blasted = false; }
    }
    function startFade(){
      phase = 'fade'; phaseT = 0;
      document.querySelector('.grain').style.opacity = .18;
      canvas.classList.remove('shake');
    }
    function resetScene(){
      phase = 'idle'; phaseT = 0;
      buildGrid();
      flash.style.opacity = 0;
      document.querySelector('.rgb-split').classList.remove('active');
      btnWrap.style.opacity = 1;
    }

    // input
    pressBtn.addEventListener('click', startCollapse);
    window.addEventListener('keydown', (e)=>{ if ((e.key||'').toLowerCase()==='f') startCollapse(); });

    // pointer pull for idle backdrop
    window.addEventListener('pointermove', setPointer);
    window.addEventListener('pointerdown', setPointer);
    window.addEventListener('pointerleave', () => (pointer.active = false));
    window.addEventListener('blur', () => (pointer.active = false));

    resize();
    window.addEventListener('resize', resize);
    requestAnimationFrame(frame);
  </script>
</body>
</html>
