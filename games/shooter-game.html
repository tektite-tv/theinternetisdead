<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bananarama Maze Pursuit</title>
<style>
  html, body { margin:0; overflow:hidden; background:#000; color:#0f0; font-family:monospace; }
  #hud {
    position:absolute; top:10px; left:10px;
    text-shadow:1px 1px 3px #000; color:#0f0;
  }
  canvas { display:block; }
</style>
</head>
<body>
<div id="hud">Level: 1 | Lives: 3 | Kills: 0</div>
<canvas id="game"></canvas>
<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
let w,h;function resize(){w=canvas.width=window.innerWidth;h=canvas.height=window.innerHeight;}
window.addEventListener("resize",resize);resize();

const TILE=32;
const COLS=Math.floor(w/TILE);
const ROWS=Math.floor(h/TILE);

// Maze generation: recursive backtracking
let maze=[];
function initMaze(){
  maze=[];
  for(let y=0;y<ROWS;y++){
    let row=[];
    for(let x=0;x<COLS;x++) row.push({x,y,visited:false,walls:[1,1,1,1]}); // top,right,bottom,left
    maze.push(row);
  }
}
function neighbors(cell){
  const dirs=[
    [0,-1,0,2],[1,0,1,3],[0,1,2,0],[-1,0,3,1]
  ];
  return dirs.map(([dx,dy,wall,opp])=>{
    const nx=cell.x+dx,ny=cell.y+dy;
    if(nx<0||ny<0||nx>=COLS||ny>=ROWS) return null;
    return {n:maze[ny][nx],w:wall,o:opp};
  }).filter(v=>v&& !v.n.visited);
}
function generateMaze(){
  const stack=[];
  const start=maze[0][0];
  start.visited=true;
  stack.push(start);
  while(stack.length){
    const current=stack[stack.length-1];
    const ns=neighbors(current);
    if(ns.length){
      const rand=ns[Math.floor(Math.random()*ns.length)];
      current.walls[rand.w]=0;
      rand.n.walls[rand.o]=0;
      rand.n.visited=true;
      stack.push(rand.n);
    }else stack.pop();
  }
}
initMaze();generateMaze();

// Player and monsters
let player={x:0,y:0,lives:3,kills:0,level:1};
let monsters=[];
const monsterImg=new Image();
monsterImg.src="/media/images/gifs/skeleton.gif";
const playerImg=new Image();
playerImg.src="/media/images/gifs/bananarama.gif";

function resetPositions(){
  player.x=0;player.y=0;
  monsters=[];
  for(let i=0;i<Math.min(5,player.level+2);i++){
    monsters.push({
      x:Math.floor(Math.random()*COLS),
      y:Math.floor(Math.random()*ROWS),
      hp:3+player.level,
      path:[],
    });
  }
}

// A* pathfinding
function heuristic(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y);}
function getNeighbors(node){
  const dirs=[[0,-1],[1,0],[0,1],[-1,0]];
  const result=[];
  for(let i=0;i<4;i++){
    const nx=node.x+dirs[i][0],ny=node.y+dirs[i][1];
    if(nx<0||ny<0||nx>=COLS||ny>=ROWS)continue;
    const cell=maze[node.y][node.x];
    if(!cell.walls[i]) result.push({x:nx,y:ny});
  }
  return result;
}
function aStar(start,goal){
  const open=[start];
  const cameFrom={};
  const gScore={[`${start.x},${start.y}`]:0};
  const fScore={[`${start.x},${start.y}`]:heuristic(start,goal)};
  while(open.length){
    open.sort((a,b)=>fScore[`${a.x},${a.y}`]-fScore[`${b.x},${b.y}`]);
    const current=open.shift();
    if(current.x===goal.x&&current.y===goal.y){
      let p=[current];
      while(`${current.x},${current.y}` in cameFrom){
        current=cameFrom[`${current.x},${current.y}`];
        p.unshift(current);
      }
      return p;
    }
    for(const n of getNeighbors(current)){
      const g=gScore[`${current.x},${current.y}`]+1;
      const key=`${n.x},${n.y}`;
      if(g< (gScore[key]??Infinity)){
        cameFrom[key]=current;
        gScore[key]=g;
        fScore[key]=g+heuristic(n,goal);
        if(!open.some(o=>o.x===n.x&&o.y===n.y))open.push(n);
      }
    }
  }
  return [];
}

// Input
const keys={};
window.addEventListener('keydown',e=>{
  keys[e.key.toLowerCase()]=true;
  movePlayer();
});
window.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);

function movePlayer(){
  const dirs={'w':[0,-1,0],'d':[1,0,1],'s':[0,1,2],'a':[-1,0,3]};
  for(const key in dirs){
    if(keys[key]){
      const [dx,dy,wall]=dirs[key];
      const cell=maze[player.y][player.x];
      if(!cell.walls[wall]){
        player.x+=dx;
        player.y+=dy;
      }
      break;
    }
  }
}

function updateMonsters(){
  monsters.forEach(m=>{
    if(m.path.length===0||Math.random()<0.02){
      m.path=aStar({x:m.x,y:m.y},{x:player.x,y:player.y});
    }
    if(m.path.length>1){
      m.path.shift();
      const next=m.path[0];
      if(next){m.x=next.x;m.y=next.y;}
    }
    if(m.x===player.x&&m.y===player.y){
      player.lives--;
      if(player.lives<=0) resetGame();
      else resetPositions();
    }
  });
}

function resetGame(){
  player.lives=3;player.kills=0;player.level=1;
  initMaze();generateMaze();resetPositions();
}

resetPositions();

function drawMaze(){
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,w,h);
  ctx.strokeStyle="#444";
  ctx.lineWidth=2;
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const c=maze[y][x];
      const px=x*TILE,py=y*TILE;
      ctx.beginPath();
      if(c.walls[0]){ctx.moveTo(px,py);ctx.lineTo(px+TILE,py);}
      if(c.walls[1]){ctx.moveTo(px+TILE,py);ctx.lineTo(px+TILE,py+TILE);}
      if(c.walls[2]){ctx.moveTo(px,py+TILE);ctx.lineTo(px+TILE,py+TILE);}
      if(c.walls[3]){ctx.moveTo(px,py);ctx.lineTo(px,py+TILE);}
      ctx.stroke();
    }
  }
}

function drawEntities(){
  const px=player.x*TILE+TILE/4,py=player.y*TILE+TILE/4;
  ctx.drawImage(playerImg,px,py,TILE/2,TILE/2);
  monsters.forEach(m=>{
    const mx=m.x*TILE+TILE/4,my=m.y*TILE+TILE/4;
    ctx.drawImage(monsterImg,mx,my,TILE/2,TILE/2);
  });
}

function loop(){
  updateMonsters();
  ctx.clearRect(0,0,w,h);
  drawMaze();
  drawEntities();
  document.getElementById("hud").textContent=`Lives: ${player.lives} | Monsters: ${monsters.length}`;
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
