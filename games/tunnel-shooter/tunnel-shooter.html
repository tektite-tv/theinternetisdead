<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tunnel Shooter (Xevious-ish) v0.1</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; height:100%; background:#05060a; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #wrap { position:relative; width:100%; height:100%; }
    canvas { width:100%; height:100%; display:block; background:#05060a; }
    /* HUD */
    .hud {
      position:absolute; left:12px; top:12px;
      display:flex; flex-direction:column; gap:10px;
      padding:10px 12px; border-radius:12px;
      background: rgba(10,12,18,0.66);
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(6px);
      max-width:min(420px, calc(100vw - 24px));
    }
    .hud h1 {
      margin:0; font-size:14px; letter-spacing:0.3px; font-weight:700;
      display:flex; gap:8px; align-items:center;
    }
    .pill {
      font-size:12px; padding:2px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      font-weight:600;
    }
    .row { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .row label {
      font-size:12px; opacity:0.9; display:flex; gap:8px; align-items:center;
      padding:6px 8px; border-radius:10px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      cursor:pointer;
      user-select:none;
    }
    .row input[type="file"] { display:none; }
    button {
      appearance:none; border:none; cursor:pointer; user-select:none;
      padding:8px 10px; border-radius:10px; font-weight:700; font-size:12px;
      color:#e9ecff;
      background: rgba(140,160,255,0.18);
      border: 1px solid rgba(140,160,255,0.30);
    }
    button:active { transform: translateY(1px); }
    .stats { font-size:12px; opacity:0.88; display:flex; gap:10px; flex-wrap:wrap; }
    .hint { font-size:12px; opacity:0.72; line-height:1.35; }
    .toast {
      position:absolute; right:12px; top:12px;
      padding:10px 12px; border-radius:12px;
      background: rgba(10,12,18,0.66);
      border: 1px solid rgba(255,255,255,0.10);
      max-width:min(420px, calc(100vw - 24px));
      font-size:12px; opacity:0; transform: translateY(-6px);
      transition: opacity .22s ease, transform .22s ease;
      pointer-events:none;
    }
    .toast.show { opacity:1; transform: translateY(0); }
    /* Touch controls */
    .touchbar {
      position:absolute; left:0; right:0; bottom:0;
      display:flex; justify-content:space-between; gap:12px;
      padding:12px; pointer-events:none;
    }
    .touchpad {
      width:160px; height:160px; border-radius:18px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      backdrop-filter: blur(6px);
      pointer-events:auto;
      touch-action:none;
      position:relative;
    }
    .knob {
      position:absolute; width:54px; height:54px; border-radius:16px;
      left:50%; top:50%; transform: translate(-50%,-50%);
      background: rgba(140,160,255,0.20);
      border: 1px solid rgba(140,160,255,0.35);
    }
    .shootbtn {
      width:160px; height:160px; border-radius:18px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,90,120,0.10);
      backdrop-filter: blur(6px);
      pointer-events:auto;
      touch-action:none;
      display:grid; place-items:center;
      font-weight:900; letter-spacing:0.6px;
    }
    .shootbtn span { opacity:0.88; }
    @media (pointer:fine) {
      .touchbar { display:none; }
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="hud">
    <h1>
      Tunnel Shooter <span class="pill">Xevious-ish</span> <span class="pill">v0.1</span>
    </h1>

    <div class="row">
      <label title="Set player ship image">
         Player Image
        <input id="playerFile" type="file" accept="image/*" />
      </label>

      <label title="Add enemy images to the spawn pool (you can add multiple)">
         Add Enemy Images
        <input id="enemyFiles" type="file" accept="image/*" multiple />
      </label>

      <button id="clearEnemies" title="Clear enemy image pool">Clear Enemies</button>
      <button id="togglePause" title="Pause/Resume">Pause</button>
      <button id="restart" title="Restart run">Restart</button>
    </div>

    <div class="stats" id="stats"></div>
    <div class="hint">
      Controls: <b>Arrow Keys / WASD</b> move, <b>Space</b> shoot, <b>P</b> pause, <b>R</b> restart.<br/>
      Upload any PNG/JPG/WebP and they become enemies. Yes, even pictures of your laundry.
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- Touch controls (auto hidden on mouse/trackpad devices) -->
  <div class="touchbar">
    <div class="touchpad" id="touchpad">
      <div class="knob" id="knob"></div>
    </div>
    <div class="shootbtn" id="shootbtn"><span>SHOOT</span></div>
  </div>
</div>

<script>
/*
  Tunnel Shooter (Xevious-ish) v0.1
  - Self-contained HTML canvas shooter
  - Ground scrolls downward forever (gives "flying forward" illusion)
  - Player image is user-supplied; enemies are user-supplied (randomly spawned from pool)
  - No external assets; no copyrighted sprites included
*/

(() => {
  // ---------- Canvas & scaling ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  let W = 0, H = 0, DPR = 1;
  function resize() {
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  // ---------- UI ----------
  const statsEl = document.getElementById('stats');
  const toastEl = document.getElementById('toast');

  const playerFile = document.getElementById('playerFile');
  const enemyFiles = document.getElementById('enemyFiles');
  const clearEnemiesBtn = document.getElementById('clearEnemies');
  const togglePauseBtn = document.getElementById('togglePause');
  const restartBtn = document.getElementById('restart');

  function toast(msg) {
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(() => toastEl.classList.remove('show'), 1800);
  }

  // ---------- Assets ----------
  function loadImageFromFile(file) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = URL.createObjectURL(file);
    });
  }

  // Default player: simple procedural ship if user doesn't upload one
  const defaultPlayerCanvas = document.createElement('canvas');
  defaultPlayerCanvas.width = 96;
  defaultPlayerCanvas.height = 96;
  {
    const g = defaultPlayerCanvas.getContext('2d');
    g.clearRect(0,0,96,96);
    g.translate(48,52);

    // glow
    g.save();
    g.globalAlpha = 0.35;
    g.beginPath();
    g.arc(0, 0, 20, 0, Math.PI*2);
    g.fillStyle = '#8aa0ff';
    g.fill();
    g.restore();

    // body
    g.beginPath();
    g.moveTo(0, -30);
    g.lineTo(18, 22);
    g.lineTo(0, 14);
    g.lineTo(-18, 22);
    g.closePath();
    g.fillStyle = '#e9ecff';
    g.fill();

    // cockpit
    g.beginPath();
    g.ellipse(0, -6, 7, 12, 0, 0, Math.PI*2);
    g.fillStyle = '#1b2140';
    g.fill();

    // wing tips
    g.beginPath();
    g.moveTo(-18, 22);
    g.lineTo(-30, 30);
    g.lineTo(-10, 28);
    g.closePath();
    g.fillStyle = '#cfd6ff';
    g.fill();

    g.beginPath();
    g.moveTo(18, 22);
    g.lineTo(30, 30);
    g.lineTo(10, 28);
    g.closePath();
    g.fillStyle = '#cfd6ff';
    g.fill();

    // thruster
    g.beginPath();
    g.moveTo(-6, 22);
    g.lineTo(0, 38);
    g.lineTo(6, 22);
    g.closePath();
    g.fillStyle = '#ff5a78';
    g.fill();
  }

  let playerImg = defaultPlayerCanvas;

  // Enemy pool: user-uploaded images
  const enemyPool = []; // {img, w, h}
  function enemyPoolCount() { return enemyPool.length; }

  // ---------- Game state ----------
  const state = {
    running: true,
    paused: false,
    time: 0,
    score: 0,
    lives: 3,
    wave: 1,
    heat: 0,          // shooting cooldown
    difficulty: 1,
    spawnTimer: 0,
    spawnInterval: 0.75, // seconds base
    speed: 220,       // scroll speed for world/enemies (px/s)
    bulletSpeed: 640, // px/s
  };

  const player = {
    x: 0, y: 0,
    r: 18,
    vx: 0, vy: 0,
    speed: 420,
    invuln: 0,
  };

  const bullets = []; // {x,y,vy,r}
  const enemies = []; // {x,y,vx,vy,r,hp,img,rot,spin,kind,hit}
  const particles = []; // {x,y,vx,vy,life}

  function resetGame() {
    state.time = 0;
    state.score = 0;
    state.lives = 3;
    state.wave = 1;
    state.heat = 0;
    state.difficulty = 1;
    state.spawnTimer = 0;
    state.spawnInterval = 0.78;
    state.speed = 220;

    bullets.length = 0;
    enemies.length = 0;
    particles.length = 0;

    player.x = W * 0.5;
    player.y = H * 0.78;
    player.vx = 0;
    player.vy = 0;
    player.invuln = 1.5;

    toast('Restarted.');
  }

  resetGame();

  // ---------- Input ----------
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    keys.add(k);

    // prevent page scroll on arrows/space
    if (['arrowup','arrowdown','arrowleft','arrowright',' '].includes(e.key)) e.preventDefault();

    if (k === 'p') togglePause();
    if (k === 'r') resetGame();
  }, { passive: false });

  window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()), { passive: true });

  let shooting = false;
  window.addEventListener('mousedown', () => shooting = true, { passive: true });
  window.addEventListener('mouseup',   () => shooting = false, { passive: true });
  window.addEventListener('blur',      () => { keys.clear(); shooting = false; }, { passive: true });

  // Touch controls
  const touchpad = document.getElementById('touchpad');
  const knob = document.getElementById('knob');
  const shootbtn = document.getElementById('shootbtn');

  const touch = { active:false, id:null, cx:0, cy:0, dx:0, dy:0 };
  function setKnob(nx, ny) {
    knob.style.left = (50 + nx*38) + '%';
    knob.style.top  = (50 + ny*38) + '%';
  }
  setKnob(0,0);

  touchpad.addEventListener('pointerdown', (e) => {
    touchpad.setPointerCapture(e.pointerId);
    touch.active = true;
    touch.id = e.pointerId;
    const rect = touchpad.getBoundingClientRect();
    touch.cx = rect.left + rect.width/2;
    touch.cy = rect.top + rect.height/2;
    touch.dx = 0; touch.dy = 0;
  });

  touchpad.addEventListener('pointermove', (e) => {
    if (!touch.active || e.pointerId !== touch.id) return;
    const rect = touchpad.getBoundingClientRect();
    const max = Math.min(rect.width, rect.height) * 0.32;
    const dx = e.clientX - touch.cx;
    const dy = e.clientY - touch.cy;
    const len = Math.hypot(dx, dy) || 1;
    const cl = Math.min(max, len);
    touch.dx = (dx / len) * (cl / max);
    touch.dy = (dy / len) * (cl / max);
    setKnob(touch.dx, touch.dy);
  });

  function endTouch(e) {
    if (e.pointerId !== touch.id) return;
    touch.active = false;
    touch.id = null;
    touch.dx = 0; touch.dy = 0;
    setKnob(0,0);
  }
  touchpad.addEventListener('pointerup', endTouch);
  touchpad.addEventListener('pointercancel', endTouch);

  shootbtn.addEventListener('pointerdown', (e) => { shootbtn.setPointerCapture(e.pointerId); shooting = true; });
  shootbtn.addEventListener('pointerup',   () => shooting = false);
  shootbtn.addEventListener('pointercancel',() => shooting = false);

  // ---------- UI handlers ----------
  playerFile.addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    try {
      const img = await loadImageFromFile(file);
      playerImg = img;
      toast('Player image set.');
    } catch {
      toast('Could not load player image.');
    } finally {
      playerFile.value = '';
    }
  });

  enemyFiles.addEventListener('change', async (e) => {
    const files = Array.from(e.target.files || []);
    if (!files.length) return;

    let added = 0;
    for (const f of files) {
      try {
        const img = await loadImageFromFile(f);
        enemyPool.push({ img, w: img.naturalWidth || img.width, h: img.naturalHeight || img.height });
        added++;
      } catch {}
    }
    toast(added ? `Added ${added} enemy image(s).` : 'No enemy images loaded.');
    enemyFiles.value = '';
  });

  clearEnemiesBtn.addEventListener('click', () => {
    enemyPool.splice(0, enemyPool.length);
    toast('Enemy pool cleared.');
  });

  function togglePause() {
    state.paused = !state.paused;
    togglePauseBtn.textContent = state.paused ? 'Resume' : 'Pause';
    toast(state.paused ? 'Paused.' : 'Resumed.');
  }
  togglePauseBtn.addEventListener('click', togglePause);

  restartBtn.addEventListener('click', resetGame);

  // ---------- Helpers ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);

  function circleHit(ax, ay, ar, bx, by, br) {
    const dx = ax - bx, dy = ay - by;
    const rr = ar + br;
    return (dx*dx + dy*dy) <= rr*rr;
  }

  function spawnExplosion(x, y, n = 14) {
    for (let i=0;i<n;i++) {
      particles.push({
        x, y,
        vx: rand(-160,160),
        vy: rand(-160,160),
        life: rand(0.25,0.6)
      });
    }
  }

  function pickEnemyImage() {
    if (!enemyPool.length) return null;
    return enemyPool[(Math.random() * enemyPool.length) | 0].img;
  }

  function spawnEnemy() {
    // Enemy types: small swooper, medium drifter, occasional "ground-ish" target
    const kindRoll = Math.random();

    const img = pickEnemyImage();
    const hasImg = !!img;

    const x = rand(W * 0.12, W * 0.88);
    const y = -40;

    let kind = 'swooper';
    let hp = 1;
    let r = 16;
    let vx = rand(-60, 60);
    let vy = state.speed * rand(0.65, 0.95);

    if (kindRoll > 0.70) {
      kind = 'drifter';
      hp = 2;
      r = 22;
      vx = rand(-90, 90);
      vy = state.speed * rand(0.55, 0.75);
    }
    if (kindRoll > 0.93) {
      kind = 'tank';
      hp = 4;
      r = 30;
      vx = rand(-40, 40);
      vy = state.speed * rand(0.45, 0.62);
    }

    enemies.push({
      x, y, vx, vy,
      r, hp,
      img: hasImg ? img : null,
      rot: rand(0, Math.PI*2),
      spin: rand(-2.2, 2.2),
      kind,
      hit: 0
    });
  }

  // ---------- Ground: procedural scrolling "tunnel-ish" texture ----------
  // We render a repeating strip onto an offscreen canvas, then scroll it down.
  const groundTex = document.createElement('canvas');
  const gctx = groundTex.getContext('2d', { alpha: true });
  function rebuildGroundTex() {
    groundTex.width = Math.max(512, Math.floor(W));
    groundTex.height = 512;

    // Base
    gctx.clearRect(0,0,groundTex.width, groundTex.height);
    gctx.fillStyle = '#060813';
    gctx.fillRect(0,0,groundTex.width, groundTex.height);

    // Center "tunnel" lane with perspective-ish stripes
    const mid = groundTex.width / 2;
    for (let y=0;y<groundTex.height;y+=6) {
      const t = y / groundTex.height; // 0..1
      const w = (0.18 + 0.52 * t) * groundTex.width;
      const x0 = mid - w/2;
      const x1 = mid + w/2;

      // tunnel fill
      gctx.fillStyle = (y % 24 === 0) ? 'rgba(20,26,55,0.55)' : 'rgba(12,16,38,0.55)';
      gctx.fillRect(x0, y, w, 6);

      // edge highlights
      gctx.fillStyle = 'rgba(140,160,255,0.18)';
      gctx.fillRect(x0, y, 2, 6);
      gctx.fillRect(x1-2, y, 2, 6);

      // center line dashes
      if (y % 36 === 0) {
        gctx.fillStyle = 'rgba(255,90,120,0.18)';
        gctx.fillRect(mid-1, y, 2, 12);
      }
    }

    // Noise specks and "structures"
    for (let i=0;i<420;i++) {
      const x = rand(0, groundTex.width);
      const y = rand(0, groundTex.height);
      const s = rand(1, 3);
      gctx.fillStyle = Math.random() < 0.5 ? 'rgba(255,255,255,0.06)' : 'rgba(140,160,255,0.05)';
      gctx.fillRect(x, y, s, s);
    }

    // Random blocks near edges
    for (let i=0;i<42;i++) {
      const side = Math.random() < 0.5 ? -1 : 1;
      const x = mid + side * rand(0.38, 0.52) * groundTex.width;
      const y = rand(0, groundTex.height);
      const w = rand(18, 60);
      const h = rand(8, 22);
      gctx.fillStyle = 'rgba(255,255,255,0.04)';
      gctx.fillRect(x, y, w * side, h);
    }

    // Vignette
    const vg = gctx.createRadialGradient(mid, groundTex.height*0.6, 60, mid, groundTex.height*0.6, groundTex.width*0.72);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.55)');
    gctx.fillStyle = vg;
    gctx.fillRect(0,0,groundTex.width, groundTex.height);
  }
  rebuildGroundTex();
  window.addEventListener('resize', rebuildGroundTex, { passive: true });

  let groundScroll = 0;

  // ---------- Update & render loop ----------
  let last = performance.now();
  function tick(now) {
    const dtRaw = (now - last) / 1000;
    last = now;

    // clamp dt to avoid huge jumps
    const dt = clamp(dtRaw, 0, 1/20);

    if (state.running && !state.paused) {
      update(dt);
    }
    render();
    requestAnimationFrame(tick);
  }

  function update(dt) {
    state.time += dt;

    // Difficulty ramps gently
    state.difficulty = 1 + state.time / 45;
    state.speed = 220 + 60 * Math.tanh(state.time / 40);
    const spawnRate = 0.78 / Math.sqrt(state.difficulty);
    state.spawnInterval = clamp(spawnRate, 0.22, 0.78);

    // World scroll (downward)
    groundScroll = (groundScroll + state.speed * dt) % groundTex.height;

    // Player movement
    let mx = 0, my = 0;
    if (keys.has('arrowleft') || keys.has('a')) mx -= 1;
    if (keys.has('arrowright') || keys.has('d')) mx += 1;
    if (keys.has('arrowup') || keys.has('w')) my -= 1;
    if (keys.has('arrowdown') || keys.has('s')) my += 1;

    // Add touch vector
    mx += touch.dx;
    my += touch.dy;

    const mlen = Math.hypot(mx, my) || 1;
    if (mlen > 1) { mx /= mlen; my /= mlen; }

    player.x += mx * player.speed * dt;
    player.y += my * player.speed * dt;

    // Keep player within playfield
    player.x = clamp(player.x, W*0.06, W*0.94);
    player.y = clamp(player.y, H*0.12, H*0.90);

    // Shooting
    state.heat = Math.max(0, state.heat - dt);
    const wantsShoot = shooting || keys.has(' ');
    if (wantsShoot && state.heat <= 0) {
      // fire
      bullets.push({ x: player.x, y: player.y - 20, vy: -state.bulletSpeed, r: 4 });
      state.heat = 0.11; // fire rate
    }

    // Spawn enemies
    state.spawnTimer += dt;
    while (state.spawnTimer >= state.spawnInterval) {
      state.spawnTimer -= state.spawnInterval;
      spawnEnemy();
      if (Math.random() < 0.20) spawnEnemy(); // occasional double spawn
    }

    // Update bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.y += b.vy * dt;
      if (b.y < -40) bullets.splice(i, 1);
    }

    // Update enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      e.x += e.vx * dt;
      e.y += e.vy * dt;
      e.rot += e.spin * dt;
      e.hit = Math.max(0, e.hit - dt);

      // bounce lightly off sides
      if (e.x < W*0.05 || e.x > W*0.95) e.vx *= -1;

      // remove if past bottom
      if (e.y > H + 80) enemies.splice(i, 1);
    }

    // Particles
    for (let i=particles.length-1;i>=0;i--) {
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= Math.pow(0.10, dt); // damp
      p.vy *= Math.pow(0.10, dt);
      p.life -= dt;
      if (p.life <= 0) particles.splice(i,1);
    }

    // Collisions: bullets vs enemies
    for (let bi = bullets.length - 1; bi >= 0; bi--) {
      const b = bullets[bi];
      let hitSomething = false;

      for (let ei = enemies.length - 1; ei >= 0; ei--) {
        const e = enemies[ei];
        if (circleHit(b.x, b.y, b.r, e.x, e.y, e.r)) {
          hitSomething = true;
          e.hp -= 1;
          e.hit = 0.10;

          spawnExplosion(b.x, b.y, 6);

          if (e.hp <= 0) {
            spawnExplosion(e.x, e.y, 18);
            state.score += (e.kind === 'tank' ? 250 : e.kind === 'drifter' ? 140 : 90);
            enemies.splice(ei, 1);
          } else {
            state.score += 15;
          }
          break;
        }
      }

      if (hitSomething) bullets.splice(bi, 1);
    }

    // Player collisions
    player.invuln = Math.max(0, player.invuln - dt);
    if (player.invuln <= 0) {
      for (let ei = enemies.length - 1; ei >= 0; ei--) {
        const e = enemies[ei];
        if (circleHit(player.x, player.y, player.r, e.x, e.y, e.r * 0.92)) {
          // hit
          spawnExplosion(player.x, player.y, 30);
          state.lives -= 1;
          player.invuln = 1.6;

          // knock enemy away
          e.vy += 120;
          e.vx += rand(-80, 80);
          e.hit = 0.20;

          if (state.lives <= 0) {
            state.running = false;
            toast('Game Over. Press Restart.');
          } else {
            toast(`Ouch. Lives left: ${state.lives}`);
          }
          break;
        }
      }
    }

    // Wave progression (soft)
    state.wave = 1 + Math.floor(state.time / 25);
  }

  function drawImageCentered(img, x, y, w, h, rot = 0, alpha = 1) {
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(x, y);
    ctx.rotate(rot);
    ctx.drawImage(img, -w/2, -h/2, w, h);
    ctx.restore();
  }

  function render() {
    // Clear
    ctx.fillStyle = '#05060a';
    ctx.fillRect(0, 0, W, H);

    // Ground scroll: tile two copies to fill screen
    const y0 = -groundScroll;
    for (let y = y0; y < H; y += groundTex.height) {
      ctx.drawImage(groundTex, 0, y, W, groundTex.height);
    }

    // Subtle scanline vibe
    ctx.save();
    ctx.globalAlpha = 0.10;
    for (let y=0; y<H; y+=3) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, y, W, 1);
    }
    ctx.restore();

    // Bullets
    for (const b of bullets) {
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fillStyle = '#e9ecff';
      ctx.fill();
      ctx.globalAlpha = 0.25;
      ctx.beginPath();
      ctx.arc(b.x, b.y + 8, b.r*2.2, 0, Math.PI*2);
      ctx.fillStyle = '#8aa0ff';
      ctx.fill();
      ctx.restore();
    }

    // Enemies
    for (const e of enemies) {
      const hitFlash = e.hit > 0 ? 0.65 : 0;
      const a = 1;

      if (e.img) {
        // scale based on radius and image aspect
        const iw = e.img.naturalWidth || e.img.width;
        const ih = e.img.naturalHeight || e.img.height;
        const aspect = iw / Math.max(1, ih);
        const w = e.r * 2.3 * Math.max(0.8, aspect);
        const h = e.r * 2.3 * Math.max(0.8, 1/aspect);

        // shadow glow
        ctx.save();
        ctx.globalAlpha = 0.22;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r*1.9, 0, Math.PI*2);
        ctx.fillStyle = '#ff5a78';
        ctx.fill();
        ctx.restore();

        drawImageCentered(e.img, e.x, e.y, w, h, e.rot, a);

        if (hitFlash) {
          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          ctx.globalAlpha = hitFlash;
          ctx.beginPath();
          ctx.arc(e.x, e.y, e.r*1.8, 0, Math.PI*2);
          ctx.fillStyle = '#ff5a78';
          ctx.fill();
          ctx.restore();
        }
      } else {
        // fallback: procedural enemy glyph
        ctx.save();
        ctx.translate(e.x, e.y);
        ctx.rotate(e.rot);

        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.moveTo(0, -e.r*1.2);
        ctx.lineTo(e.r*1.1, e.r*1.0);
        ctx.lineTo(0, e.r*0.6);
        ctx.lineTo(-e.r*1.1, e.r*1.0);
        ctx.closePath();
        ctx.fillStyle = '#cfd6ff';
        ctx.fill();

        ctx.globalAlpha = 0.35;
        ctx.beginPath();
        ctx.arc(0, 0, e.r*1.4, 0, Math.PI*2);
        ctx.fillStyle = '#ff5a78';
        ctx.fill();

        if (hitFlash) {
          ctx.globalAlpha = hitFlash;
          ctx.beginPath();
          ctx.arc(0, 0, e.r*1.5, 0, Math.PI*2);
          ctx.fillStyle = '#ff5a78';
          ctx.fill();
        }
        ctx.restore();
      }

      // HP pip for beefy enemies
      if (e.hp > 1) {
        ctx.save();
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = 'rgba(255,255,255,0.18)';
        ctx.fillRect(e.x - 18, e.y - e.r - 16, 36, 6);
        ctx.fillStyle = 'rgba(140,160,255,0.65)';
        ctx.fillRect(e.x - 18, e.y - e.r - 16, 36 * (e.hp / (e.kind === 'tank' ? 4 : 2)), 6);
        ctx.restore();
      }
    }

    // Particles
    ctx.save();
    for (const p of particles) {
      ctx.globalAlpha = clamp(p.life * 2, 0, 1) * 0.85;
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.fillRect(p.x, p.y, 2, 2);
    }
    ctx.restore();

    // Player
    const blink = player.invuln > 0 ? (Math.sin(performance.now()/60) * 0.5 + 0.5) : 1;
    const palpha = player.invuln > 0 ? (0.55 + 0.45 * blink) : 1;

    // player shadow glow
    ctx.save();
    ctx.globalAlpha = 0.20 * palpha;
    ctx.beginPath();
    ctx.arc(player.x, player.y + 18, player.r*2.2, 0, Math.PI*2);
    ctx.fillStyle = '#8aa0ff';
    ctx.fill();
    ctx.restore();

    // draw player image, keep it sane-sized
    const pW = player.r * 2.6;
    const pH = player.r * 2.6;
    drawImageCentered(playerImg, player.x, player.y, pW, pH, 0, palpha);

    // UI text overlay (top center)
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.font = '700 16px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(255,255,255,0.86)';
    ctx.fillText(`WAVE ${state.wave}`, W/2, 28);
    ctx.restore();

    // Game over overlay
    if (!state.running) {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(0,0,W,H);
      ctx.textAlign = 'center';
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.font = '900 44px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
      ctx.fillText('GAME OVER', W/2, H/2 - 10);
      ctx.font = '700 16px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.fillText('Press Restart (or R)', W/2, H/2 + 24);
      ctx.restore();
    }

    // HUD stats text (DOM)
    statsEl.textContent =
      `Score: ${state.score}  路  Lives: ${state.lives}  路  Enemies: ${enemies.length}  路  Bullets: ${bullets.length}  路  Enemy Pool: ${enemyPoolCount()}  路  ${state.paused ? 'Paused' : 'Running'}`;
  }

  // Start loop
  requestAnimationFrame(tick);

  // Nice little nudge if no enemies have been added
  setTimeout(() => {
    if (enemyPoolCount() === 0) toast('Add enemy images to make this more cursed.');
  }, 700);
})();
</script>
</body>
</html>
