<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Game</title>
  <style>
    /* random-game.html
       Simple WASD "walk-around" with an infinitely tiling, parallax background.
       Background: /media/images/networks.png
       Player:     /media/images/gifs/eyes.gif

       Notes:
       - The background is a CSS repeating background-image, so it tiles seamlessly and efficiently.
       - The player is an <img>, so animated GIF frames render/animate normally (canvas usually won't).
    */

    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: #cfcfcf;
    }

    #game {
      position: fixed;
      inset: 0;
      /* The tileable texture */
      background-image: url("/media/images/networks.png");
      background-repeat: repeat;
      background-size: auto; /* keep native scale; change to "512px 512px" if you want */
      background-position: 0px 0px;
      image-rendering: auto;
      cursor: none;
    }

    /* Optional subtle vignette/contrast to make the sprite pop */
    #overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(closest-side, rgba(0,0,0,0.05), rgba(0,0,0,0.55)),
        linear-gradient(to bottom, rgba(0,0,0,0.15), rgba(0,0,0,0.35));
      mix-blend-mode: multiply;
    }

    #player {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 96px;
      height: 96px;
      transform: translate(-50%, -50%);
      user-select: none;
      -webkit-user-drag: none;
      pointer-events: none;
      /* a tiny glow so it reads against bright nodes */
      filter: drop-shadow(0 0 10px rgba(0, 255, 170, 0.35)) drop-shadow(0 0 18px rgba(255, 90, 0, 0.25));
    }

    #hud {
      position: fixed;
      left: 12px;
      top: 10px;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
      font-size: 12px;
      line-height: 1.35;
      user-select: none;
    }

    #hud b { color: #fff; }
    #hud .dim { opacity: 0.8; }
    #hud kbd {
      font: inherit;
      padding: 1px 6px;
      border-radius: 6px;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.14);
    }
  </style>
</head>

<body>
  <div id="game" aria-label="Game background"></div>
  <div id="overlay"></div>
  <img id="player" src="/media/images/gifs/eyes.gif" alt="Player" />

  <div id="hud">
    <div><b>WASD</b> move <span class="dim">(or arrow keys)</span></div>
    <div><kbd>Shift</kbd> sprint</div>
    <div id="coords" class="dim">x: 0, y: 0</div>
  </div>

  <script>
    (() => {
      const bg = document.getElementById("game");
      const coordsEl = document.getElementById("coords");

      // World-space player position (the sprite stays centered; the world moves).
      const player = {
        x: 0,
        y: 0,
        speed: 260,   // pixels/sec
        sprint: 1.85
      };

      // Parallax factor:
      // 1.0  -> background moves 1:1 with world (feels "attached")
      // 0.25 -> background lags (more depth)
      const PARALLAX = 0.35;

      const keys = new Set();
      let lastT = performance.now();

      function onKey(e, down) {
        // Prevent scrolling with arrows/space.
        const block = ["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "];
        if (block.includes(e.key)) e.preventDefault();

        if (down) keys.add(e.key.toLowerCase());
        else keys.delete(e.key.toLowerCase());
      }

      window.addEventListener("keydown", (e) => onKey(e, true), { passive: false });
      window.addEventListener("keyup", (e) => onKey(e, false), { passive: false });

      function step(t) {
        const dt = Math.min(0.05, (t - lastT) / 1000); // cap dt to avoid huge jumps
        lastT = t;

        const up    = keys.has("w") || keys.has("arrowup");
        const down  = keys.has("s") || keys.has("arrowdown");
        const left  = keys.has("a") || keys.has("arrowleft");
        const right = keys.has("d") || keys.has("arrowright");
        const shift = keys.has("shift");

        let vx = (right ? 1 : 0) - (left ? 1 : 0);
        let vy = (down ? 1 : 0) - (up ? 1 : 0);

        // Normalize diagonal movement so it isn't faster.
        if (vx !== 0 || vy !== 0) {
          const len = Math.hypot(vx, vy);
          vx /= len; vy /= len;
        }

        const spd = player.speed * (shift ? player.sprint : 1);
        player.x += vx * spd * dt;
        player.y += vy * spd * dt;

        // Infinitely tiling background scroll with parallax.
        // Negative so the world scrolls opposite the player's direction.
        const bx = (-player.x * PARALLAX);
        const by = (-player.y * PARALLAX);
        bg.style.backgroundPosition = `${bx.toFixed(2)}px ${by.toFixed(2)}px`;

        coordsEl.textContent = `x: ${player.x.toFixed(1)}, y: ${player.y.toFixed(1)} | parallax: ${PARALLAX}`;

        requestAnimationFrame(step);
      }

      requestAnimationFrame(step);
    })();
  </script>
</body>
</html>
