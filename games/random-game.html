<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Game</title>
  <style>
    /* random-game.html
       WASD movement with an infinitely tiling, parallax background.

       Background: /media/images/networks.png
       Player:     /media/images/gifs/eyes.gif

       Performance notes:
       - The old version animated background-position (forces frequent repaints).
       - This version moves a dedicated background layer using translate3d (GPU-friendly, much less jank).
    */

    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: #000;
    }

    #game {
      position: fixed;
      inset: 0;
      cursor: none;
      background: #000;
    }

    /* Big layer that tiles forever and we just slide it around.
       Oversized so it always covers the viewport even while translated. */
    #bgLayer {
      position: absolute;
      left: -100vw;
      top: -100vh;
      width: 300vw;
      height: 300vh;

      background-image: url("/media/images/networks.png");
      background-repeat: repeat;
      background-size: auto;

      will-change: transform;
      transform: translate3d(0, 0, 0);
      pointer-events: none;
    }

    /* Optional subtle vignette to make the sprite pop */
    #overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(closest-side, rgba(0,0,0,0.05), rgba(0,0,0,0.55)),
        linear-gradient(to bottom, rgba(0,0,0,0.15), rgba(0,0,0,0.35));
      mix-blend-mode: multiply;
    }

    #player {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 96px;
      height: 96px;
      transform: translate(-50%, -50%);
      user-select: none;
      -webkit-user-drag: none;
      pointer-events: none;
      filter: drop-shadow(0 0 10px rgba(0, 255, 170, 0.35)) drop-shadow(0 0 18px rgba(255, 90, 0, 0.25));
    }
  </style>
</head>

<body>
  <div id="game" aria-label="Game">
    <div id="bgLayer" aria-hidden="true"></div>
  </div>
  <div id="overlay" aria-hidden="true"></div>
  <img id="player" src="/media/images/gifs/eyes.gif" alt="Player" />

  <script>
    (() => {
      const bgLayer = document.getElementById("bgLayer");

      // World-space player position (the sprite stays centered; the world moves).
      const player = {
        x: 0,
        y: 0,
        speed: 280,   // px/sec
        sprint: 1.85
      };

      // Parallax factor:
      // lower = more "far away", higher = more "attached".
      const PARALLAX = 0.35;

      // Keep transform values bounded so they don't grow forever.
      // This helps precision and can reduce stutter on some browsers.
      const WRAP = 2048; // px

      const keys = new Set();
      let lastT = performance.now();

      function onKey(e, down) {
        const block = ["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "];
        if (block.includes(e.key)) e.preventDefault();
        if (down) keys.add(e.key.toLowerCase());
        else keys.delete(e.key.toLowerCase());
      }

      window.addEventListener("keydown", (e) => onKey(e, true), { passive: false });
      window.addEventListener("keyup", (e) => onKey(e, false), { passive: false });

      function mod(n, m) {
        return ((n % m) + m) % m;
      }

      function step(t) {
        const dt = Math.min(0.05, (t - lastT) / 1000);
        lastT = t;

        const up    = keys.has("w") || keys.has("arrowup");
        const down  = keys.has("s") || keys.has("arrowdown");
        const left  = keys.has("a") || keys.has("arrowleft");
        const right = keys.has("d") || keys.has("arrowright");
        const shift = keys.has("shift");

        let vx = (right ? 1 : 0) - (left ? 1 : 0);
        let vy = (down ? 1 : 0) - (up ? 1 : 0);

        if (vx !== 0 || vy !== 0) {
          const len = Math.hypot(vx, vy);
          vx /= len; vy /= len;
        }

        const spd = player.speed * (shift ? player.sprint : 1);
        player.x += vx * spd * dt;
        player.y += vy * spd * dt;

        // Move background layer with parallax using GPU-friendly transform.
        // Wrap to keep numbers small.
        const bx = mod(-player.x * PARALLAX, WRAP);
        const by = mod(-player.y * PARALLAX, WRAP);
        bgLayer.style.transform = `translate3d(${bx.toFixed(2)}px, ${by.toFixed(2)}px, 0)`;

        requestAnimationFrame(step);
      }

      requestAnimationFrame(step);
    })();
  </script>
</body>
</html>
