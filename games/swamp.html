<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Topo Camo Lava Lamp (Fast)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });

  // Offscreen low-res buffer for speed.
  const buf = document.createElement('canvas');
  const bctx = buf.getContext('2d', { alpha:false });

  let DPR = 1, W = 0, H = 0;
  let BW = 0, BH = 0;
  let imageData = null;

  // Adaptive internal scale: lower = faster. Will auto-adjust a bit.
  let quality = 0.75; // start decent; will drop if frame time is bad
  const MIN_Q = 0.45;
  const MAX_Q = 1.00;

  function resize() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W;
    canvas.height = H;

    // internal buffer resolution
    BW = Math.max(220, Math.floor(W * quality));
    BH = Math.max(220, Math.floor(H * quality));
    buf.width = BW;
    buf.height = BH;

    imageData = bctx.createImageData(BW, BH);
  }
  addEventListener('resize', resize, { passive:true });
  resize();

  // --- Interaction: a single "stir" vector + decaying swirl center ---
  let dragging = false;
  let px = 0, py = 0;
  let stirX = 0, stirY = 0;
  let centerX = 0.5, centerY = 0.5; // normalized
  let swirl = 0;

  function pos(e){
    if (e.touches && e.touches.length) {
      return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
    return { x: e.clientX, y: e.clientY };
  }

  function down(e){
    dragging = true;
    const p = pos(e);
    px = p.x; py = p.y;
    centerX = p.x / innerWidth;
    centerY = p.y / innerHeight;
  }

  function move(e){
    const p = pos(e);
    const dx = p.x - px;
    const dy = p.y - py;
    px = p.x; py = p.y;

    // update stir vector (normalized)
    const mag = Math.hypot(dx, dy) || 1;
    const nx = dx / mag;
    const ny = dy / mag;

    // keep a decaying directional bias
    stirX = stirX * 0.75 + nx * 0.25;
    stirY = stirY * 0.75 + ny * 0.25;

    // swirl strength based on speed
    swirl = Math.min(1, swirl * 0.8 + Math.min(1, mag / 40) * 0.35);

    // move swirl center even when not dragging, feels alive
    centerX = p.x / innerWidth;
    centerY = p.y / innerHeight;
  }

  function up(){ dragging = false; }

  canvas.addEventListener('mousedown', down);
  addEventListener('mousemove', (e)=>{ if(dragging) move(e); }, { passive:true });
  addEventListener('mouseup', up, { passive:true });

  canvas.addEventListener('touchstart', (e)=>{ down(e); }, { passive:false });
  canvas.addEventListener('touchmove', (e)=>{ e.preventDefault(); move(e); }, { passive:false });
  canvas.addEventListener('touchend', up, { passive:true });
  canvas.addEventListener('touchcancel', up, { passive:true });

  // --- Fast-ish hash noise (no sin) ---
  function hash(n){
    // integer hash to [0,1)
    n = (n ^ 61) ^ (n >>> 16);
    n = n + (n << 3);
    n = n ^ (n >>> 4);
    n = n * 0x27d4eb2d;
    n = n ^ (n >>> 15);
    return (n >>> 0) / 4294967296;
  }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function smooth(t){ return t*t*(3-2*t); }

  function vnoise(x, y){
    const xi = x|0, yi = y|0;
    const xf = x - xi, yf = y - yi;
    const u = smooth(xf), v = smooth(yf);

    const a = hash((xi*374761393) ^ (yi*668265263));
    const b = hash(((xi+1)*374761393) ^ (yi*668265263));
    const c = hash((xi*374761393) ^ ((yi+1)*668265263));
    const d = hash(((xi+1)*374761393) ^ ((yi+1)*668265263));

    return lerp(lerp(a,b,u), lerp(c,d,u), v);
  }

  // 3 octaves is plenty here (fast)
  function fbm(x, y){
    let f = 0, amp = 0.6, freq = 1.0;
    for(let i=0;i<3;i++){
      f += amp * (vnoise(x*freq, y*freq)*2 - 1);
      freq *= 2.03;
      amp *= 0.5;
    }
    return f; // ~[-1,1]
  }

  function clamp(x){ return x<0?0:x>255?255:x; }
  function clamp01(x){ return x<0?0:x>1?1:x; }

  // topo camo palette (green->olive->khaki->brown)
  function camo(t){
    // quantized "layer cake"
    const bands = 11;
    const s = Math.floor(t * bands) / (bands - 1);

    const A=[20,44,20], B=[60,92,44], C=[110,98,60], D=[70,52,34];
    let r,g,b, m;

    if (s < 0.33){
      m = s/0.33;
      r = lerp(A[0],B[0],m); g = lerp(A[1],B[1],m); b = lerp(A[2],B[2],m);
    } else if (s < 0.66){
      m = (s-0.33)/0.33;
      r = lerp(B[0],C[0],m); g = lerp(B[1],C[1],m); b = lerp(B[2],C[2],m);
    } else {
      m = (s-0.66)/0.34;
      r = lerp(C[0],D[0],m); g = lerp(C[1],D[1],m); b = lerp(C[2],D[2],m);
    }
    return [r,g,b,s];
  }

  // Performance control
  let lastT = performance.now();
  let avgDt = 16;

  function frame(t){
    const dt = t - lastT; lastT = t;
    avgDt = avgDt * 0.92 + dt * 0.08;

    // If things get choppy, lower internal resolution. If stable, raise a bit.
    if (avgDt > 20 && quality > MIN_Q){
      quality = Math.max(MIN_Q, quality - 0.05);
      resize();
    } else if (avgDt < 15.5 && quality < MAX_Q){
      quality = Math.min(MAX_Q, quality + 0.02);
      resize();
    }

    // decay interaction
    stirX *= 0.94;
    stirY *= 0.94;
    swirl *= 0.93;

    const time = t * 0.001;
    const data = imageData.data;

    // coordinate mapping
    const cx = centerX * BW;
    const cy = centerY * BH;

    // noise zoom (tune to taste)
    const scale = 0.018; // larger => more zoomed out
    const driftX = Math.cos(time * 0.12) * 2.2;
    const driftY = Math.sin(time * 0.10) * 2.2;

    let i = 0;
    for (let y = 0; y < BH; y++){
      for (let x = 0; x < BW; x++){
        // swirl around touch/drag center (cheap polar-ish warp)
        const dx = x - cx;
        const dy = y - cy;
        const inv = 1 / (Math.hypot(dx, dy) + 18);
        const sw = swirl * 220 * inv;

        const wx = x + (-dy * sw) + stirX * 26;
        const wy = y + ( dx * sw) + stirY * 26;

        // convert to noise space
        const nx = wx * scale + driftX;
        const ny = wy * scale + driftY;

        // lava-lamp blobs: domain warp via 1 fbm call
        const w = fbm(nx*0.9 + time*0.15, ny*0.9 - time*0.12);
        const hx = nx + w * 0.85;
        const hy = ny - w * 0.85;

        // height field
        let h = fbm(hx*1.25, hy*1.25) * 0.62 + (vnoise(hx*3.2 + time*0.25, hy*3.2 - time*0.18) - 0.5) * 0.35;
        h = clamp01(h * 0.5 + 0.5);

        // camo mixing mask
        const mask = clamp01(fbm(nx*0.75 - 2.0, ny*0.75 + 1.0) * 0.5 + 0.5);
        h = clamp01(h + (mask - 0.5) * 0.16);

        // topo edge: emphasize band transitions
        const bands = 11;
        const band = h * bands;
        const frac = band - (band|0);
        const edge = 1 - Math.abs(frac - 0.5) * 2; // 0..1 (center high)
        const contour = Math.pow(1 - edge, 1.6);    // edges darker

        // base camo color
        const [r0,g0,b0,s] = camo(h);

        // slight "weird gradient" sheen tied to mask + time
        const sheen = (mask - 0.5) * 22 + Math.sin(time + s * 7) * 6;

        const r = clamp(r0 + sheen - contour * 44);
        const g = clamp(g0 + sheen * 0.7 - contour * 44);
        const b = clamp(b0 + sheen * 0.4 - contour * 44);

        data[i++] = r|0;
        data[i++] = g|0;
        data[i++] = b|0;
        data[i++] = 255;
      }
    }

    // Draw low-res to main, scaled up crisp-ish
    bctx.putImageData(imageData, 0, 0);

    ctx.imageSmoothingEnabled = true; // smooth upscaling for gradients
    ctx.drawImage(buf, 0, 0, W, H);

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
