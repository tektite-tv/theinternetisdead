<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Galaga-ish Clone v1.00</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow: hidden;
    }
    #wrap {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #000;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 14px;
      text-shadow: 0 0 6px rgba(0,0,0,0.9);
      pointer-events: none;
      line-height: 1.35;
    }
    #centerMsg {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 30px;
      font-weight: 800;
      text-shadow: 0 0 14px rgba(0,0,0,0.95);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    #centerMsg.show { opacity: 1; }
    #hint {
      position: absolute;
      left: 10px;
      bottom: 10px;
      font-size: 12px;
      opacity: 0.75;
      text-shadow: 0 0 6px rgba(0,0,0,0.9);
      pointer-events: none;
      line-height: 1.35;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>

    <div id="ui">
      <div><b>Galaga-ish Clone v1.00</b></div>
      <div>Move: A/D or ←/→ | Shoot: Space or LMB | Restart: R</div>
      <div>Score: <span id="score">0</span> | Lives: <span id="lives">3</span> | Wave: <span id="wave">1</span></div>
      <div>Enemies: <span id="enemyCount">0</span></div>
    </div>

    <div id="hint">
      Classic rules: don’t get hit. Shoot the swarm. Some will dive. The rest will wiggle menacingly.
    </div>

    <div id="centerMsg"></div>
  </div>

  <script>
    // ================================================================
    // Galaga-ish Clone v1.00 (FULL FILE)
    //
    // - Player bottom, move left/right, shoot up
    // - Enemy formation + lateral march + step-down
    // - Dive attackers
    // - Enemies use random GIFs from /media/images/gifs/index.json
    // - SFX: hitmarker (enemy hit), oof (player hit)
    //
    // Notes:
    // - Uses simple rectangular collision (fast, arcade-feeling)
    // - Deterministic per-image "type" via hash so some GIFs tend to dive more, etc.
    // ================================================================

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const scoreEl = document.getElementById("score");
    const livesEl = document.getElementById("lives");
    const waveEl = document.getElementById("wave");
    const enemyCountEl = document.getElementById("enemyCount");
    const centerMsg = document.getElementById("centerMsg");

    function resize() {
      const r = canvas.getBoundingClientRect();
      canvas.width = Math.floor(r.width);
      canvas.height = Math.floor(r.height);
    }
    window.addEventListener("resize", resize);
    resize();

    // -------------------------
    // Assets (GIF list)
    // -------------------------
    const ENEMY_GIF_INDEX_URL = "/media/images/gifs/index.json";
    const ENEMY_GIF_BASE_URL = "/media/images/gifs/";
    let enemyGifFilenames = [];
    const imageCache = new Map();

    function normalizeIndexJsonToFilenames(json) {
      if (Array.isArray(json)) return json.filter(v => typeof v === "string");
      if (json && typeof json === "object") {
        for (const key of ["files", "gifs", "images", "items"]) {
          if (Array.isArray(json[key])) {
            const out = [];
            for (const it of json[key]) {
              if (typeof it === "string") out.push(it);
              else if (it && typeof it === "object") {
                if (typeof it.name === "string") out.push(it.name);
                else if (typeof it.filename === "string") out.push(it.filename);
                else if (typeof it.file === "string") out.push(it.file);
              }
            }
            if (out.length) return out;
          }
        }
        const keys = Object.keys(json);
        const looks = keys.filter(k => /\.(gif|png|jpg|jpeg|webp)$/i.test(k));
        if (looks.length) return looks;
      }
      return [];
    }

    async function loadEnemyGifIndex() {
      try {
        const res = await fetch(ENEMY_GIF_INDEX_URL, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();
        enemyGifFilenames = normalizeIndexJsonToFilenames(json)
          .map(s => String(s).trim())
          .filter(Boolean)
          .filter(n => !n.endsWith("/") && !n.includes(".."));
        console.log("[Galaga v1.00] Loaded enemy list:", enemyGifFilenames.length);
      } catch (err) {
        console.warn("[Galaga v1.00] Failed to load enemy index.json:", err);
        enemyGifFilenames = [];
      }
    }

    function getOrCreateImage(src) {
      if (imageCache.has(src)) return imageCache.get(src);
      const img = new Image();
      img.src = src;
      imageCache.set(src, img);
      return img;
    }

    function hashStringFNV1a(str) {
      let h = 0x811c9dc5;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 0x01000193);
      }
      return h >>> 0;
    }

    function makeRng(seed) {
      let s = seed >>> 0;
      return function rand() {
        s ^= s << 13; s >>>= 0;
        s ^= s >>> 17; s >>>= 0;
        s ^= s << 5;  s >>>= 0;
        return (s >>> 0) / 4294967296;
      };
    }

    function pickRandomEnemySrc(rand) {
      if (!enemyGifFilenames.length) return null;
      const fn = enemyGifFilenames[Math.floor(rand() * enemyGifFilenames.length)];
      return ENEMY_GIF_BASE_URL + fn;
    }

    loadEnemyGifIndex();

    // -------------------------
    // Audio
    // -------------------------
    const SFX = {
      enemyHit: "/media/audio/hitmarker.mp3",
      playerHit: "/media/audio/oof.mp3"
    };

    const sfxThrottle = {
      enemyHit: { last: 0, minGap: 0.04 },
      playerHit: { last: 0, minGap: 0.18 }
    };

    function playSfx(key, volume = 0.8) {
      const now = performance.now() / 1000;
      const t = sfxThrottle[key];
      if (t && now - t.last < t.minGap) return;
      if (t) t.last = now;

      const a = new Audio(SFX[key]);
      a.volume = volume;
      a.play().catch(() => {});
    }

    // -------------------------
    // Input
    // -------------------------
    const keys = { left: false, right: false, shoot: false };
    let mouseDown = false;

    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "a" || k === "arrowleft") keys.left = true;
      if (k === "d" || k === "arrowright") keys.right = true;
      if (k === " " ) keys.shoot = true;
      if (k === "r") resetGame();
    });

    window.addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (k === "a" || k === "arrowleft") keys.left = false;
      if (k === "d" || k === "arrowright") keys.right = false;
      if (k === " " ) keys.shoot = false;
    });

    canvas.addEventListener("mousedown", (e) => { if (e.button === 0) mouseDown = true; });
    window.addEventListener("mouseup", (e) => { if (e.button === 0) mouseDown = false; });

    // -------------------------
    // Helpers
    // -------------------------
    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

    function aabbOverlap(a, b) {
      return a.x < b.x + b.w &&
             a.x + a.w > b.x &&
             a.y < b.y + b.h &&
             a.y + a.h > b.y;
    }

    // -------------------------
    // Game state
    // -------------------------
    let score = 0;
    let lives = 3;
    let wave = 1;

    const player = {
      x: 0,
      y: 0,
      w: 48,
      h: 18,
      speed: 520,
      iFrames: 0
    };

    const bullets = [];        // player bullets
    const enemyBullets = [];   // enemy bullets (simple)
    const enemies = [];

    // Formation controller
    const formation = {
      x: 0,
      y: 90,
      dir: 1,                // +1 right, -1 left
      speed: 55,
      stepDown: 26,
      boundsPad: 70,
      sway: 0,
      swaySpeed: 0.85
    };

    // Shooting cadence
    let lastShot = 0;
    const SHOT_COOLDOWN = 0.12;

    // Dive cadence
    let lastDive = 0;
    let lastEnemyShot = 0;

    let isGameOver = false;
    let showWaveBannerUntil = 0;

    function resetGame() {
      score = 0;
      lives = 3;
      wave = 1;
      isGameOver = false;
      centerMsg.classList.remove("show");
      centerMsg.textContent = "";
      bullets.length = 0;
      enemyBullets.length = 0;
      enemies.length = 0;
      formation.y = 90;
      formation.dir = 1;
      formation.speed = 55;
      formation.stepDown = 26;
      formation.sway = 0;
      spawnWave(wave);
      layoutPlayer();
      syncUI();
    }

    function layoutPlayer() {
      player.x = (canvas.width - player.w) / 2;
      player.y = canvas.height - 80;
    }

    function showCenter(text, ms = 900) {
      centerMsg.textContent = text;
      centerMsg.classList.add("show");
      showWaveBannerUntil = performance.now() + ms;
    }

    function syncUI() {
      scoreEl.textContent = String(score);
      livesEl.textContent = String(lives);
      waveEl.textContent = String(wave);
      enemyCountEl.textContent = String(enemies.length);
    }

    // -------------------------
    // Enemy creation
    // -------------------------
    function enemyTypeFromSrc(src) {
      // Deterministic "personality" per image
      const name = src ? src.split("/").pop() : "fallback";
      const h = hashStringFNV1a("ETYPE:" + name);

      // 0..3 type band
      // 0: grunt (rare dives)
      // 1: diver (dives more)
      // 2: shooter (fires more)
      // 3: tank (more hp, slower)
      return h % 4;
    }

    function spawnWave(w) {
      enemies.length = 0;
      bullets.length = 0;
      enemyBullets.length = 0;

      // Scale formation a bit with wave
      formation.x = 0;
      formation.y = clamp(90 + (w - 1) * 6, 90, 150);
      formation.speed = 55 + (w - 1) * 6;
      formation.stepDown = clamp(26 + (w - 1) * 1.2, 26, 40);

      const rows = clamp(3 + Math.floor((w - 1) / 2), 3, 6);
      const cols = clamp(8 + Math.floor((w - 1) / 2), 8, 12);

      const cellW = 66;
      const cellH = 54;

      const totalW = cols * cellW;
      formation.x = (canvas.width - totalW) / 2;

      const rand = makeRng(hashStringFNV1a("WAVE:" + w));

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const src = pickRandomEnemySrc(rand);
          const img = src ? getOrCreateImage(src) : null;

          const etype = enemyTypeFromSrc(src);
          const baseSize = 42;
          const size = clamp(baseSize + (rand() * 16 - 8), 30, 56);

          let hp = 1;
          if (etype === 3) hp = 3 + Math.floor(w * 0.2);
          else if (etype === 0) hp = 1;
          else hp = 1 + (w > 6 ? 1 : 0);

          const diveChance = (etype === 1) ? 0.70 : (etype === 0 ? 0.20 : 0.35);
          const shootBias = (etype === 2) ? 0.80 : 0.35;

          enemies.push({
            // "home" position relative to formation
            fx: c * cellW + (cellW - size) / 2,
            fy: r * cellH,

            // current world position (updated each frame)
            x: 0, y: 0,
            w: size, h: size,

            img, src,
            type: etype,
            hp, maxHp: hp,

            state: "formation", // formation | diving | returning
            vx: 0, vy: 0,
            t0: performance.now() / 1000,
            diveChance,
            shootBias,
            flash: 0
          });
        }
      }

      showCenter(`WAVE ${w}`, 900);
      syncUI();
    }

    // -------------------------
    // Shooting
    // -------------------------
    function shoot() {
      const now = performance.now() / 1000;
      if (now - lastShot < SHOT_COOLDOWN) return;
      lastShot = now;

      bullets.push({
        x: player.x + player.w / 2 - 3,
        y: player.y - 10,
        w: 6,
        h: 14,
        vy: -920,
        damage: 1
      });
    }

    function enemyShootFrom(e) {
      // Simple downward shots, not constant
      enemyBullets.push({
        x: e.x + e.w / 2 - 3,
        y: e.y + e.h - 2,
        w: 6,
        h: 14,
        vy: 520 + wave * 10,
        damage: 1
      });
    }

    // -------------------------
    // Update
    // -------------------------
    function update(dt) {
      if (isGameOver) return;

      if (performance.now() > showWaveBannerUntil) {
        centerMsg.classList.remove("show");
      }

      // Player iFrames
      player.iFrames = Math.max(0, player.iFrames - dt);

      // Player move
      let dir = 0;
      if (keys.left) dir -= 1;
      if (keys.right) dir += 1;
      player.x += dir * player.speed * dt;
      player.x = clamp(player.x, 10, canvas.width - player.w - 10);

      // Player shoot
      if (keys.shoot || mouseDown) shoot();

      // Formation movement (classic Galaga-ish march)
      formation.sway += dt * formation.swaySpeed;
      const swayOffset = Math.sin(formation.sway) * 10;

      formation.x += formation.dir * formation.speed * dt;

      // Compute formation bounds from living enemies in formation
      let minX = Infinity, maxX = -Infinity;
      for (const e of enemies) {
        if (e.state === "formation") {
          const ex = formation.x + e.fx;
          minX = Math.min(minX, ex);
          maxX = Math.max(maxX, ex + e.w);
        }
      }

      // If no formation enemies remain, still bounce based on screen edges
      if (minX === Infinity) {
        minX = formation.x;
        maxX = formation.x + 400;
      }

      if (minX < formation.boundsPad) {
        formation.x += (formation.boundsPad - minX);
        formation.dir = 1;
        formation.y += formation.stepDown;
      } else if (maxX > canvas.width - formation.boundsPad) {
        formation.x -= (maxX - (canvas.width - formation.boundsPad));
        formation.dir = -1;
        formation.y += formation.stepDown;
      }

      // Dive selection (peel attackers)
      const now = performance.now() / 1000;

      const alive = enemies.length;
      const diveInterval = clamp(1.7 - wave * 0.06, 0.55, 1.7);
      if (now - lastDive > diveInterval && alive > 0) {
        lastDive = now;

        // Pick a random formation enemy to dive
        const candidates = enemies.filter(e => e.state === "formation");
        if (candidates.length) {
          const pick = candidates[Math.floor(Math.random() * candidates.length)];
          // Chance depends on type
          if (Math.random() < pick.diveChance) {
            pick.state = "diving";
            // Dive toward player with a bit of curve
            const dx = (player.x + player.w/2) - (formation.x + pick.fx + pick.w/2);
            pick.vx = clamp(dx * 0.9, -420, 420);
            pick.vy = 260 + wave * 10;
          }
        }
      }

      // Enemy shooting cadence
      const enemyShotInterval = clamp(1.2 - wave * 0.05, 0.35, 1.2);
      if (now - lastEnemyShot > enemyShotInterval && enemies.length) {
        lastEnemyShot = now;

        // Prefer shooter types and those closer to player x
        const shooters = enemies
          .filter(e => (e.state !== "returning")) // allow formation+diving
          .sort((a, b) => {
            const ax = Math.abs((a.x + a.w/2) - (player.x + player.w/2));
            const bx = Math.abs((b.x + b.w/2) - (player.x + player.w/2));
            // type bias
            const ab = (a.shootBias || 0.35);
            const bb = (b.shootBias || 0.35);
            return (ax - bx) + (bb - ab) * 80;
          });

        if (shooters.length) {
          const e = shooters[Math.floor(Math.random() * Math.min(6, shooters.length))];
          if (Math.random() < (e.shootBias || 0.35)) enemyShootFrom(e);
        }
      }

      // Update enemies positions
      for (const e of enemies) {
        e.flash = Math.max(0, e.flash - dt);

        if (e.state === "formation") {
          e.x = formation.x + e.fx + swayOffset;
          e.y = formation.y + e.fy;
        } else if (e.state === "diving") {
          // Curved-ish dive
          e.vx *= Math.pow(0.15, dt); // slowly reduce x velocity (curve effect)
          e.x += e.vx * dt;
          e.y += e.vy * dt;

          // If passed bottom, return upward to formation
          if (e.y > canvas.height + 40) {
            e.state = "returning";
            e.vx = 0;
            e.vy = -420 - wave * 8;
          }
        } else if (e.state === "returning") {
          // Move upward toward formation band; once near, snap back into formation
          e.y += e.vy * dt;

          // Find its target formation position
          const tx = formation.x + e.fx + swayOffset;
          const ty = formation.y + e.fy;

          // Lerp x toward target while returning
          e.x = e.x + (tx - e.x) * clamp(dt * 3.5, 0, 1);

          if (e.y <= ty) {
            e.state = "formation";
          }
        }
      }

      // Bullets update
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.y += b.vy * dt;
        if (b.y + b.h < -50) bullets.splice(i, 1);
      }

      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const b = enemyBullets[i];
        b.y += b.vy * dt;
        if (b.y > canvas.height + 60) enemyBullets.splice(i, 1);
      }

      // Player bullets vs enemies
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const eb = { x: e.x, y: e.y, w: e.w, h: e.h };

        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          if (aabbOverlap(eb, b)) {
            bullets.splice(j, 1);
            e.hp -= 1;
            e.flash = 0.10;
            playSfx("enemyHit", 0.65);

            if (e.hp <= 0) {
              // score based on type
              const bonus = (e.type === 3) ? 40 : (e.type === 2 ? 30 : (e.type === 1 ? 25 : 20));
              score += bonus + Math.floor(wave * 2);
              enemies.splice(i, 1);
            }
            break;
          }
        }
      }

      // Enemy bullets vs player
      if (player.iFrames <= 0) {
        const pb = { x: player.x, y: player.y, w: player.w, h: player.h };
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
          if (aabbOverlap(pb, enemyBullets[i])) {
            enemyBullets.splice(i, 1);
            takeHit();
            break;
          }
        }
      }

      // Enemy body vs player (classic “you touched it, you lose a life”)
      if (player.iFrames <= 0) {
        const pb = { x: player.x, y: player.y, w: player.w, h: player.h };
        for (const e of enemies) {
          const eb = { x: e.x, y: e.y, w: e.w, h: e.h };
          if (aabbOverlap(pb, eb)) {
            takeHit();
            break;
          }
        }
      }

      // Lose condition: formation marched too far down
      if (formation.y > canvas.height - 220) {
        // It’s Galaga. They reached you. Bad day.
        lives = 0;
        gameOver();
      }

      // Win wave: no enemies left
      if (enemies.length === 0) {
        wave++;
        spawnWave(wave);
      }

      syncUI();
    }

    function takeHit() {
      lives--;
      player.iFrames = 1.0;
      playSfx("playerHit", 0.85);

      // Clear bullets for fairness (classic arcade “reset moment”)
      enemyBullets.length = 0;
      bullets.length = 0;

      if (lives <= 0) gameOver();
    }

    function gameOver() {
      isGameOver = true;
      centerMsg.textContent = "GAME OVER\nPress R to restart";
      centerMsg.classList.add("show");
    }

    // -------------------------
    // Draw
    // -------------------------
    function drawStarfield(t) {
      // cheap starfield: deterministic pseudo-stars based on time
      ctx.save();
      ctx.globalAlpha = 0.9;

      const n = 120;
      for (let i = 0; i < n; i++) {
        const x = (i * 997) % canvas.width;
        const y = ((i * 571) + Math.floor(t * 50)) % canvas.height;
        const a = 0.25 + ((i * 37) % 100) / 160;
        ctx.fillStyle = `rgba(180, 210, 255, ${a})`;
        ctx.fillRect(x, y, 2, 2);
      }
      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const t = performance.now() / 1000;
      drawStarfield(t);

      // Bullets
      ctx.fillStyle = "#ffdd55";
      for (const b of bullets) {
        ctx.fillRect(b.x, b.y, b.w, b.h);
      }

      // Enemy bullets
      ctx.fillStyle = "rgba(255, 110, 110, 0.95)";
      for (const b of enemyBullets) {
        ctx.fillRect(b.x, b.y, b.w, b.h);
      }

      // Enemies (GIFs)
      for (const e of enemies) {
        if (e.img && e.img.complete && e.img.naturalWidth > 0) {
          ctx.save();
          if (e.flash > 0) ctx.globalAlpha = 0.65;
          ctx.drawImage(e.img, e.x, e.y, e.w, e.h);
          ctx.restore();
        } else {
          // fallback block if gif hasn't loaded yet
          ctx.save();
          ctx.fillStyle = "rgba(255, 80, 80, 0.85)";
          ctx.fillRect(e.x, e.y, e.w, e.h);
          ctx.restore();
        }

        // tiny hp pip for tanks (optional readability)
        if (e.maxHp > 1) {
          const pct = clamp(e.hp / e.maxHp, 0, 1);
          ctx.save();
          ctx.fillStyle = "rgba(0,0,0,0.55)";
          ctx.fillRect(e.x, e.y - 8, e.w, 5);
          ctx.fillStyle = "rgba(90,255,120,0.9)";
          ctx.fillRect(e.x, e.y - 8, e.w * pct, 5);
          ctx.restore();
        }
      }

      // Player
      ctx.save();
      if (player.iFrames > 0) {
        const blink = Math.floor((performance.now() / 100) % 2) === 0;
        ctx.globalAlpha = blink ? 0.35 : 0.85;
      }
      ctx.fillStyle = "#55aaff";
      ctx.fillRect(player.x, player.y, player.w, player.h);

      // little "ship" nose
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(player.x + player.w/2 - 4, player.y - 6, 8, 6);

      ctx.restore();
    }

    // -------------------------
    // Main loop
    // -------------------------
    layoutPlayer();
    spawnWave(wave);

    let last = performance.now();
    function loop(now) {
      const dt = clamp((now - last) / 1000, 0, 0.05);
      last = now;

      // Keep player positioned relative to resize
      // (This is intentionally gentle; you can still be mid-dodge.)
      if (canvas.width !== Math.floor(canvas.getBoundingClientRect().width) ||
          canvas.height !== Math.floor(canvas.getBoundingClientRect().height)) {
        const oldW = canvas.width;
        resize();
        // preserve relative x position
        const ratio = oldW > 0 ? (player.x / oldW) : 0.5;
        player.x = ratio * canvas.width;
        player.y = canvas.height - 80;
      }

      update(dt);
      draw();

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
