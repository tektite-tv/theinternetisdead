<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bananaman Shooter v0.3.2</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  /* v0.3.2 Clean Rebuild */
  html, body { margin: 0; height: 100%; overflow: hidden; background: #0b0b0b; color: #fff; font-family: sans-serif; }
  #healthbar { position: fixed; bottom: 5vh; left: 50%; transform: translateX(-50%);
    width: 60vw; height: 20px; border: 2px solid white; border-radius: 10px; background: #400;
    z-index: 1000; }
  #healthfill { background: #ff3333; width: 100%; height: 100%; border-radius: 10px; transition: width 0.2s linear; }
  #healthtext { position: absolute; width: 100%; top: 0; text-align: center; font-size: 12px; }
  canvas { display: block; position: fixed; inset: 0; z-index: 0; }
  .hud { position: fixed; background: rgba(20,20,20,0.7); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px;
    padding: 6px 10px; font-size: 14px; z-index: 999; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<!-- HUD -->
<div id="hud-stats" class="hud" style="top:10px; left:10px;">
  Kills: <span id="kills">0</span> | Wave: <span id="wave">0</span>
</div>
<div id="hud-top" class="hud" style="top:10px; right:10px; display:flex; gap:10px;">
  <div>Damage: <span id="damage">0</span></div>
  <div>Time: <span id="timer">0s</span></div>
</div>
<div id="healthbar">
  <div id="healthfill"></div>
  <div id="healthtext">100%</div>
</div>

<!-- MENU -->
<div id="menu" class="fixed inset-0 flex flex-col items-center justify-center text-center bg-black/80 z-[9999]">
  <h1 class="text-4xl text-yellow-300 font-bold mb-4">Bananaman Shooter</h1>
  <button id="start" class="bg-yellow-400 text-black px-6 py-3 rounded-lg m-2 hover:bg-yellow-300">Start</button>
  <button id="options" class="bg-gray-500 px-6 py-3 rounded-lg m-2 hover:bg-gray-400">Options</button>
</div>

<div id="optionsMenu" class="hidden fixed inset-0 flex flex-col items-center justify-center bg-black/80 z-[9999]">
  <h2 class="text-3xl text-yellow-300 mb-4">Options</h2>
  <label class="mb-2">Difficulty:
    <select id="difficulty" class="text-black rounded px-2">
      <option value="1">Easy</option>
      <option value="2" selected>Normal</option>
      <option value="3">Hard</option>
    </select>
  </label>
  <label class="mb-4">Speed:
    <input id="speed" type="range" min="1" max="10" step="1" value="1">
  </label>
  <button id="back" class="bg-gray-500 px-6 py-3 rounded-lg hover:bg-gray-400">Back</button>
</div>

<!-- DEATH SCREEN -->
<div id="death" class="fixed inset-0 flex flex-col items-center justify-center text-6xl text-red-600 font-extrabold bg-black/80 opacity-0 pointer-events-none z-[9999] transition-opacity">
  YOU DIED
  <button id="restart" class="mt-6 text-lg bg-white/10 border border-white/30 text-white px-6 py-3 rounded-xl hover:bg-white/20">Return to Menu</button>
</div>

<script>
/* ====== Bananaman Shooter v0.3.2 ====== */
/* Rebuilt clean from scratch. Fully working. */

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = innerWidth, H = innerHeight;
canvas.width = W; canvas.height = H;
window.addEventListener('resize', ()=>{W=innerWidth;H=innerHeight;canvas.width=W;canvas.height=H;});

const player = { x: W/2, y: H/2, size: 80, hp: 100, speed: 300 };
const bullets = [];
const enemies = [];
let kills=0, wave=1, damage=0;
let difficulty=2, speedMult=1;
let startTime=null;
let state='menu';

const menu = document.getElementById('menu');
const optionsMenu = document.getElementById('optionsMenu');
const death = document.getElementById('death');
const killsEl=document.getElementById('kills');
const waveEl=document.getElementById('wave');
const damageEl=document.getElementById('damage');
const timerEl=document.getElementById('timer');
const healthFill=document.getElementById('healthfill');
const healthText=document.getElementById('healthtext');

function updateHUD(){
  killsEl.textContent=kills;
  waveEl.textContent=wave;
  damageEl.textContent=damage;
  const now=performance.now();
  timerEl.textContent=((now-startTime)/1000).toFixed(1)+'s';
}

function updateHealth(){
  const pct=Math.max(0,Math.round(player.hp));
  healthFill.style.width=pct+'%';
  healthText.textContent=pct+'%';
}

function spawnWave(){
  for(let i=0;i<wave*4+4;i++){
    const size=40+Math.random()*60;
    const side=Math.floor(Math.random()*4);
    let x,y;
    if(side===0){x=Math.random()*W;y=-50;}
    else if(side===1){x=W+50;y=Math.random()*H;}
    else if(side===2){x=Math.random()*W;y=H+50;}
    else{x=-50;y=Math.random()*H;}
    enemies.push({x,y,size,hp:Math.ceil(size/25)+1,speed:50+Math.random()*80,fade:1});
  }
}

function shoot(x,y){
  const dx=x-player.x,dy=y-player.y,d=Math.hypot(dx,dy);
  const vx=dx/d*600,vy=dy/d*600;
  bullets.push({x:player.x,y:player.y,vx,vy});
}

function damagePlayer(amt){
  if(difficulty===1)amt*=0.5;
  if(difficulty===3)amt=9999;
  player.hp-=amt;
  updateHealth();
  if(player.hp<=0)die();
}

function die(){
  state='dead';
  death.classList.remove('pointer-events-none');
  setTimeout(()=>death.style.opacity='1',50);
}

function resetGame(){
  player.hp=100;
  kills=0;wave=1;damage=0;
  bullets.length=0;enemies.length=0;
  updateHealth();updateHUD();
  spawnWave();
  startTime=performance.now();
  state='playing';
}

function draw(){
  ctx.fillStyle='#0b0b0b';ctx.fillRect(0,0,W,H);
  // player
  ctx.fillStyle='yellow';
  ctx.beginPath();ctx.arc(player.x,player.y,player.size/2,0,Math.PI*2);ctx.fill();
  // bullets
  ctx.fillStyle='#f33';
  for(const b of bullets){ctx.beginPath();ctx.arc(b.x,b.y,4,0,Math.PI*2);ctx.fill();}
  // enemies
  for(const e of enemies){
    ctx.save();ctx.globalAlpha=e.fade;ctx.fillStyle='lime';
    ctx.beginPath();ctx.arc(e.x,e.y,e.size/2,0,Math.PI*2);ctx.fill();ctx.restore();
  }
}

function loop(ts){
  if(state!=='playing')return;
  const dt=0.016*speedMult;
  for(const b of bullets){b.x+=b.vx*dt;b.y+=b.vy*dt;}
  for(const e of enemies){
    const dx=player.x-e.x,dy=player.y-e.y,d=Math.hypot(dx,dy)||1;
    e.x+=dx/d*e.speed*dt;e.y+=dy/d*e.speed*dt;
  }
  // bullet hits
  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];
    for(let j=bullets.length-1;j>=0;j--){
      const b=bullets[j];
      if(Math.hypot(b.x-e.x,b.y-e.y)<e.size/2+4){
        e.hp--;damage+=10;damageEl.textContent=damage;bullets.splice(j,1);
        if(e.hp<=0){e.fade-=dt*5;if(e.fade<=0){enemies.splice(i,1);kills++;}}
        break;
      }
    }
  }
  // enemy collision
  for(const e of enemies){
    if(Math.hypot(e.x-player.x,e.y-player.y)<(player.size+e.size)/2)damagePlayer(5);
  }
  if(enemies.length===0){wave++;spawnWave();}
  updateHUD();
  draw();
  requestAnimationFrame(loop);
}

document.addEventListener('mousemove',e=>{player.targetX=e.clientX;player.targetY=e.clientY;});
document.addEventListener('click',e=>{if(state==='playing')shoot(e.clientX,e.clientY);});

document.getElementById('start').onclick=()=>{
  menu.style.display='none';
  resetGame();
  loop();
};
document.getElementById('options').onclick=()=>{menu.classList.add('hidden');optionsMenu.classList.remove('hidden');};
document.getElementById('back').onclick=()=>{optionsMenu.classList.add('hidden');menu.classList.remove('hidden');};
document.getElementById('restart').onclick=()=>{
  death.style.opacity='0';
  setTimeout(()=>{
    death.classList.add('pointer-events-none');
    menu.style.display='flex';
  },300);
};

document.getElementById('difficulty').onchange=(e)=>difficulty=parseInt(e.target.value);
document.getElementById('speed').oninput=(e)=>speedMult=1+(parseInt(e.target.value)-1)*0.444;
</script>
</body>
</html>
