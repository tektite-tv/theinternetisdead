<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Galaga-ish Clone v1.11</title>
<style>
  html, body { margin:0; padding:0; background:black; overflow:hidden; color:#0f0; font-family:monospace; }
  canvas { display:block; }
  #overlay{
    position:absolute; top:10px; left:10px; font-size:14px; line-height:1.4; pointer-events:none;
    text-shadow:0 0 6px rgba(0,255,0,0.35);
  }

  #uiRoot{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
  .panel{
    pointer-events:auto;
    width:min(520px, 92vw);
    border:1px solid rgba(0,255,0,0.35);
    border-radius:14px;
    background: rgba(0,0,0,0.72);
    box-shadow: 0 0 28px rgba(0,255,0,0.08);
    padding: 18px 18px 16px;
    text-align:center;
  }
  .title{ font-size:26px; letter-spacing:1px; margin:4px 0 10px; }
  .subimg{
    width:120px; height:120px; display:block; margin:0 auto 10px;
    image-rendering:pixelated; filter: drop-shadow(0 0 8px rgba(0,255,0,0.18));
  }
  .btnRow{ display:flex; gap:10px; justify-content:center; margin-top:12px; flex-wrap:wrap; }
  button{
    font-family:monospace; color:#0f0; background:rgba(0,0,0,0.55);
    border:1px solid rgba(0,255,0,0.45);
    padding:10px 14px; border-radius:12px; cursor:pointer; min-width:160px;
  }
  button:hover{ background: rgba(0,255,0,0.08); }
  .smallBtn{ min-width:120px; padding:8px 12px; border-radius:10px; }
  .optionsGrid{ display:grid; grid-template-columns:1fr; gap:12px; text-align:left; margin-top:10px; }
  .optRow{ border:1px solid rgba(0,255,0,0.2); border-radius:12px; padding:10px 12px; background: rgba(0,0,0,0.35); }
  .optLabel{ display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; font-size:14px; }
  input[type="range"]{ width:100%; accent-color:#00ff66; }
  .hint{ opacity:0.8; font-size:12px; margin-top:10px; line-height:1.35; }
  .statusLine{ margin-top:10px; font-size:12px; opacity:0.9; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="overlay"></div>

<div id="uiRoot">
  <div id="startMenu" class="panel">
    <div class="title">GALAGA-ISH CLONE</div>
    <img class="subimg" src="/media/images/gifs/bananarama.gif" alt="bananarama" />
    <div class="hint">Move: A/D or ⬅➡ · Shoot: Space · ESC: Menu</div>
    <div class="btnRow">
      <button id="btnStart">Start Game</button>
      <button id="btnOptions">Options</button>
    </div>
    <div id="assetStatus" class="statusLine">Loading enemy images...</div>
  </div>

  <div id="optionsMenu" class="panel" style="display:none;">
    <div class="title">OPTIONS</div>

    <div class="optionsGrid">
      <div class="optRow">
        <div class="optLabel"><span>Enemy Rows</span><span id="rowsVal">4</span></div>
        <input id="rowsSlider" type="range" min="1" max="10" value="4" step="1" />
      </div>

      <div class="optRow">
        <div class="optLabel"><span>Enemy Columns</span><span id="colsVal">6</span></div>
        <input id="colsSlider" type="range" min="1" max="14" value="6" step="1" />
      </div>

      <div class="optRow">
        <div class="optLabel"><span>Total Enemies</span><span id="totalVal">24</span></div>
        <div class="hint">Rows × Columns. More enemies = more chaos.</div>
      </div>
    </div>

    <div class="btnRow" style="margin-top:14px;">
      <button id="btnBack" class="smallBtn">Back</button>
      <button id="btnApply" class="smallBtn">Apply</button>
    </div>
  </div>
</div>

<script>
/* ======================================================================
  PROJECT CHANGELOG / REMOVAL LOG
  Purpose: Permanent in-file audit trail of removed/disabled features, so
  future changes are reversible without myth-making.

  Rules:
  - If functionality is REMOVED or DISABLED, log it here.
  - Include: date (YYYY-MM-DD), version tag, what changed, why, where.
========================================================================

[REMOVAL LOG]

- 2025-12-17 | v1.10
  Removed/Not implemented: Full enemy AI pathing / per-enemy movement styles.
  Reason: Current build uses classic formation movement (left/right bounce + step down).
  Previous location: N/A (never implemented in this version).
  Re-add idea: Give each enemy individual velocity + patterns (sine drift, dive-bomb, orbit).

- 2025-12-17 | v1.10
  Removed/Not implemented: Enemy spawn waves / waypoint-based difficulty scaling.
  Reason: Replaced with simple wave increment on clear, + faster enemy bullets / formation speed.
  Previous location: N/A
  Re-add idea: Wave configs array + spawn scheduler.

- 2025-12-17 | v1.10
  Removed/Not implemented: Boss at wave 6 (NO_U_cycle.gif with orbiting minis + YOU WIN overlay).
  Reason: Not in current file scope while stabilizing movement/collisions/sfx.
  Previous location: N/A
  Re-add idea: On wave === 6: spawn boss entity + orbit children + win overlay on defeat.

- 2025-12-17 | v1.10
  Removed: Reliance on `e.key === " "` for shooting.
  Reason: Inconsistent across browsers; replaced with `e.code === "Space"`.
  Previous location: keydown handler.
  Re-add: Don’t. This was the bug.

- 2025-12-17 | v1.11
  Modified: Player firing rate and bullet speed.
  Reason: Bullets were too frequent/fast and flattened difficulty pacing.
  Previous behavior: Unlimited fire cadence, bullet vy ≈ -10.
  Current behavior: Cooldown enforced (~50% slower), bullet vy reduced.
  Location: shoot() + update(dt) cooldown tick.

====================================================================== */


/* =========================================================
   v1.11 FEATURES (retained + updated)
   - Start Menu + Options (enemy rows/cols)
   - Enemy sprite pool loads all gifs from /media/images/gifs/index.json
   - Enemy formation movement (left/right bounce + step down)
   - Player bullets hit enemies (hitmarker.mp3)
   - Enemy bullets + contact damage hit player (oof.mp3)
   - Wave progression: clear formation -> next wave
   - v1.11: slower player fire rate + slower bullets
========================================================= */

/* =======================
   Paths (EDIT IF NEEDED)
======================= */
const GIF_BASE = "/media/images/gifs/";
const AUDIO_HIT = "/media/audio/hitmarker.mp3";
const AUDIO_OOF = "/media/audio/oof.mp3";

/* =======================
   Player Firing Tuning (v1.11)
======================= */
const PLAYER_FIRE_COOLDOWN = 0.32; // seconds (~50% fewer bullets than spam)
const PLAYER_BULLET_SPEED  = -6.5; // slower bullets

/* =======================
   Canvas + Globals
======================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const overlay = document.getElementById("overlay");
function resize(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener("resize", resize);
resize();

let time = 0;
let score = 0;
let lives = 3;
let wave = 1;

const STATE = { MENU:"menu", OPTIONS:"options", PLAYING:"playing" };
let gameState = STATE.MENU;

/* =======================
   Audio (unlock + play)
======================= */
const sfxHit = new Audio(AUDIO_HIT);
const sfxOof = new Audio(AUDIO_OOF);
sfxHit.preload = "auto";
sfxOof.preload = "auto";
sfxHit.volume = 0.7;
sfxOof.volume = 0.8;

let audioUnlocked = false;
function unlockAudioOnce(){
  if (audioUnlocked) return;
  audioUnlocked = true;

  // Autoplay restrictions: browsers insist on "gesture".
  try{
    sfxHit.muted = true;
    sfxHit.play().then(() => {
      sfxHit.pause();
      sfxHit.currentTime = 0;
      sfxHit.muted = false;
    }).catch(()=>{ sfxHit.muted = false; });

    sfxOof.muted = true;
    sfxOof.play().then(() => {
      sfxOof.pause();
      sfxOof.currentTime = 0;
      sfxOof.muted = false;
    }).catch(()=>{ sfxOof.muted = false; });
  }catch(e){}
}

function playSfx(a){
  // Clone so rapid events don't cut off sound.
  try{
    const c = a.cloneNode();
    c.volume = a.volume;
    c.play().catch(()=>{});
  }catch(e){}
}

/* =======================
   UI
======================= */
const uiRoot = document.getElementById("uiRoot");
const startMenu = document.getElementById("startMenu");
const optionsMenu = document.getElementById("optionsMenu");
const assetStatus = document.getElementById("assetStatus");

const btnStart = document.getElementById("btnStart");
const btnOptions = document.getElementById("btnOptions");
const btnBack = document.getElementById("btnBack");
const btnApply = document.getElementById("btnApply");

const rowsSlider = document.getElementById("rowsSlider");
const colsSlider = document.getElementById("colsSlider");
const rowsVal = document.getElementById("rowsVal");
const colsVal = document.getElementById("colsVal");
const totalVal = document.getElementById("totalVal");

let ENEMY_ROWS = parseInt(rowsSlider.value, 10);
let ENEMY_COLS = parseInt(colsSlider.value, 10);

function syncOptionsLabels(){
  rowsVal.textContent = rowsSlider.value;
  colsVal.textContent = colsSlider.value;
  totalVal.textContent = (parseInt(rowsSlider.value,10) * parseInt(colsSlider.value,10)).toString();
}
rowsSlider.addEventListener("input", syncOptionsLabels);
colsSlider.addEventListener("input", syncOptionsLabels);
syncOptionsLabels();

function showMenu(){
  gameState = STATE.MENU;
  startMenu.style.display = "block";
  optionsMenu.style.display = "none";
  uiRoot.style.display = "flex";
}
function showOptions(){
  gameState = STATE.OPTIONS;
  startMenu.style.display = "none";
  optionsMenu.style.display = "block";
  uiRoot.style.display = "flex";
}
function startGame(){
  unlockAudioOnce();
  gameState = STATE.PLAYING;
  uiRoot.style.display = "none";

  score = 0;
  lives = 3;
  wave = 1;

  bullets.length = 0;
  enemyBullets.length = 0;

  fireCooldown = 0;
  resetFormation();
  spawnEnemies();
  window.focus();
}

btnStart.addEventListener("click", startGame);
btnOptions.addEventListener("click", showOptions);
btnBack.addEventListener("click", showMenu);
btnApply.addEventListener("click", () => {
  ENEMY_ROWS = parseInt(rowsSlider.value, 10);
  ENEMY_COLS = parseInt(colsSlider.value, 10);
  resetFormation();
  spawnEnemies();
});

/* =======================
   Player
======================= */
const playerImg = new Image();
playerImg.src = GIF_BASE + "bananarama.gif";

const player = {
  x: canvas.width/2,
  y: canvas.height-80,
  w: 48,
  h: 48,
  speed: 6,
  invuln: 0
};

const keys = {};

// v1.11: fire cooldown timer
let fireCooldown = 0;

/* =======================
   Enemy Images from index.json
======================= */
let enemyImages = [];
let assetsReady = false;

const FALLBACK_URLS = [
  GIF_BASE + "frog.gif",
  GIF_BASE + "skeleton.gif",
  GIF_BASE + "dragon.gif",
  GIF_BASE + "firework.gif"
];

function setAssetStatus(msg){ assetStatus.textContent = msg; }

function preloadImages(urls){
  return new Promise((resolve) => {
    const imgs = [];
    let done = 0;
    if (!urls.length) resolve(imgs);

    urls.forEach((url) => {
      const img = new Image();
      img.onload = () => { done++; if (done === urls.length) resolve(imgs); };
      img.onerror = () => { done++; if (done === urls.length) resolve(imgs); };
      img.src = url;
      imgs.push(img);
    });
  });
}

async function loadEnemyImagesFromIndex(){
  try{
    setAssetStatus("Fetching index.json...");
    const res = await fetch(GIF_BASE + "index.json", { cache: "no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);

    const list = await res.json();
    if (!Array.isArray(list)) throw new Error("index.json not an array");

    const urls = list
      .filter(name => typeof name === "string" && name.toLowerCase().endsWith(".gif"))
      .map(name => GIF_BASE + name);

    if (!urls.length) throw new Error("No gifs in index.json");

    setAssetStatus(`Preloading ${urls.length} enemy images...`);
    let imgs = await preloadImages(urls);
    imgs = imgs.filter(img => img && img.naturalWidth > 0);
    if (!imgs.length) throw new Error("All enemy images failed to load");

    enemyImages = imgs;
    assetsReady = true;
    setAssetStatus(`Loaded ${enemyImages.length} enemy images ✅`);
  }catch(err){
    console.warn("Failed to load index.json enemy list:", err);
    setAssetStatus("Failed to load index.json. Using fallback images.");
    let imgs = await preloadImages(FALLBACK_URLS);
    enemyImages = imgs.filter(img => img && img.naturalWidth > 0);
    assetsReady = true;
  }
}
loadEnemyImagesFromIndex();

/* =======================
   Enemies + Formation Movement
======================= */
const BASE_SPACING_X = 95;
const BASE_SPACING_Y = 75;

let enemies = [];

// Formation movement state
const formation = {
  xOffset: 0,
  yOffset: 0,
  dir: 1,
  speed: 1.2,
  stepDown: 18,
  boundsPad: 40
};

function resetFormation(){
  formation.xOffset = 0;
  formation.yOffset = 0;
  formation.dir = 1;
  formation.speed = 1.2 + (wave-1) * 0.15;
}

function randEnemyImg(){
  if (!enemyImages.length) return playerImg;
  return enemyImages[Math.floor(Math.random() * enemyImages.length)];
}

function spawnEnemies(){
  enemies = [];
  const baseY = 120;

  for (let r = 0; r < ENEMY_ROWS; r++){
    for (let c = 0; c < ENEMY_COLS; c++){
      enemies.push({
        row: r,
        col: c,
        baseY,
        img: randEnemyImg(),
        size: 56,
        hp: 1,
        x: 0, y: 0, w: 0, h: 0
      });
    }
  }
}

/* =======================
   Bullets
======================= */
const bullets = [];
const enemyBullets = [];

// v1.11: enforced cooldown + slower bullets
function shoot(){
  if (fireCooldown > 0) return;

  bullets.push({
    x: player.x,
    y: player.y - 22,
    vy: PLAYER_BULLET_SPEED,
    r: 4
  });

  fireCooldown = PLAYER_FIRE_COOLDOWN;
}

// Enemy shooting cadence
let enemyShootTimer = 0;
function enemyTryShoot(dt){
  enemyShootTimer -= dt;
  if (enemyShootTimer > 0) return;

  const alive = enemies.length;
  const base = Math.max(0.18, 0.55 - wave*0.04 - Math.min(0.22, alive*0.002));
  enemyShootTimer = base;

  if (!enemies.length) return;

  const e = enemies[Math.floor(Math.random() * enemies.length)];
  enemyBullets.push({
    x: e.x,
    y: e.y + e.h/2 + 6,
    vy: 6 + wave*0.35,
    r: 4
  });
}

/* =======================
   Collision helpers
======================= */
function circleRect(cx, cy, cr, rx, ry, rw, rh){
  const testX = Math.max(rx, Math.min(cx, rx+rw));
  const testY = Math.max(ry, Math.min(cy, ry+rh));
  const dx = cx - testX;
  const dy = cy - testY;
  return (dx*dx + dy*dy) <= cr*cr;
}

function damagePlayer(){
  if (player.invuln > 0) return;
  lives -= 1;
  player.invuln = 0.85;
  playSfx(sfxOof);

  if (lives <= 0){
    showMenu();
  }
}

/* =======================
   Input (Space fixed)
======================= */
window.addEventListener("keydown", (e) => {
  unlockAudioOnce();

  if (e.code === "Space") e.preventDefault();

  const k = e.key.toLowerCase();
  keys[k] = true;

  if (e.code === "Space" && gameState === STATE.PLAYING) shoot();
  if (k === "escape") showMenu();
}, { passive:false });

window.addEventListener("keyup", (e) => {
  keys[e.key.toLowerCase()] = false;
});

// tap/click shoot
canvas.addEventListener("pointerdown", () => {
  unlockAudioOnce();
  if (gameState === STATE.PLAYING) shoot();
});

/* =======================
   Update + Draw
======================= */
function update(dt){
  time += dt;

  if (gameState !== STATE.PLAYING) return;

  // invulnerability timer
  if (player.invuln > 0) player.invuln = Math.max(0, player.invuln - dt);

  // v1.11: firing cooldown tick
  if (fireCooldown > 0) fireCooldown = Math.max(0, fireCooldown - dt);

  // player move
  if (keys["a"] || keys["arrowleft"]) player.x -= player.speed;
  if (keys["d"] || keys["arrowright"]) player.x += player.speed;
  player.x = Math.max(player.w/2, Math.min(canvas.width - player.w/2, player.x));

  // formation movement uses current breathing spacing to compute bounds
  const breath = Math.sin(time * 2) * 0.5 + 0.5;
  const spacingX = BASE_SPACING_X * (1 + breath * 0.35);

  const formationWidth = (ENEMY_COLS - 1) * spacingX;
  const leftEdge  = canvas.width/2 - formationWidth/2 + formation.xOffset;
  const rightEdge = canvas.width/2 + formationWidth/2 + formation.xOffset;

  formation.xOffset += formation.dir * formation.speed;

  if (leftEdge < formation.boundsPad){
    formation.dir = 1;
    formation.xOffset += 2;
    formation.yOffset += formation.stepDown;
  } else if (rightEdge > canvas.width - formation.boundsPad){
    formation.dir = -1;
    formation.xOffset -= 2;
    formation.yOffset += formation.stepDown;
  }

  // update player bullets
  for (let i = bullets.length - 1; i >= 0; i--){
    bullets[i].y += bullets[i].vy;
    if (bullets[i].y < -50) bullets.splice(i, 1);
  }

  // update enemy bullets
  for (let i = enemyBullets.length - 1; i >= 0; i--){
    enemyBullets[i].y += enemyBullets[i].vy;
    if (enemyBullets[i].y > canvas.height + 60) enemyBullets.splice(i, 1);
  }

  // compute enemy positions (same math draw uses)
  const spacingY = BASE_SPACING_Y * (1 + breath * 0.15);
  const startX = canvas.width/2 - formationWidth/2 + formation.xOffset;
  const baseY = 120 + formation.yOffset;

  for (const e of enemies){
    if (assetsReady && enemyImages.length && e.img === playerImg) e.img = randEnemyImg();

    const scale = 1 + breath * 0.25;
    const size = e.size * scale;

    const x = startX + e.col * spacingX;
    const y = baseY + e.row * spacingY;

    e.x = x;
    e.y = y;
    e.w = size;
    e.h = size;
  }

  // bullet -> enemy collision
  for (let bi = bullets.length - 1; bi >= 0; bi--){
    const b = bullets[bi];

    for (let ei = enemies.length - 1; ei >= 0; ei--){
      const e = enemies[ei];
      const rx = e.x - e.w/2, ry = e.y - e.h/2;

      if (circleRect(b.x, b.y, b.r, rx, ry, e.w, e.h)){
        enemies.splice(ei, 1);
        bullets.splice(bi, 1);
        score += 10;
        playSfx(sfxHit);
        break;
      }
    }
  }

  // enemy bullet -> player collision
  const prx = player.x - player.w/2, pry = player.y - player.h/2;
  for (let i = enemyBullets.length - 1; i >= 0; i--){
    const b = enemyBullets[i];
    if (circleRect(b.x, b.y, b.r, prx, pry, player.w, player.h)){
      enemyBullets.splice(i, 1);
      damagePlayer();
    }
  }

  // enemy contact damage
  if (player.invuln <= 0){
    for (const e of enemies){
      const rx = e.x - e.w/2, ry = e.y - e.h/2;
      const overlap =
        prx < rx + e.w &&
        prx + player.w > rx &&
        pry < ry + e.h &&
        pry + player.h > ry;

      if (overlap){
        damagePlayer();
        break;
      }
    }
  }

  // enemy shooting
  enemyTryShoot(dt);

  // wave clear
  if (enemies.length === 0){
    wave += 1;
    resetFormation();
    spawnEnemies();
  }
}

function drawBackgroundStars(){
  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle = "#111";
  for (let i = 0; i < 200; i++){
    ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 1, 1);
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBackgroundStars();

  // player flicker on invulnerability
  const flicker = player.invuln > 0 && Math.floor(time * 20) % 2 === 0;
  if (!flicker){
    ctx.drawImage(playerImg, player.x - player.w/2, player.y - player.h/2, player.w, player.h);
  }

  // enemies
  for (const e of enemies){
    ctx.drawImage(e.img, e.x - e.w/2, e.y - e.h/2, e.w, e.h);
  }

  // bullets (player)
  ctx.fillStyle = "#0f0";
  for (const b of bullets){
    ctx.fillRect(b.x - 2, b.y - 10, 4, 12);
  }

  // bullets (enemy)
  ctx.fillStyle = "#0a6";
  for (const b of enemyBullets){
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.fill();
  }

  overlay.innerHTML =
    `Galaga-ish Clone v1.11<br>` +
    `State: ${gameState}<br>` +
    `Score: ${score} | Lives: ${lives} | Wave: ${wave}<br>` +
    `Enemies: ${enemies.length} (${ENEMY_ROWS}x${ENEMY_COLS})<br>` +
    `Enemy pool: ${enemyImages.length || 0} images<br>` +
    `Bullets: ${bullets.length} | Enemy Bullets: ${enemyBullets.length}<br>` +
    `Fire CD: ${fireCooldown.toFixed(2)}s<br>` +
    `ESC: Menu`;
}

let lastT = performance.now();
function loop(t){
  const dt = Math.min(0.033, (t - lastT) / 1000);
  lastT = t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

showMenu();
</script>
</body>
</html>
