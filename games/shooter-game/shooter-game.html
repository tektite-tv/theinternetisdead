<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bananaman Shooter v0.3.3</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  html, body {margin:0;overflow:hidden;background:#000;color:#fff;font-family:sans-serif;height:100%;}
  canvas {display:block;position:fixed;inset:0;z-index:0;}
  /* HUD Styling */
  .hud {position:fixed;background:rgba(20,20,20,0.7);border:1px solid rgba(255,255,255,0.2);border-radius:8px;
    padding:6px 10px;font-size:14px;z-index:999;}
  #healthbar {position:fixed;bottom:5vh;left:50%;transform:translateX(-50%);
    width:60vw;height:20px;border:2px solid white;border-radius:10px;background:#400;z-index:1000;}
  #healthfill {background:#ff3333;width:100%;height:100%;border-radius:10px;transition:width .2s linear;}
  #healthtext {position:absolute;width:100%;top:0;text-align:center;font-size:12px;}
</style>
</head>
<body>
<canvas id="bg"></canvas>
<canvas id="game"></canvas>

<!-- HUD -->
<div id="hud-stats" class="hud" style="top:10px;left:10px;">Kills: <span id="kills">0</span> | Wave: <span id="wave">0</span></div>
<div id="hud-top" class="hud" style="top:10px;right:10px;display:flex;gap:10px;">
  <div>Damage: <span id="damage">0</span></div>
  <div>Time: <span id="timer">0s</span></div>
</div>
<div id="healthbar"><div id="healthfill"></div><div id="healthtext">100%</div></div>

<!-- MENU -->
<div id="menu" class="fixed inset-0 flex flex-col items-center justify-center text-center bg-black/80 z-[9999]">
  <h1 class="text-4xl text-yellow-300 font-bold mb-4">Bananaman Shooter</h1>
  <button id="start" class="bg-yellow-400 text-black px-6 py-3 rounded-lg m-2 hover:bg-yellow-300">Start</button>
</div>

<script>
/* === v0.3.3 Neon Grid Edition === */

const bg = document.getElementById('bg');
const g = bg.getContext('2d');
const game = document.getElementById('game');
const ctx = game.getContext('2d');
let W=innerWidth,H=innerHeight;
bg.width=game.width=W; bg.height=game.height=H;
addEventListener('resize',()=>{W=innerWidth;H=innerHeight;bg.width=game.width=W;bg.height=game.height=H;});

let gridOffset=0;
function drawGrid(){
  g.clearRect(0,0,W,H);
  g.strokeStyle='rgba(0,255,150,0.5)';
  g.shadowColor='#00ffaa'; g.shadowBlur=8;
  g.lineWidth=1.2;
  const spacing=40; gridOffset+=0.5;
  g.beginPath();
  for(let x=-W;x<W*2;x+=spacing){
    g.moveTo(x+gridOffset%spacing,0);
    g.lineTo(x+gridOffset%spacing,H);
  }
  for(let y=-H;y<H*2;y+=spacing){
    g.moveTo(0,y+gridOffset%spacing);
    g.lineTo(W,y+gridOffset%spacing);
  }
  g.stroke();
}

const player={x:W/2,y:H/2,size:80,hp:100,speed:300};
const bullets=[],enemies=[];
let kills=0,wave=1,damage=0,startTime=null;
const killsEl=document.getElementById('kills'),waveEl=document.getElementById('wave'),
damageEl=document.getElementById('damage'),timerEl=document.getElementById('timer'),
healthFill=document.getElementById('healthfill'),healthText=document.getElementById('healthtext');

function updateHUD(){
  killsEl.textContent=kills;waveEl.textContent=wave;damageEl.textContent=damage;
  timerEl.textContent=((performance.now()-startTime)/1000).toFixed(1)+'s';
}
function updateHealth(){
  const pct=Math.max(0,Math.round(player.hp));
  healthFill.style.width=pct+'%';
  healthText.textContent=pct+'%';
}
function spawnWave(){
  for(let i=0;i<wave*4+4;i++){
    const s=40+Math.random()*60,side=Math.floor(Math.random()*4);
    let x,y;
    if(side===0){x=Math.random()*W;y=-50;}
    else if(side===1){x=W+50;y=Math.random()*H;}
    else if(side===2){x=Math.random()*W;y=H+50;}
    else{x=-50;y=Math.random()*H;}
    enemies.push({x,y,size:s,hp:Math.ceil(s/25)+1,speed:50+Math.random()*80,fade:1});
  }
}
function shoot(x,y){const dx=x-player.x,dy=y-player.y,d=Math.hypot(dx,dy),vx=dx/d*600,vy=dy/d*600;bullets.push({x:player.x,y:player.y,vx,vy});}
function damagePlayer(amt){player.hp-=amt;updateHealth();if(player.hp<=0)die();}
function die(){state='dead';menu.style.display='flex';player.hp=100;}
let state='menu';
function resetGame(){player.hp=100;kills=0;wave=1;damage=0;bullets.length=0;enemies.length=0;updateHealth();updateHUD();spawnWave();startTime=performance.now();state='playing';}

function draw(){
  drawGrid();
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle='yellow';ctx.beginPath();ctx.arc(player.x,player.y,player.size/2,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#f33';
  for(const b of bullets){ctx.beginPath();ctx.arc(b.x,b.y,4,0,Math.PI*2);ctx.fill();}
  for(const e of enemies){ctx.save();ctx.globalAlpha=e.fade;ctx.fillStyle='lime';
    ctx.beginPath();ctx.arc(e.x,e.y,e.size/2,0,Math.PI*2);ctx.fill();ctx.restore();}
}

function loop(){
  if(state!=='playing')return;
  const dt=0.016;
  for(const b of bullets){b.x+=b.vx*dt;b.y+=b.vy*dt;}
  for(const e of enemies){
    const dx=player.x-e.x,dy=player.y-e.y,d=Math.hypot(dx,dy)||1;
    e.x+=dx/d*e.speed*dt;e.y+=dy/d*e.speed*dt;
  }
  // collisions
  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];
    for(let j=bullets.length-1;j>=0;j--){
      const b=bullets[j];
      if(Math.hypot(b.x-e.x,b.y-e.y)<e.size/2+4){
        e.hp--;damage+=10;damageEl.textContent=damage;bullets.splice(j,1);
        if(e.hp<=0){e.fade-=dt*5;if(e.fade<=0){enemies.splice(i,1);kills++;}}
        break;
      }
    }
    if(Math.hypot(e.x-player.x,e.y-player.y)<(player.size+e.size)/2){damagePlayer(5);}
  }
  if(enemies.length===0){wave++;spawnWave();}
  updateHUD();draw();
  requestAnimationFrame(loop);
}
document.addEventListener('click',e=>{if(state==='playing')shoot(e.clientX,e.clientY);});
document.getElementById('start').onclick=()=>{menu.style.display='none';resetGame();loop();};
</script>
</body>
</html>
