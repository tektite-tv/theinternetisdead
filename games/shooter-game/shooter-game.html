<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Galaga-ish Clone v1.12.4</title>
<style>
  html, body { margin:0; padding:0; background:black; overflow:hidden; color:#0f0; font-family:monospace; }
  canvas { display:block; }
  #overlay{
    position:absolute; top:10px; left:10px; font-size:14px; line-height:1.4; pointer-events:none;
    text-shadow:0 0 6px rgba(0,255,0,0.35);
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="overlay"></div>

<script>
/* =========================================================
   Galaga-ish Clone v1.12.4
   Changes:
   - Responsive horizontal enemy spacing for desktop
   - Hard vertical clamping so enemies never leave screen
   - Reduced enemy size + breathing scale to prevent overlap
========================================================= */

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const overlay = document.getElementById("overlay");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

let time = 0;
const BASE_SPACING_Y = 75;

function getSpacingX(){
  const maxFormationWidth = canvas.width * 0.82;
  const cols = Math.max(1, ENEMY_COLS - 1);
  return Math.min(120, Math.max(80, maxFormationWidth / cols));
}

const ENEMY_ROWS = 4;
const ENEMY_COLS = 6;

const formation = {
  xOffset: 0,
  yOffset: 0,
  dir: 1,
  speed: 1.2,
  boundsPad: 40
};

const enemies = [];
function spawnEnemies(){
  enemies.length = 0;
  for(let r=0;r<ENEMY_ROWS;r++){
    for(let c=0;c<ENEMY_COLS;c++){
      enemies.push({row:r,col:c,x:0,y:0,size:52});
    }
  }
}
spawnEnemies();

function update(dt){
  time += dt;
  const breath = Math.sin(time * 2) * 0.5 + 0.5;

  const spacingX = getSpacingX() * (1 + breath * 0.25);
  const spacingY = BASE_SPACING_Y * (1 + breath * 0.15);

  const formationWidth = (ENEMY_COLS - 1) * spacingX;
  const startX = canvas.width/2 - formationWidth/2 + formation.xOffset;

  formation.xOffset += formation.dir * formation.speed;
  if(startX < formation.boundsPad || startX + formationWidth > canvas.width - formation.boundsPad){
    formation.dir *= -1;
  }

  let baseY = 80 + formation.yOffset;
  const TOP_SAFE_MARGIN = 60;
  if(baseY < TOP_SAFE_MARGIN){
    baseY = TOP_SAFE_MARGIN;
  }

  for(const e of enemies){
    const scale = 1 + breath * 0.18;
    const size = e.size * scale;
    e.x = startX + e.col * spacingX;
    e.y = baseY + e.row * spacingY;
    e.w = size;
    e.h = size;
  }
}

function draw(){
  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  for(const e of enemies){
    ctx.fillStyle = "#0f0";
    ctx.fillRect(e.x - e.w/2, e.y - e.h/2, e.w, e.h);
  }

  overlay.innerHTML =
    "v1.12.4<br>" +
    "Enemies always visible<br>" +
    "Responsive desktop spacing";
}

let last = performance.now();
function loop(t){
  const dt = Math.min(0.033,(t-last)/1000);
  last = t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
