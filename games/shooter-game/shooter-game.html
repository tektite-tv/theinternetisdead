<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Galaga-ish Clone v1.03</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow: hidden;
    }
    #wrap {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #000;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 14px;
      text-shadow: 0 0 6px rgba(0,0,0,0.9);
      pointer-events: none;
      line-height: 1.35;
    }
    #centerMsg {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 30px;
      font-weight: 800;
      white-space: pre-line;
      text-shadow: 0 0 14px rgba(0,0,0,0.95);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    #centerMsg.show { opacity: 1; }
    #hint {
      position: absolute;
      left: 10px;
      bottom: 10px;
      font-size: 12px;
      opacity: 0.75;
      text-shadow: 0 0 6px rgba(0,0,0,0.9);
      pointer-events: none;
      line-height: 1.35;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>

    <div id="ui">
      <div><b>Galaga-ish Clone v1.03</b></div>
      <div>Move: A/D or ←/→ | Shoot: Space or LMB | Restart: R</div>
      <div>Score: <span id="score">0</span> | Lives: <span id="lives">3</span> | Wave: <span id="wave">1</span></div>
      <div>Enemies: <span id="enemyCount">0</span></div>
      <div style="opacity:0.8">Player: /media/images/gifs/bananarama.gif</div>
    </div>

    <div id="hint">
      If enemies show as red blocks: that’s the fallback while images load. v1.03 adds enemy “breathing” (pulse size + spacing) and slightly larger enemy visuals.
    </div>

    <div id="centerMsg"></div>
  </div>

  <script>
    // ================================================================
    // Galaga-ish Clone v1.03 (FULL FILE)
    //
    // FIX:
    // - v1.03: enemies “breathe” (pulse size + spacing) + slightly larger formation.
    // - Wait for index.json to load before spawning first wave.
    // - Pre-warm a handful of images so wave 1 doesn't start as red squares.
    // ================================================================

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const scoreEl = document.getElementById("score");
    const livesEl = document.getElementById("lives");
    const waveEl = document.getElementById("wave");
    const enemyCountEl = document.getElementById("enemyCount");
    const centerMsg = document.getElementById("centerMsg");

    function resize() {
      const r = canvas.getBoundingClientRect();
      canvas.width = Math.floor(r.width);
      canvas.height = Math.floor(r.height);
    }
    window.addEventListener("resize", resize);
    resize();

    // -------------------------
    // Paths
    // -------------------------
    const ENEMY_GIF_INDEX_URL = "/media/images/gifs/index.json";
    const ENEMY_GIF_BASE_URL  = "/media/images/gifs/";
    const PLAYER_SPRITE_URL   = "/media/images/gifs/bananarama.gif";

    // -------------------------
    // Image cache
    // -------------------------
    const imageCache = new Map();

    function getOrCreateImage(src) {
      if (imageCache.has(src)) return imageCache.get(src);
      const img = new Image();
      img.src = src;
      imageCache.set(src, img);
      return img;
    }

    const playerImg = getOrCreateImage(PLAYER_SPRITE_URL);

    // -------------------------
    // Index.json loading
    // -------------------------
    let enemyGifFilenames = [];
    let enemyIndexLoaded = false;

    async function loadEnemyGifIndex() {
      try {
        const res = await fetch(ENEMY_GIF_INDEX_URL, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();

        if (!Array.isArray(json)) {
          console.warn("[Galaga] index.json is not an array. Expected: [\"a.gif\", ...]");
          enemyGifFilenames = [];
        } else {
          enemyGifFilenames = json
            .filter(v => typeof v === "string")
            .map(s => s.trim())
            .filter(Boolean)
            .filter(s => !s.includes(".."))
            .filter(s => /\.(gif|png|jpg|jpeg|webp)$/i.test(s));
        }

        console.log("[Galaga] Loaded enemy list:", enemyGifFilenames.length);
      } catch (err) {
        console.warn("[Galaga] Failed to load enemy index.json:", err);
        enemyGifFilenames = [];
      } finally {
        enemyIndexLoaded = true;
      }
    }

    // Pre-warm a few images so wave 1 isn't all fallback blocks
    async function prewarmEnemyImages(maxCount = 10) {
      if (!enemyGifFilenames.length) return;

      const pick = enemyGifFilenames.slice(0, maxCount);
      const promises = pick.map(fn => new Promise((resolve) => {
        const img = getOrCreateImage(ENEMY_GIF_BASE_URL + fn);
        if (img.complete && img.naturalWidth > 0) return resolve();
        img.onload = () => resolve();
        img.onerror = () => resolve();
      }));

      // Don’t block forever. Just give it a head start.
      await Promise.race([
        Promise.all(promises),
        new Promise(resolve => setTimeout(resolve, 350))
      ]);
    }

    function pickRandomEnemySrc(rand) {
      if (!enemyGifFilenames.length) return null;
      const fn = enemyGifFilenames[Math.floor(rand() * enemyGifFilenames.length)];
      return ENEMY_GIF_BASE_URL + fn;
    }

    // -------------------------
    // Deterministic RNG + hash
    // -------------------------
    function hashStringFNV1a(str) {
      let h = 0x811c9dc5;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 0x01000193);
      }
      return h >>> 0;
    }

    function makeRng(seed) {
      let s = seed >>> 0;
      return function rand() {
        s ^= s << 13; s >>>= 0;
        s ^= s >>> 17; s >>>= 0;
        s ^= s << 5;  s >>>= 0;
        return (s >>> 0) / 4294967296;
      };
    }

    // -------------------------
    // Audio
    // -------------------------
    const SFX = {
      enemyHit: "/media/audio/hitmarker.mp3",
      playerHit: "/media/audio/oof.mp3"
    };

    const sfxThrottle = {
      enemyHit: { last: 0, minGap: 0.04 },
      playerHit: { last: 0, minGap: 0.18 }
    };

    function playSfx(key, volume = 0.8) {
      const now = performance.now() / 1000;
      const t = sfxThrottle[key];
      if (t && now - t.last < t.minGap) return;
      if (t) t.last = now;

      const a = new Audio(SFX[key]);
      a.volume = volume;
      a.play().catch(() => {});
    }

    // -------------------------
    // Input
    // -------------------------
    const keys = { left: false, right: false, shoot: false };
    let mouseDown = false;

    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "a" || k === "arrowleft") keys.left = true;
      if (k === "d" || k === "arrowright") keys.right = true;
      if (k === " ") keys.shoot = true;
      if (k === "r") resetGame();
    });

    window.addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (k === "a" || k === "arrowleft") keys.left = false;
      if (k === "d" || k === "arrowright") keys.right = false;
      if (k === " ") keys.shoot = false;
    });

    canvas.addEventListener("mousedown", (e) => { if (e.button === 0) mouseDown = true; });
    window.addEventListener("mouseup", (e) => { if (e.button === 0) mouseDown = false; });

    // -------------------------
    // Helpers
    // -------------------------
    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
    function aabbOverlap\(a, b\) \{
      return a\.x < b\.x \+ b\.w &&
             a\.x \+ a\.w > b\.x &&
             a\.y < b\.y \+ b\.h &&
             a\.y \+ a\.h > b\.y;
    \}
function enemyRenderRect(e, t) {
      // Per-enemy phase so the whole group feels "alive" instead of perfectly synchronized.
      const breathe = Math.sin(t * formation.breatheSpeed + (e.breathePhase || 0));
      const scale = 1 + formation.breatheScaleAmp * breathe;

      // Scale is drawn around the enemy's center so it doesn't "crawl" off its slot.
      const bw = e.baseW ?? e.w;
      const bh = e.baseH ?? e.h;

      // Base position is e.x/e.y (top-left) for the *base* box.
      const cx = e.x + bw / 2;
      const cy = e.y + bh / 2;

      const rw = bw * scale;
      const rh = bh * scale;

      return {
        breathe,
        scale,
        x: cx - rw / 2,
        y: cy - rh / 2,
        w: rw,
        h: rh
      };
    }

    // -------------------------
    // Game state
    // -------------------------
    let score = 0;
    let lives = 3;
    let wave = 1;

    const player = {
      x: 0,
      y: 0,
      w: 56,
      h: 56,
      speed: 520,
      iFrames: 0
    };

    const bullets = [];
    const enemyBullets = [];
    const enemies = [];

    const formation = {
      x: 0,
      y: 90,
      dir: 1,
      speed: 55,
      stepDown: 26,
      boundsPad: 70,
      sway: 0,
      swaySpeed: 0.85,

      // "Breathing" formation: enemies pulse in size AND subtly push away/toward each other.
      // (Yes, your space bugs are now doing cardio.)
      cols: 0,
      rows: 0,
      cellW: 70,
      cellH: 58,
      breathe: 0,
      breatheSpeed: 2.2,         // radians/sec multiplier (higher = faster pulse)
      breatheScaleAmp: 0.12,     // +/- scale amount (0.12 = 12% bigger/smaller)
      breatheSpacingAmp: 7       // pixels of spacing in/out (subtle but noticeable)
    };

    let lastShot = 0;
    const SHOT_COOLDOWN = 0.12;

    let lastDive = 0;
    let lastEnemyShot = 0;

    let isGameOver = false;
    let showWaveBannerUntil = 0;

    function layoutPlayer() {
      player.x = (canvas.width - player.w) / 2;
      player.y = canvas.height - 96;
    }

    function showCenter(text, ms = 900) {
      centerMsg.textContent = text;
      centerMsg.classList.add("show");
      showWaveBannerUntil = performance.now() + ms;
    }

    function syncUI() {
      scoreEl.textContent = String(score);
      livesEl.textContent = String(lives);
      waveEl.textContent = String(wave);
      enemyCountEl.textContent = String(enemies.length);
    }

    function enemyTypeFromSrc(src) {
      const name = src ? src.split("/").pop() : "fallback";
      const h = hashStringFNV1a("ETYPE:" + name);
      return h % 4; // 0 grunt, 1 diver, 2 shooter, 3 tank
    }

    function spawnWave(w) {
      enemies.length = 0;
      bullets.length = 0;
      enemyBullets.length = 0;

      formation.y = clamp(90 + (w - 1) * 6, 90, 150);
      formation.dir = 1;
      formation.speed = 55 + (w - 1) * 6;
      formation.stepDown = clamp(26 + (w - 1) * 1.2, 26, 40);
      formation.sway = 0;

      const rows = clamp(3 + Math.floor((w - 1) / 2), 3, 6);
      const cols = clamp(8 + Math.floor((w - 1) / 2), 8, 12);

      // Make enemies and their formation slots a bit larger,
      // but also adapt spacing so it doesn't explode off-screen on small viewports.
      const cellW = clamp(Math.floor(canvas.width / (cols + 2)), 64, 92);
      const cellH = clamp(Math.floor(canvas.height / (rows + 9)), 60, 86);

      formation.cols = cols;
      formation.rows = rows;
      formation.cellW = cellW;
      formation.cellH = cellH;

      const totalW = cols * cellW;
      formation.x = (canvas.width - totalW) / 2;

      const rand = makeRng(hashStringFNV1a("WAVE:" + w));

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const src = pickRandomEnemySrc(rand); // now actually populated before first spawn
          const img = src ? getOrCreateImage(src) : null;

          const etype = enemyTypeFromSrc(src);

          // Slightly larger baseline enemy size (with a little per-enemy variance).
          const baseSize = 56;
          const size = clamp(baseSize + (rand() * 20 - 10), 40, 74);

          let hp = 1;
          if (etype === 3) hp = 3 + Math.floor(w * 0.2);
          else if (etype === 0) hp = 1;
          else hp = 1 + (w > 6 ? 1 : 0);

          const diveChance = (etype === 1) ? 0.75 : (etype === 0 ? 0.20 : 0.40);
          const shootBias  = (etype === 2) ? 0.85 : 0.35;

          enemies.push({
            // Base formation slot position (relative to formation.x / formation.y)
            baseFx: c * cellW + (cellW - size) / 2,
            baseFy: r * cellH,

            // Current formation offsets (we'll compute fx/fy each frame so "breathing" can affect spacing)
            fx: 0,
            fy: 0,

            // Base hitbox size (breathing scales are applied at render/collision time, centered)
            baseW: size,
            baseH: size,

            // Current base box top-left position in world space (used as anchor for scaling)
            x: 0,
            y: 0,
            w: size,
            h: size,

            // Grid coords so spacing can push outward/inward
            gridC: c,
            gridR: r,

            // Per-enemy breathe phase (deterministic per sprite, so it feels consistent)
            breathePhase: (hashStringFNV1a("BREATHE:" + (src || ("r" + r + "c" + c))) % 1000) / 1000 * Math.PI * 2,

            img, src,
            type: etype,
            hp, maxHp: hp,

            state: "formation",
            vx: 0, vy: 0,
            diveChance,
            shootBias,
            flash: 0
          });
        }
      }

      showCenter(`WAVE ${w}`, 900);
      syncUI();
    }

    function resetGame() {
      score = 0;
      lives = 3;
      wave = 1;
      isGameOver = false;
      centerMsg.classList.remove("show");
      centerMsg.textContent = "";
      bullets.length = 0;
      enemyBullets.length = 0;
      enemies.length = 0;

      // If index still isn’t loaded somehow, don’t pretend it is
      if (!enemyIndexLoaded) {
        centerMsg.textContent = "Loading enemy sprites...";
        centerMsg.classList.add("show");
        return;
      }

      spawnWave(wave);
      layoutPlayer();
      syncUI();
    }

    // -------------------------
    // Shooting
    // -------------------------
    function shoot() {
      const now = performance.now() / 1000;
      if (now - lastShot < SHOT_COOLDOWN) return;
      lastShot = now;

      bullets.push({
        x: player.x + player.w / 2 - 3,
        y: player.y - 10,
        w: 6,
        h: 14,
        vy: -920,
        damage: 1
      });
    }

    function enemyShootFrom(e) {
      const t = performance.now() / 1000;
      const rr = enemyRenderRect(e, t);

      enemyBullets.push({
        x: rr.x + rr.w / 2 - 3,
        y: rr.y + rr.h - 2,
        w: 6,
        h: 14,
        vy: 520 + wave * 10,
        damage: 1
      });
    }

    // -------------------------
    // Update
    // -------------------------
    function takeHit() {
      lives--;
      player.iFrames = 1.0;
      playSfx("playerHit", 0.85);

      enemyBullets.length = 0;
      bullets.length = 0;

      if (lives <= 0) gameOver();
    }

    function gameOver() {
      isGameOver = true;
      centerMsg.textContent = "GAME OVER\nPress R to restart";
      centerMsg.classList.add("show");
    }

    function update(dt) {
      if (!enemyIndexLoaded) return; // hard gate: don’t run before sprites list loads
      if (isGameOver) return;

      if (performance.now() > showWaveBannerUntil) centerMsg.classList.remove("show");

      player.iFrames = Math.max(0, player.iFrames - dt);

      // Player move
      let dir = 0;
      if (keys.left) dir -= 1;
      if (keys.right) dir += 1;
      player.x += dir * player.speed * dt;
      player.x = clamp(player.x, 10, canvas.width - player.w - 10);

      // Shoot
      if (keys.shoot || mouseDown) shoot();

      // Formation movement
      formation.sway += dt * formation.swaySpeed;
      const swayOffset = Math.sin(formation.sway) * 10;

      formation.x += formation.dir * formation.speed * dt;

      let minX = Infinity, maxX = -Infinity;
      const t = performance.now() / 1000;

      for (const e of enemies) {
        if (e.state === "formation") {
          // Compute current slot position with breathing spacing.
          const breathe = Math.sin(t * formation.breatheSpeed + (e.breathePhase || 0));
          const spacing = formation.breatheSpacingAmp * breathe;

          const cx = (formation.cols - 1) / 2;
          const cy = (formation.rows - 1) / 2;
          let dx = (e.gridC ?? 0) - cx;
          let dy = (e.gridR ?? 0) - cy;
          const mag = Math.hypot(dx, dy) || 1;
          dx /= mag; dy /= mag;

          const fx = (e.baseFx ?? e.fx) + dx * spacing;
          const x = formation.x + fx + swayOffset;

          // Anchor a temporary base position to get a render rect.
          const bw = e.baseW ?? e.w;
          const bh = e.baseH ?? e.h;
          const baseY = formation.y + (e.baseFy ?? e.fy);

          const tmp = { ...e, x, y: baseY, w: bw, h: bh, baseW: bw, baseH: bh };
          const rr = enemyRenderRect(tmp, t);

          minX = Math.min(minX, rr.x);
          maxX = Math.max(maxX, rr.x + rr.w);
        }
      }

      if (minX === Infinity) { minX = formation.x; maxX = formation.x + 400; }

      if (minX < formation.boundsPad) {
        formation.x += (formation.boundsPad - minX);
        formation.dir = 1;
        formation.y += formation.stepDown;
      } else if (maxX > canvas.width - formation.boundsPad) {
        formation.x -= (maxX - (canvas.width - formation.boundsPad));
        formation.dir = -1;
        formation.y += formation.stepDown;
      }

      // Dive selection
      const now = performance.now() / 1000;
      const alive = enemies.length;
      const diveInterval = clamp(1.7 - wave * 0.06, 0.55, 1.7);

      if (now - lastDive > diveInterval && alive > 0) {
        lastDive = now;
        const candidates = enemies.filter(e => e.state === "formation");
        if (candidates.length) {
          const pick = candidates[Math.floor(Math.random() * candidates.length)];
          if (Math.random() < pick.diveChance) {
            pick.state = "diving";
            // Aim dive based on current slot (using baseFx so wave start doesn't mis-aim).
            const bw = pick.baseW ?? pick.w;
            const breathe = Math.sin(t * formation.breatheSpeed + (pick.breathePhase || 0));
            const spacing = formation.breatheSpacingAmp * breathe;

            const cx = (formation.cols - 1) / 2;
            const cy = (formation.rows - 1) / 2;
            let ddx = (pick.gridC ?? 0) - cx;
            let ddy = (pick.gridR ?? 0) - cy;
            const mag = Math.hypot(ddx, ddy) || 1;
            ddx /= mag; ddy /= mag;

            const slotX = formation.x + (pick.baseFx ?? 0) + ddx * spacing + swayOffset;
            const dx = (player.x + player.w/2) - (slotX + bw/2);
            pick.vx = clamp(dx * 0.9, -420, 420);
            pick.vy = 260 + wave * 10;
          }
        }
      }

      // Enemy shooting cadence
      const enemyShotInterval = clamp(1.2 - wave * 0.05, 0.35, 1.2);
      if (now - lastEnemyShot > enemyShotInterval && enemies.length) {
        lastEnemyShot = now;

        const shooters = enemies
          .filter(e => e.state !== "returning")
          .sort((a, b) => {
            const ar = enemyRenderRect(a, t);
            const br = enemyRenderRect(b, t);
            const ax = Math.abs((ar.x + ar.w/2) - (player.x + player.w/2));
            const bx = Math.abs((br.x + br.w/2) - (player.x + player.w/2));
            return (ax - bx) + (b.shootBias - a.shootBias) * 80;
          });

        if (shooters.length) {
          const e = shooters[Math.floor(Math.random() * Math.min(6, shooters.length))];
          if (Math.random() < (e.shootBias || 0.35)) enemyShootFrom(e);
        }
      }

      // Update enemies
      for (const e of enemies) {
        e.flash = Math.max(0, e.flash - dt);

        if (e.state === "formation") {
          // Breathing spacing only affects enemies in formation (not divers mid-attack).
          const breathe = Math.sin(t * formation.breatheSpeed + (e.breathePhase || 0));
          const spacing = formation.breatheSpacingAmp * breathe;

          const cx = (formation.cols - 1) / 2;
          const cy = (formation.rows - 1) / 2;
          let dx = (e.gridC ?? 0) - cx;
          let dy = (e.gridR ?? 0) - cy;
          const mag = Math.hypot(dx, dy) || 1;
          dx /= mag; dy /= mag;

          e.fx = (e.baseFx ?? e.fx) + dx * spacing;
          e.fy = (e.baseFy ?? e.fy) + dy * spacing * 0.55;

          e.x = formation.x + e.fx + swayOffset;
          e.y = formation.y + e.fy;
        } else if (e.state === "diving") {
          e.vx *= Math.pow(0.15, dt);
          e.x += e.vx * dt;
          e.y += e.vy * dt;
          if (e.y > canvas.height + 40) {
            e.state = "returning";
            e.vx = 0;
            e.vy = -420 - wave * 8;
          }
        } else if (e.state === "returning") {
          e.y += e.vy * dt;
          const tx = formation.x + (e.baseFx ?? e.fx) + swayOffset;
          const ty = formation.y + (e.baseFy ?? e.fy);
          e.x = e.x + (tx - e.x) * clamp(dt * 3.5, 0, 1);
          if (e.y <= ty) e.state = "formation";
        }
      }

      // Bullets update
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.y += b.vy * dt;
        if (b.y + b.h < -50) bullets.splice(i, 1);
      }
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const b = enemyBullets[i];
        b.y += b.vy * dt;
        if (b.y > canvas.height + 60) enemyBullets.splice(i, 1);
      }

      // Player bullets vs enemies
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const rr = enemyRenderRect(e, t);
        const eb = { x: rr.x, y: rr.y, w: rr.w, h: rr.h };

        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          if (aabbOverlap(eb, b)) {
            bullets.splice(j, 1);
            e.hp -= 1;
            e.flash = 0.10;
            playSfx("enemyHit", 0.65);

            if (e.hp <= 0) {
              const bonus = (e.type === 3) ? 40 : (e.type === 2 ? 30 : (e.type === 1 ? 25 : 20));
              score += bonus + Math.floor(wave * 2);
              enemies.splice(i, 1);
            }
            break;
          }
        }
      }

      // Enemy bullets vs player
      if (player.iFrames <= 0) {
        const pb = { x: player.x, y: player.y, w: player.w, h: player.h };
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
          if (aabbOverlap(pb, enemyBullets[i])) {
            enemyBullets.splice(i, 1);
            takeHit();
            break;
          }
        }
      }

      // Enemy body vs player
      if (player.iFrames <= 0) {
        const pb = { x: player.x, y: player.y, w: player.w, h: player.h };
        for (const e of enemies) {
          const rr = enemyRenderRect(e, t);
          const eb = { x: rr.x, y: rr.y, w: rr.w, h: rr.h };
          if (aabbOverlap(pb, eb)) { takeHit(); break; }
        }
      }

      // Lose if formation marches too low
      if (formation.y > canvas.height - 220) {
        lives = 0;
        gameOver();
      }

      // Next wave
      if (enemies.length === 0) {
        wave++;
        spawnWave(wave);
      }

      syncUI();
    }

    // -------------------------
    // Draw
    // -------------------------
    function drawStarfield(t) {
      ctx.save();
      ctx.globalAlpha = 0.9;
      const n = 120;
      for (let i = 0; i < n; i++) {
        const x = (i * 997) % canvas.width;
        const y = ((i * 571) + Math.floor(t * 50)) % canvas.height;
        const a = 0.25 + ((i * 37) % 100) / 160;
        ctx.fillStyle = `rgba(180, 210, 255, ${a})`;
        ctx.fillRect(x, y, 2, 2);
      }
      ctx.restore();
    }

    function drawSpriteOrFallback(img, x, y, w, h, fallbackStyle) {
      if (img && img.complete && img.naturalWidth > 0) {
        ctx.drawImage(img, x, y, w, h);
      } else {
        ctx.fillStyle = fallbackStyle || "rgba(255,80,80,0.85)";
        ctx.fillRect(x, y, w, h);
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const t = performance.now() / 1000;

      drawStarfield(t);

      if (!enemyIndexLoaded) {
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.font = "22px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "center";
        ctx.fillText("Loading enemy sprites...", canvas.width/2, canvas.height/2);
        ctx.restore();
        return;
      }

      // Player bullets
      ctx.fillStyle = "#ffdd55";
      for (const b of bullets) ctx.fillRect(b.x, b.y, b.w, b.h);

      // Enemy bullets
      ctx.fillStyle = "rgba(255, 110, 110, 0.95)";
      for (const b of enemyBullets) ctx.fillRect(b.x, b.y, b.w, b.h);

      // Enemies
      for (const e of enemies) {
        const rr = enemyRenderRect(e, t);

        ctx.save();
        if (e.flash > 0) ctx.globalAlpha = 0.65;
        drawSpriteOrFallback(e.img, rr.x, rr.y, rr.w, rr.h, "rgba(255,80,80,0.85)");
        ctx.restore();

        if (e.maxHp > 1) {
          const pct = clamp(e.hp / e.maxHp, 0, 1);
          ctx.save();
          ctx.fillStyle = "rgba(0,0,0,0.55)";
          ctx.fillRect(rr.x, rr.y - 9, rr.w, 5);
          ctx.fillStyle = "rgba(90,255,120,0.9)";
          ctx.fillRect(rr.x, rr.y - 9, rr.w * pct, 5);
          ctx.restore();
        }
      }

      // Player (bananarama.gif)
      ctx.save();
      if (player.iFrames > 0) {
        const blink = Math.floor((performance.now() / 100) % 2) === 0;
        ctx.globalAlpha = blink ? 0.35 : 0.90;
      }
      drawSpriteOrFallback(playerImg, player.x, player.y, player.w, player.h, "#55aaff");

      // muzzle marker
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillRect(player.x + player.w/2 - 3, player.y - 6, 6, 6);
      ctx.restore();
    }

    // -------------------------
    // Main loop + boot
    // -------------------------
    let started = false;

    async function boot() {
      centerMsg.textContent = "Loading enemy sprites...";
      centerMsg.classList.add("show");

      layoutPlayer();
      syncUI();

      await loadEnemyGifIndex();
      await prewarmEnemyImages(10);

      // Start game even if list is empty, but now it’s a real choice, not a race condition
      spawnWave(wave);
      started = true;

      centerMsg.classList.remove("show");

      console.log("[Galaga] Enemy index URL:", ENEMY_GIF_INDEX_URL);
      console.log("[Galaga] Enemy list count:", enemyGifFilenames.length);
      console.log("[Galaga] Player sprite:", PLAYER_SPRITE_URL);
    }

    boot();

    let last = performance.now();
    function loop(now) {
      const dt = clamp((now - last) / 1000, 0, 0.05);
      last = now;

      // Resize mid-game, keep relative player x
      const rect = canvas.getBoundingClientRect();
      const wantW = Math.floor(rect.width);
      const wantH = Math.floor(rect.height);
      if (canvas.width !== wantW || canvas.height !== wantH) {
        const oldW = canvas.width || 1;
        resize();
        const ratio = player.x / oldW;
        player.x = clamp(ratio * canvas.width, 10, canvas.width - player.w - 10);
        player.y = canvas.height - 96;
      }

      if (started) update(dt);
      draw();

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
