<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shooter Game v0.07</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000000;
      color: #ffffff;
      font-family: system-ui;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    #game {
      width: 100%;
      height: 100%;
      display: block;
      background: #000000;
      border: 2px solid #444;
    }

    #ui {
      position: absolute;
      left: 10px;
      top: 10px;
      text-shadow: 0 0 4px black;
      pointer-events: none;
      z-index: 10;
      font-size: 14px;
    }

    #gameOverMessage {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: bold;
      color: #ff5555;
      text-shadow: 0 0 10px black;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      z-index: 20;
    }
  </style>
</head>

<body>
  <div id="gameContainer">
    <canvas id="game"></canvas>

    <div id="ui">
      <div>shooter-game v0.07</div>
      <div>WASD = move | Mouse = aim | LMB = shoot | R = restart</div>
      <div>HP: <span id="hpDisplay">100</span></div>
      <div>Score: <span id="scoreDisplay">0</span></div>
      <div style="opacity:0.85">Floor: hidden grid revealed by walking</div>
    </div>

    <div id="gameOverMessage">GAME OVER</div>
  </div>

  <script>
    // ================================================================
    // Shooter Game v0.07 (FULL FILE)
    //
    // New in v0.07:
    //  - Floor is now a hidden grid revealed by the player's movement.
    //    (Grid is drawn only where you've walked, persistently.)
    //
    // Kept:
    //  - Random enemy GIFs from /media/images/gifs/index.json
    //  - Random enemy size + HP + health bar
    //  - SFX hitmarker/oof
    //  - "Fun" collision rewrite (swept bullets, overlap resolution, repulsion)
    //  - No visible enemy circle outlines
    // ================================================================

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const hpDisplay = document.getElementById("hpDisplay");
    const scoreDisplay = document.getElementById("scoreDisplay");
    const gameOverMessage = document.getElementById("gameOverMessage");

    const VIRTUAL_WIDTH = 1200;
    const VIRTUAL_HEIGHT = 800;

    const WIDTH = VIRTUAL_WIDTH;
    const HEIGHT = VIRTUAL_HEIGHT;

    const camera = { x: WIDTH / 2, y: HEIGHT / 2 };

    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
    function lerp(a, b, t) { return a + (b - a) * t; }

    // Resize real canvas to match its CSS box
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      rebuildOffscreenCanvases();
    }
    window.addEventListener("resize", resizeCanvas);

    // World -> screen mapping
    function sx(worldX) {
      const viewportX = (worldX - camera.x) + VIRTUAL_WIDTH / 2;
      return (viewportX / VIRTUAL_WIDTH) * canvas.width;
    }
    function sy(worldY) {
      const viewportY = (worldY - camera.y) + VIRTUAL_HEIGHT / 2;
      return (viewportY / VIRTUAL_HEIGHT) * canvas.height;
    }

    // =================================================================
    // GAME STATE
    // =================================================================
    const player = {
      x: WIDTH / 2,
      y: HEIGHT / 2,
      radius: 12,
      speed: 260,
      angle: 0,
      hp: 100,
      maxHp: 100,

      iFrames: 0,
      bumpVelX: 0,
      bumpVelY: 0
    };

    const bullets = [];
    const enemies = [];
    const keys = { w: false, a: false, s: false, d: false };
    const mouse = { x: WIDTH / 2, y: HEIGHT / 2, isDown: false };

    let score = 0;
    let isGameOver = false;

    let lastShotTime = 0;
    const SHOT_COOLDOWN = 0.14;

    let enemySpawnTimer = 0;
    const ENEMY_SPAWN_INTERVAL = 1.55;

    // =================================================================
    // TRAIL POINTS (now used to REVEAL grid, not paint a glow blob)
    // =================================================================
    const trailPoints = [];

    const TRAIL_STEP_DIST = 22;      // slightly tighter = smoother reveal
    const REVEAL_RADIUS = 180;       // world units
    const REVEAL_HARD_CORE = 0.22;   // how "solid" the middle looks
    const MAX_TRAIL_POINTS = 4500;   // keep it from eating your RAM like a snack

    let lastTrailX = player.x;
    let lastTrailY = player.y;
    trailPoints.push({ x: player.x, y: player.y });

    // =================================================================
    // OFFSCREEN CANVASES FOR GRID + MASK (v0.07 core feature)
    // =================================================================
    let gridCanvas, gridCtx, maskCanvas, maskCtx;

    function rebuildOffscreenCanvases() {
      gridCanvas = document.createElement("canvas");
      maskCanvas = document.createElement("canvas");

      gridCanvas.width = canvas.width;
      gridCanvas.height = canvas.height;
      maskCanvas.width = canvas.width;
      maskCanvas.height = canvas.height;

      gridCtx = gridCanvas.getContext("2d");
      maskCtx = maskCanvas.getContext("2d");
    }

    // Initial setup
    resizeCanvas();

    // =================================================================
    // ENEMY GIF LIST + IMAGE CACHE
    // =================================================================
    const ENEMY_GIF_INDEX_URL = "/media/images/gifs/index.json";
    const ENEMY_GIF_BASE_URL = "/media/images/gifs/";
    let enemyGifFilenames = [];
    const imageCache = new Map();

    function normalizeIndexJsonToFilenames(json) {
      if (Array.isArray(json)) return json.filter(v => typeof v === "string");

      if (json && typeof json === "object") {
        for (const key of ["files", "gifs", "images", "items"]) {
          if (Array.isArray(json[key])) {
            const out = [];
            for (const it of json[key]) {
              if (typeof it === "string") out.push(it);
              else if (it && typeof it === "object") {
                if (typeof it.name === "string") out.push(it.name);
                else if (typeof it.filename === "string") out.push(it.filename);
                else if (typeof it.file === "string") out.push(it.file);
              }
            }
            if (out.length) return out;
          }
        }
        const keys = Object.keys(json);
        const looksLikeFiles = keys.filter(k => /\.(gif|png|jpg|jpeg|webp)$/i.test(k));
        if (looksLikeFiles.length) return looksLikeFiles;
      }
      return [];
    }

    async function loadEnemyGifIndex() {
      try {
        const res = await fetch(ENEMY_GIF_INDEX_URL, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();
        enemyGifFilenames = normalizeIndexJsonToFilenames(json)
          .map(s => String(s).trim())
          .filter(Boolean)
          .filter(n => !n.endsWith("/") && !n.includes(".."));

        console.log("[v0.07] Loaded enemy image list:", enemyGifFilenames.length);
      } catch (err) {
        console.warn("[v0.07] Failed to load enemy index.json:", err);
        enemyGifFilenames = [];
      }
    }

    function getOrCreateImage(src) {
      if (imageCache.has(src)) return imageCache.get(src);
      const img = new Image();
      img.src = src;
      imageCache.set(src, img);
      return img;
    }

    function getRandomEnemyImageSrc() {
      if (!enemyGifFilenames.length) return null;
      const filename = enemyGifFilenames[Math.floor(Math.random() * enemyGifFilenames.length)];
      return ENEMY_GIF_BASE_URL + filename;
    }

    loadEnemyGifIndex();

    // =================================================================
    // AUDIO
    // =================================================================
    const SFX = {
      enemyHit: "/media/audio/hitmarker.mp3",
      playerHit: "/media/audio/oof.mp3"
    };

    const sfxThrottle = {
      enemyHit: { last: 0, minGap: 0.045 },
      playerHit: { last: 0, minGap: 0.18 }
    };

    function playSfx(key, volume = 0.8) {
      const now = performance.now() / 1000;
      const t = sfxThrottle[key];
      if (t && now - t.last < t.minGap) return;
      if (t) t.last = now;

      const a = new Audio(SFX[key]);
      a.volume = volume;
      a.play().catch(() => {});
    }

    // =================================================================
    // INPUT
    // =================================================================
    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = true;
      if (k === "a") keys.a = true;
      if (k === "s") keys.s = true;
      if (k === "d") keys.d = true;
      if (k === "r" && isGameOver) location.reload();
    });

    window.addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = false;
      if (k === "a") keys.a = false;
      if (k === "s") keys.s = false;
      if (k === "d") keys.d = false;
    });

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      const nx = (e.clientX - rect.left) / canvas.width;
      const ny = (e.clientY - rect.top) / canvas.height;
      mouse.x = camera.x + (nx - 0.5) * VIRTUAL_WIDTH;
      mouse.y = camera.y + (ny - 0.5) * VIRTUAL_HEIGHT;
    });

    canvas.addEventListener("mousedown", (e) => { if (e.button === 0) mouse.isDown = true; });
    canvas.addEventListener("mouseup", (e) => { if (e.button === 0) mouse.isDown = false; });

    // =================================================================
    // FUN COLLISION HELPERS
    // =================================================================
    function closestPointOnSegment(ax, ay, bx, by, px, py) {
      const abx = bx - ax, aby = by - ay;
      const apx = px - ax, apy = py - ay;
      const abLen2 = abx * abx + aby * aby;
      if (abLen2 <= 1e-9) return { x: ax, y: ay, t: 0 };
      let t = (apx * abx + apy * aby) / abLen2;
      t = clamp(t, 0, 1);
      return { x: ax + abx * t, y: ay + aby * t, t };
    }

    function segmentHitsCircle(ax, ay, bx, by, cx, cy, r) {
      const c = closestPointOnSegment(ax, ay, bx, by, cx, cy);
      const dx = cx - c.x, dy = cy - c.y;
      return (dx * dx + dy * dy) <= (r * r);
    }

    function resolveOverlap(a, b, strength = 1.0) {
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.hypot(dx, dy) || 1;
      const minDist = a.radius + b.radius;
      const overlap = minDist - dist;

      if (overlap > 0) {
        const nx = dx / dist;
        const ny = dy / dist;

        const massA = a.radius * a.radius;
        const massB = b.radius * b.radius;
        const total = massA + massB;

        const pushA = (massB / total) * overlap * strength;
        const pushB = (massA / total) * overlap * strength;

        a.x -= nx * pushA;
        a.y -= ny * pushA;
        b.x += nx * pushB;
        b.y += ny * pushB;
      }
    }

    // =================================================================
    // GAME MECHANICS
    // =================================================================
    function shootBullet() {
      const dx = mouse.x - player.x;
      const dy = mouse.y - player.y;
      const len = Math.hypot(dx, dy) || 1;
      const dirX = dx / len;
      const dirY = dy / len;

      const bulletSpeed = 720;

      bullets.push({
        x: player.x,
        y: player.y,
        prevX: player.x,
        prevY: player.y,
        radius: 3.8,
        vx: dirX * bulletSpeed,
        vy: dirY * bulletSpeed,
        life: 1.45,
        damage: (Math.random() < 0.12) ? 2 : 1
      });
    }

    function spawnEnemy() {
      const angle = Math.random() * Math.PI * 2;
      const minDist = 520;
      const maxDist = 920;
      const dist = minDist + Math.random() * (maxDist - minDist);

      const x = player.x + Math.cos(angle) * dist;
      const y = player.y + Math.sin(angle) * dist;

      const sizeFactor = 0.65 + Math.random() * 1.55;
      const baseRadius = 18;
      const radius = clamp(baseRadius * sizeFactor, 12, 44);

      const maxHp = Math.max(2, Math.round(2 + (radius * radius) / 220));
      const hp = maxHp;

      const speed = clamp(150 - radius * 1.25 + Math.random() * 28, 55, 155);

      const src = getRandomEnemyImageSrc();
      const img = src ? getOrCreateImage(src) : null;

      enemies.push({
        x, y,
        radius,
        speed,
        hp, maxHp,
        img, imgSrc: src,

        hitFlash: 0,
        knockX: 0,
        knockY: 0
      });
    }

    // =================================================================
    // v0.07: GRID REVEAL RENDERING
    // =================================================================
    function drawRevealedGrid() {
      // Build two offscreen layers per frame:
      //  1) gridCanvas = crisp scrolling grid aligned to WORLD coords
      //  2) maskCanvas = accumulated reveal mask from trailPoints (screen-space)
      //
      // Then apply: gridCanvas * maskCanvas, and draw to main canvas.

      if (!gridCtx || !maskCtx) return;

      // --- 1) Draw grid into gridCanvas ---
      gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

      // View bounds in WORLD coordinates
      const left = camera.x - VIRTUAL_WIDTH / 2;
      const top = camera.y - VIRTUAL_HEIGHT / 2;
      const right = camera.x + VIRTUAL_WIDTH / 2;
      const bottom = camera.y + VIRTUAL_HEIGHT / 2;

      // Grid settings (world units)
      const major = 240;  // thicker line spacing
      const minor = 60;   // thin line spacing

      // Visual settings
      gridCtx.lineWidth = 1;

      function drawGridLines(spacing, alpha, isMajor) {
        gridCtx.strokeStyle = `rgba(180, 200, 255, ${alpha})`;

        // Vertical lines
        let x = Math.floor(left / spacing) * spacing;
        for (; x <= right; x += spacing) {
          const px = sx(x);
          gridCtx.beginPath();
          gridCtx.moveTo(px, 0);
          gridCtx.lineTo(px, gridCanvas.height);
          gridCtx.stroke();
        }

        // Horizontal lines
        let y = Math.floor(top / spacing) * spacing;
        for (; y <= bottom; y += spacing) {
          const py = sy(y);
          gridCtx.beginPath();
          gridCtx.moveTo(0, py);
          gridCtx.lineTo(gridCanvas.width, py);
          gridCtx.stroke();
        }
      }

      // Minor grid faint, major grid a bit stronger
      drawGridLines(minor, 0.10, false);
      gridCtx.lineWidth = 2;
      drawGridLines(major, 0.16, true);
      gridCtx.lineWidth = 1;

      // --- 2) Build reveal mask into maskCanvas ---
      // Mask is persistent in concept, but we rebuild it each frame from trailPoints,
      // which *effectively* persists since trailPoints persists.
      maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);

      // Scale reveal radius into screen pixels
      const scaleFactor = canvas.width / VIRTUAL_WIDTH;
      const revealPx = REVEAL_RADIUS * scaleFactor;

      // Draw all reveal spots (yes, it’s a loop; no, it’s not that bad unless you make 200k points)
      for (const p of trailPoints) {
        const cx = sx(p.x);
        const cy = sy(p.y);

        const grad = maskCtx.createRadialGradient(cx, cy, 0, cx, cy, revealPx);
        // solid-ish middle, soft edges
        grad.addColorStop(0.0, `rgba(255,255,255, ${REVEAL_HARD_CORE})`);
        grad.addColorStop(0.35, "rgba(255,255,255, 0.22)");
        grad.addColorStop(1.0, "rgba(255,255,255, 0.0)");

        maskCtx.fillStyle = grad;
        maskCtx.beginPath();
        maskCtx.arc(cx, cy, revealPx, 0, Math.PI * 2);
        maskCtx.fill();
      }

      // --- 3) Apply mask to gridCanvas ---
      // grid = grid * mask
      gridCtx.save();
      gridCtx.globalCompositeOperation = "destination-in";
      gridCtx.drawImage(maskCanvas, 0, 0);
      gridCtx.restore();

      // --- 4) Draw revealed grid onto the main canvas ---
      ctx.save();
      // Screen blend makes it feel like “lines emerging” rather than flat paint
      ctx.globalCompositeOperation = "screen";
      ctx.globalAlpha = 1.0;
      ctx.drawImage(gridCanvas, 0, 0);
      ctx.restore();
    }

    // =================================================================
    // UPDATE LOOP
    // =================================================================
    function update(dt) {
      if (isGameOver) return;

      player.iFrames = Math.max(0, player.iFrames - dt);

      const dmx = mouse.x - player.x;
      const dmy = mouse.y - player.y;
      player.angle = Math.atan2(dmy, dmx);

      let mvx = 0, mvy = 0;
      if (keys.w) mvy -= 1;
      if (keys.s) mvy += 1;
      if (keys.a) mvx -= 1;
      if (keys.d) mvx += 1;

      const mag = Math.hypot(mvx, mvy) || 1;
      mvx /= mag;
      mvy /= mag;

      const bumpDecay = Math.pow(0.0006, dt);
      player.bumpVelX *= bumpDecay;
      player.bumpVelY *= bumpDecay;

      player.x += (mvx * player.speed + player.bumpVelX) * dt;
      player.y += (mvy * player.speed + player.bumpVelY) * dt;

      camera.x = player.x;
      camera.y = player.y;

      // Record trail points (used for grid reveal)
      const dxTrail = player.x - lastTrailX;
      const dyTrail = player.y - lastTrailY;
      const trailDist = Math.hypot(dxTrail, dyTrail);

      if (trailDist >= TRAIL_STEP_DIST) {
        trailPoints.push({ x: player.x, y: player.y });
        lastTrailX = player.x;
        lastTrailY = player.y;

        if (trailPoints.length > MAX_TRAIL_POINTS) trailPoints.shift();
      }

      // Shooting
      if (mouse.isDown) {
        const t = performance.now() / 1000;
        if (t - lastShotTime >= SHOT_COOLDOWN) {
          shootBullet();
          lastShotTime = t;
        }
      }

      // Bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.prevX = b.x; b.prevY = b.y;
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        b.life -= dt;
        if (b.life <= 0) bullets.splice(i, 1);
      }

      // Spawn enemies
      enemySpawnTimer += dt;
      if (enemySpawnTimer >= ENEMY_SPAWN_INTERVAL) {
        enemySpawnTimer = 0;
        spawnEnemy();
      }

      // Enemy movement
      for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i];
        e.hitFlash = Math.max(0, e.hitFlash - dt);

        const kd = Math.pow(0.0008, dt);
        e.knockX *= kd;
        e.knockY *= kd;

        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const dist = Math.hypot(dx, dy) || 1;
        const dirX = dx / dist;
        const dirY = dy / dist;

        e.x += (dirX * e.speed + e.knockX) * dt;
        e.y += (dirY * e.speed + e.knockY) * dt;
      }

      // Enemy repulsion
      for (let i = 0; i < enemies.length; i++) {
        for (let j = i + 1; j < enemies.length; j++) {
          resolveOverlap(enemies[i], enemies[j], 0.55);
        }
      }

      // Player/enemy contact
      for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i];
        resolveOverlap(player, e, 0.9);

        const dx = e.x - player.x;
        const dy = e.y - player.y;
        const dist = Math.hypot(dx, dy) || 1;
        const combined = player.radius + e.radius;

        if (dist < combined * 1.02 && player.iFrames <= 0 && !isGameOver) {
          const sizeFactor = clamp(e.radius / 22, 0.7, 2.0);
          const dmg = Math.round(12 * sizeFactor);

          player.hp -= dmg;
          player.iFrames = 0.55;

          const nx = (player.x - e.x) / dist;
          const ny = (player.y - e.y) / dist;

          player.bumpVelX += nx * (420 / sizeFactor);
          player.bumpVelY += ny * (420 / sizeFactor);

          e.knockX -= nx * (220 * sizeFactor);
          e.knockY -= ny * (220 * sizeFactor);

          playSfx("playerHit", 0.85);

          if (player.hp <= 0) {
            player.hp = 0;
            handleGameOver();
          }
        }
      }

      // Bullets vs enemies (swept)
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];

        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          const hitR = e.radius + b.radius * 1.35;

          if (segmentHitsCircle(b.prevX, b.prevY, b.x, b.y, e.x, e.y, hitR)) {
            e.hp -= b.damage;
            e.hitFlash = 0.08;

            const vx = b.x - b.prevX;
            const vy = b.y - b.prevY;
            const vlen = Math.hypot(vx, vy) || 1;
            const nx = vx / vlen;
            const ny = vy / vlen;

            const resist = clamp(e.radius / 26, 0.8, 2.4);
            e.knockX += nx * (520 / resist);
            e.knockY += ny * (520 / resist);

            playSfx("enemyHit", 0.65);
            bullets.splice(j, 1);

            if (e.hp <= 0) {
              score += 10 + Math.round(e.maxHp);
              enemies.splice(i, 1);
            }
            break;
          }
        }
      }

      hpDisplay.textContent = Math.max(0, player.hp).toFixed(0);
      scoreDisplay.textContent = score;
    }

    // =================================================================
    // DRAW LOOP
    // =================================================================
    function drawEnemyHealthBar(e, scaleFactor) {
      const barW = (e.radius * 2) * scaleFactor;
      const barH = 6;
      const pad = 2;

      const x = sx(e.x) - barW / 2;
      const y = sy(e.y) - (e.radius * scaleFactor) - 14;

      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.fillRect(x - pad, y - pad, barW + pad * 2, barH + pad * 2);

      const pct = e.maxHp > 0 ? (e.hp / e.maxHp) : 0;
      ctx.fillStyle = "rgba(90,255,120,0.9)";
      ctx.fillRect(x, y, barW * clamp(pct, 0, 1), barH);

      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = 1;
      ctx.strokeRect(x - pad, y - pad, barW + pad * 2, barH + pad * 2);
    }

    function draw() {
      // Base void stays black, but now the grid will appear where you've walked.
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // v0.07: draw revealed grid floor
      drawRevealedGrid();

      const scaleFactor = canvas.width / VIRTUAL_WIDTH;

      // Bullets
      for (const b of bullets) {
        ctx.beginPath();
        ctx.arc(sx(b.x), sy(b.y), b.radius * scaleFactor, 0, Math.PI * 2);
        ctx.fillStyle = "#ffdd55";
        ctx.fill();
      }

      // Enemies (no visible hitbox rings)
      for (const e of enemies) {
        const rr = e.radius * scaleFactor;
        const ex = sx(e.x);
        const ey = sy(e.y);

        if (e.img && e.img.complete && e.img.naturalWidth > 0) {
          ctx.save();
          ctx.imageSmoothingEnabled = true;

          if (e.hitFlash > 0) {
            const t = clamp(e.hitFlash / 0.08, 0, 1);
            ctx.globalAlpha = lerp(1.0, 0.65, t);
          }

          ctx.drawImage(e.img, ex - rr, ey - rr, rr * 2, rr * 2);
          ctx.restore();
        } else {
          ctx.fillStyle = "rgba(255, 80, 80, 0.85)";
          ctx.fillRect(ex - rr, ey - rr, rr * 2, rr * 2);
        }

        drawEnemyHealthBar(e, scaleFactor);
      }

      // Player
      const pr = player.radius * scaleFactor;
      ctx.beginPath();
      ctx.arc(sx(player.x), sy(player.y), pr, 0, Math.PI * 2);
      ctx.fillStyle = (player.iFrames > 0) ? "rgba(85,170,255,0.75)" : "#55aaff";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#ffffff";
      ctx.stroke();

      // Gun direction
      const gunLen = player.radius + 10;
      const gx = player.x + Math.cos(player.angle) * gunLen;
      const gy = player.y + Math.sin(player.angle) * gunLen;

      ctx.beginPath();
      ctx.moveTo(sx(player.x), sy(player.y));
      ctx.lineTo(sx(gx), sy(gy));
      ctx.strokeStyle = "#ffffff";
      ctx.stroke();

      if (isGameOver) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    function handleGameOver() {
      isGameOver = true;
      gameOverMessage.style.opacity = 1;
    }

    // =================================================================
    // MAIN LOOP
    // =================================================================
    let lastTime = performance.now();
    function gameLoop(t) {
      const dt = (t - lastTime) / 1000;
      lastTime = t;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
