<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shooter Game v0.08</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    #game {
      width: 100%;
      height: 100%;
      display: block;
      background: #000;
      border: 2px solid #444;
    }

    #ui {
      position: absolute;
      left: 10px;
      top: 10px;
      pointer-events: none;
      z-index: 10;
      font-size: 14px;
      text-shadow: 0 0 6px rgba(0,0,0,0.9);
      line-height: 1.35;
    }

    #gameOverMessage {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 34px;
      font-weight: 800;
      color: #ff5555;
      text-shadow: 0 0 14px rgba(0,0,0,0.95);
      opacity: 0;
      transition: opacity 0.25s ease;
      pointer-events: none;
      z-index: 30;
    }

    #hint {
      position: absolute;
      left: 10px;
      bottom: 10px;
      pointer-events: none;
      z-index: 10;
      font-size: 12px;
      opacity: 0.75;
      text-shadow: 0 0 6px rgba(0,0,0,0.9);
    }
  </style>
</head>

<body>
  <div id="gameContainer">
    <canvas id="game"></canvas>

    <div id="ui">
      <div><b>shooter-game v0.08</b> (tunnel runner)</div>
      <div>WASD = move | Mouse = aim | LMB = shoot | R = restart</div>
      <div>HP: <span id="hpDisplay">100</span> | Score: <span id="scoreDisplay">0</span></div>
      <div>Waypoint: <span id="wpDisplay">0</span> | Enemies: <span id="enemyDisplay">0</span></div>
      <div style="opacity:0.85">GIF enemies via /media/images/gifs/index.json</div>
    </div>

    <div id="hint">
      Tip: don’t fall behind the scroll. Waypoints spawn harder waves.
    </div>

    <div id="gameOverMessage">GAME OVER</div>
  </div>

  <script>
    // ================================================================
    // Shooter Game v0.08 (FULL FILE)
    //
    // CORE SHIFT: Arena -> Left-to-right scrolling tunnel runner.
    // - Camera auto-advances right through a tunnel with walls & obstacles.
    // - Waypoints every segment; crossing triggers progressively harder waves.
    // - Obstacles are procedural per segment (deterministic).
    // - Enemies still come from /media/images/gifs/index.json
    // - Enemy behavior is deterministic from image filename (hash):
    //     speed + style + wobble/jitter/charge patterns
    //
    // Collision:
    // - Player circle vs tunnel walls and obstacle AABBs (push-out resolution).
    // - Bullets use swept segment-vs-circle for enemies (prevents phasing).
    // - Bullets collide with obstacles (stop).
    //
    // Audio:
    // - hitmarker.mp3 for enemy damage
    // - oof.mp3 for player damage
    //
    // No visible enemy hitbox circles.
    // ================================================================

    // ---------------------------
    // Canvas + scaling
    // ---------------------------
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const hpDisplay = document.getElementById("hpDisplay");
    const scoreDisplay = document.getElementById("scoreDisplay");
    const wpDisplay = document.getElementById("wpDisplay");
    const enemyDisplay = document.getElementById("enemyDisplay");
    const gameOverMessage = document.getElementById("gameOverMessage");

    // Virtual viewport (world units)
    const VIRTUAL_WIDTH = 1200;
    const VIRTUAL_HEIGHT = 800;

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const camera = { x: 0, y: 0 };

    function sx(worldX) {
      const viewportX = (worldX - camera.x) + VIRTUAL_WIDTH / 2;
      return (viewportX / VIRTUAL_WIDTH) * canvas.width;
    }
    function sy(worldY) {
      const viewportY = (worldY - camera.y) + VIRTUAL_HEIGHT / 2;
      return (viewportY / VIRTUAL_HEIGHT) * canvas.height;
    }

    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function hypot(x, y) { return Math.hypot(x, y); }

    // ---------------------------
    // Deterministic RNG utilities
    // ---------------------------
    function hashStringFNV1a(str) {
      // 32-bit FNV-1a
      let h = 0x811c9dc5;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 0x01000193);
      }
      return h >>> 0;
    }

    function makeRng(seed) {
      // xorshift32
      let s = seed >>> 0;
      return function rand() {
        s ^= s << 13; s >>>= 0;
        s ^= s >>> 17; s >>>= 0;
        s ^= s << 5;  s >>>= 0;
        return (s >>> 0) / 4294967296;
      };
    }

    // ---------------------------
    // World: tunnel + segments
    // ---------------------------
    const TUNNEL_TOP = 60;                 // world y
    const TUNNEL_BOTTOM = 740;             // world y
    const TUNNEL_H = TUNNEL_BOTTOM - TUNNEL_TOP;

    const SEG_LEN = 1500;                 // world x length per segment
    const SEG_BUFFER_AHEAD = 3;           // keep generated segments ahead
    const SEG_BUFFER_BEHIND = 1;          // keep segments behind (for collision/cleanup)

    // Auto-scroll
    const SCROLL_BASE = 250;              // world units/sec
    let scrollSpeed = SCROLL_BASE;

    // Pressure behind camera
    const BACK_SOFT_LIMIT = 520;          // behind camera.x
    const BACK_HARD_LIMIT = 700;          // gameover if farther behind

    // Waypoint system
    let waypointIndex = 0;                // number of passed waypoints
    function waypointX(i) { return (i + 1) * SEG_LEN; } // waypoint lines at segment boundaries

    // Segments store obstacles (rects)
    // rect: {x,y,w,h}
    const segments = new Map(); // key: segIndex -> { obstacles: [] }

    function worldSegIndex(x) {
      return Math.floor(x / SEG_LEN);
    }

    function ensureSegmentsAroundCamera() {
      const camSeg = worldSegIndex(camera.x);
      const minSeg = camSeg - SEG_BUFFER_BEHIND;
      const maxSeg = camSeg + SEG_BUFFER_AHEAD;

      for (let si = minSeg; si <= maxSeg; si++) {
        if (!segments.has(si)) {
          segments.set(si, generateSegment(si));
        }
      }

      // Cleanup far segments
      for (const key of segments.keys()) {
        if (key < minSeg - 2 || key > maxSeg + 4) {
          segments.delete(key);
        }
      }
    }

    function generateSegment(segIndex) {
      // Deterministic segment generation based on segIndex
      const seed = hashStringFNV1a("SEG:" + segIndex);
      const rand = makeRng(seed);

      const obstacles = [];

      // Difficulty influences obstacle density mildly
      const difficulty = segIndex; // roughly increases as you go right
      const density = clamp(0.9 + difficulty * 0.03, 0.9, 2.4); // scaling factor

      // Number of obstacle "sets" in segment
      const baseSets = 3;
      const sets = Math.floor(baseSets * density);

      const segX0 = segIndex * SEG_LEN;
      const segX1 = segX0 + SEG_LEN;

      // We create obstacle sets as vertical blockers leaving a guaranteed gap lane.
      // Each set: one big block from top or bottom, sometimes both with a corridor.
      for (let k = 0; k < sets; k++) {
        const px = lerp(segX0 + 260, segX1 - 260, rand());
        const w = lerp(90, 180, rand());
        const gap = lerp(170, 280, rand()); // passable corridor height
        const gapCenter = lerp(TUNNEL_TOP + 120, TUNNEL_BOTTOM - 120, rand());
        const gapTop = clamp(gapCenter - gap / 2, TUNNEL_TOP + 20, TUNNEL_BOTTOM - 20 - gap);
        const gapBottom = gapTop + gap;

        // Top block
        const topH = gapTop - TUNNEL_TOP;
        if (topH > 40) {
          obstacles.push({
            x: px - w / 2,
            y: TUNNEL_TOP,
            w,
            h: topH
          });
        }

        // Bottom block
        const bottomH = TUNNEL_BOTTOM - gapBottom;
        if (bottomH > 40) {
          obstacles.push({
            x: px - w / 2,
            y: gapBottom,
            w,
            h: bottomH
          });
        }

        // Occasionally add a mid "pillar" to force lateral adjustments
        if (rand() < 0.35) {
          const ph = lerp(60, 140, rand());
          const py = lerp(gapTop + 10, gapBottom - 10 - ph, rand());
          obstacles.push({
            x: px + lerp(-240, 240, rand()) - w * 0.35,
            y: py,
            w: lerp(50, 90, rand()),
            h: ph
          });
        }
      }

      // Safety: don’t put obstacles right at the segment boundary where waypoint triggers
      // We’ll keep collision but allow a small buffer.
      const safe = 90;
      const filtered = obstacles.filter(r => r.x + r.w > segX0 + safe && r.x < segX1 - safe);

      return { obstacles: filtered };
    }

    function getNearbyObstacles(x) {
      const si = worldSegIndex(x);
      const obs = [];
      for (let k = si - 1; k <= si + 1; k++) {
        const seg = segments.get(k);
        if (seg) obs.push(...seg.obstacles);
      }
      return obs;
    }

    // ---------------------------
    // Player + entities
    // ---------------------------
    const player = {
      x: 180,
      y: (TUNNEL_TOP + TUNNEL_BOTTOM) / 2,
      radius: 14,
      speed: 290,
      angle: 0,
      hp: 100,
      maxHp: 100,
      iFrames: 0,
      bumpVelX: 0,
      bumpVelY: 0
    };

    const bullets = [];
    const enemies = [];

    const keys = { w: false, a: false, s: false, d: false };
    const mouse = { x: 0, y: 0, isDown: false };

    let score = 0;
    let isGameOver = false;

    // Shooting
    let lastShotTime = 0;
    const SHOT_COOLDOWN = 0.13;

    // ---------------------------
    // Enemy images: index.json
    // ---------------------------
    const ENEMY_GIF_INDEX_URL = "/media/images/gifs/index.json";
    const ENEMY_GIF_BASE_URL = "/media/images/gifs/";
    let enemyGifFilenames = [];
    const imageCache = new Map();

    function normalizeIndexJsonToFilenames(json) {
      if (Array.isArray(json)) return json.filter(v => typeof v === "string");
      if (json && typeof json === "object") {
        for (const key of ["files", "gifs", "images", "items"]) {
          if (Array.isArray(json[key])) {
            const out = [];
            for (const it of json[key]) {
              if (typeof it === "string") out.push(it);
              else if (it && typeof it === "object") {
                if (typeof it.name === "string") out.push(it.name);
                else if (typeof it.filename === "string") out.push(it.filename);
                else if (typeof it.file === "string") out.push(it.file);
              }
            }
            if (out.length) return out;
          }
        }
        const keys = Object.keys(json);
        const looks = keys.filter(k => /\.(gif|png|jpg|jpeg|webp)$/i.test(k));
        if (looks.length) return looks;
      }
      return [];
    }

    async function loadEnemyGifIndex() {
      try {
        const res = await fetch(ENEMY_GIF_INDEX_URL, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();
        enemyGifFilenames = normalizeIndexJsonToFilenames(json)
          .map(s => String(s).trim())
          .filter(Boolean)
          .filter(n => !n.endsWith("/") && !n.includes(".."));
        console.log("[v0.08] Loaded enemy list:", enemyGifFilenames.length);
      } catch (err) {
        console.warn("[v0.08] Failed to load enemy index.json:", err);
        enemyGifFilenames = [];
      }
    }

    function getOrCreateImage(src) {
      if (imageCache.has(src)) return imageCache.get(src);
      const img = new Image();
      img.src = src;
      imageCache.set(src, img);
      return img;
    }

    function getRandomEnemyImageSrc(rand) {
      if (!enemyGifFilenames.length) return null;
      const filename = enemyGifFilenames[Math.floor(rand() * enemyGifFilenames.length)];
      return ENEMY_GIF_BASE_URL + filename;
    }

    loadEnemyGifIndex();

    // ---------------------------
    // Audio
    // ---------------------------
    const SFX = {
      enemyHit: "/media/audio/hitmarker.mp3",
      playerHit: "/media/audio/oof.mp3"
    };

    const sfxThrottle = {
      enemyHit: { last: 0, minGap: 0.04 },
      playerHit: { last: 0, minGap: 0.16 }
    };

    function playSfx(key, volume = 0.8) {
      const now = performance.now() / 1000;
      const t = sfxThrottle[key];
      if (t && now - t.last < t.minGap) return;
      if (t) t.last = now;

      const a = new Audio(SFX[key]);
      a.volume = volume;
      a.play().catch(() => {});
    }

    // ---------------------------
    // Input
    // ---------------------------
    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = true;
      if (k === "a") keys.a = true;
      if (k === "s") keys.s = true;
      if (k === "d") keys.d = true;
      if (k === "r" && isGameOver) location.reload();
    });

    window.addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = false;
      if (k === "a") keys.a = false;
      if (k === "s") keys.s = false;
      if (k === "d") keys.d = false;
    });

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      const nx = (e.clientX - rect.left) / canvas.width;
      const ny = (e.clientY - rect.top) / canvas.height;

      // Map mouse to world using camera-centered virtual viewport
      mouse.x = camera.x + (nx - 0.5) * VIRTUAL_WIDTH;
      mouse.y = camera.y + (ny - 0.5) * VIRTUAL_HEIGHT;
    });

    canvas.addEventListener("mousedown", (e) => { if (e.button === 0) mouse.isDown = true; });
    canvas.addEventListener("mouseup", (e) => { if (e.button === 0) mouse.isDown = false; });

    // ---------------------------
    // Collision helpers
    // ---------------------------
    function closestPointOnSegment(ax, ay, bx, by, px, py) {
      const abx = bx - ax, aby = by - ay;
      const apx = px - ax, apy = py - ay;
      const abLen2 = abx * abx + aby * aby;
      if (abLen2 <= 1e-9) return { x: ax, y: ay, t: 0 };
      let t = (apx * abx + apy * aby) / abLen2;
      t = clamp(t, 0, 1);
      return { x: ax + abx * t, y: ay + aby * t, t };
    }

    function segmentHitsCircle(ax, ay, bx, by, cx, cy, r) {
      const c = closestPointOnSegment(ax, ay, bx, by, cx, cy);
      const dx = cx - c.x, dy = cy - c.y;
      return (dx * dx + dy * dy) <= (r * r);
    }

    function circleVsAABBResolve(c, r, rect) {
      // Push circle (center c:{x,y}) out of rect if overlapping.
      const closestX = clamp(c.x, rect.x, rect.x + rect.w);
      const closestY = clamp(c.y, rect.y, rect.y + rect.h);
      const dx = c.x - closestX;
      const dy = c.y - closestY;
      const d2 = dx * dx + dy * dy;

      if (d2 < r * r) {
        const d = Math.sqrt(d2) || 0.0001;
        const nx = dx / d;
        const ny = dy / d;
        const push = (r - d);

        c.x += nx * push;
        c.y += ny * push;
        return { hit: true, nx, ny, push };
      }
      return { hit: false, nx: 0, ny: 0, push: 0 };
    }

    function clampToTunnel(entity) {
      // Tunnel walls: y in [TUNNEL_TOP + r, TUNNEL_BOTTOM - r]
      const r = entity.radius;
      if (entity.y < TUNNEL_TOP + r) entity.y = TUNNEL_TOP + r;
      if (entity.y > TUNNEL_BOTTOM - r) entity.y = TUNNEL_BOTTOM - r;
    }

    // ---------------------------
    // Enemy behavior (deterministic from image filename)
    // ---------------------------
    const ENEMY_STYLES = ["chaser", "zigzag", "dasher", "drifter", "skitter"];

    function makeEnemyProfileFromImage(src, difficulty) {
      const name = src ? src.split("/").pop() : "fallback";
      const seed = hashStringFNV1a("ENEMY:" + name);
      const rand = makeRng(seed);

      const style = ENEMY_STYLES[seed % ENEMY_STYLES.length];

      // Size influences HP and collision radius.
      const sizeFactor = clamp(0.70 + rand() * 1.60, 0.65, 2.25);
      const radius = clamp(16 * sizeFactor, 12, 46);

      // Base HP: size + difficulty ramp
      const hpBase = Math.round(2 + (radius * radius) / 240);
      const hp = Math.max(2, Math.round(hpBase + difficulty * 0.35));

      // Speed: style + difficulty ramp (deterministic)
      const speedBase = 120 + rand() * 120 + difficulty * 2.6;

      // Personality params
      const wobbleAmp = 30 + rand() * 110;
      const wobbleFreq = 0.7 + rand() * 1.6;
      const jitter = rand() * 1.0;

      // Dash params
      const dashPeriod = 1.0 + rand() * 1.2;
      const dashDuration = 0.25 + rand() * 0.22;
      const dashBoost = 1.8 + rand() * 1.5;

      // Drift params
      const driftBias = (rand() * 2 - 1) * 0.9;

      return {
        name,
        seed,
        rand,
        style,
        radius,
        maxHp: hp,
        baseSpeed: speedBase,
        wobbleAmp,
        wobbleFreq,
        jitter,
        dashPeriod,
        dashDuration,
        dashBoost,
        driftBias
      };
    }

    function spawnWave(waypointIdx) {
      // Difficulty increases with waypoint
      const difficulty = waypointIdx;

      // Determine spawn count
      const base = 4 + Math.floor(difficulty * 0.8);
      const variance = Math.floor(difficulty * 0.35);
      const count = clamp(base + Math.floor(Math.random() * (variance + 1)), 4, 30);

      // Spawn in the next segment (ahead of the waypoint)
      const waveSeg = waypointIdx + 1;
      const segX0 = waveSeg * SEG_LEN;
      const segX1 = segX0 + SEG_LEN;

      const rand = makeRng(hashStringFNV1a("WAVE:" + waypointIdx));
      for (let i = 0; i < count; i++) {
        const src = getRandomEnemyImageSrc(rand);
        const img = src ? getOrCreateImage(src) : null;

        const profile = makeEnemyProfileFromImage(src || "fallback", difficulty);

        const x = lerp(segX0 + 250, segX1 - 250, rand());
        const y = lerp(TUNNEL_TOP + 40, TUNNEL_BOTTOM - 40, rand());

        enemies.push({
          x, y,
          radius: profile.radius,
          hp: profile.maxHp,
          maxHp: profile.maxHp,
          img, imgSrc: src,

          // Behavior
          style: profile.style,
          baseSpeed: profile.baseSpeed,
          seed: profile.seed,

          // State
          t0: performance.now() / 1000,
          phase: rand() * Math.PI * 2,
          hitFlash: 0,
          knockX: 0,
          knockY: 0,
          dashTimer: rand() * profile.dashPeriod,

          // Params
          wobbleAmp: profile.wobbleAmp,
          wobbleFreq: profile.wobbleFreq,
          jitter: profile.jitter,
          dashPeriod: profile.dashPeriod,
          dashDuration: profile.dashDuration,
          dashBoost: profile.dashBoost,
          driftBias: profile.driftBias
        });
      }
    }

    // ---------------------------
    // Shooting
    // ---------------------------
    function shootBullet() {
      const dx = mouse.x - player.x;
      const dy = mouse.y - player.y;
      const len = hypot(dx, dy) || 1;

      const dirX = dx / len;
      const dirY = dy / len;

      const bulletSpeed = 800;

      bullets.push({
        x: player.x,
        y: player.y,
        prevX: player.x,
        prevY: player.y,
        radius: 3.8,
        vx: dirX * bulletSpeed,
        vy: dirY * bulletSpeed,
        life: 1.35,
        damage: (Math.random() < 0.10) ? 2 : 1
      });
    }

    // ---------------------------
    // Game Over
    // ---------------------------
    function handleGameOver() {
      isGameOver = true;
      gameOverMessage.style.opacity = 1;
    }

    // ---------------------------
    // Update loop
    // ---------------------------
    function update(dt) {
      if (isGameOver) return;

      // Auto scroll ramps slightly with waypoint (difficulty)
      scrollSpeed = SCROLL_BASE + waypointIndex * 10;
      camera.x += scrollSpeed * dt;

      // Keep camera centered vertically in tunnel
      camera.y = (TUNNEL_TOP + TUNNEL_BOTTOM) / 2;

      ensureSegmentsAroundCamera();

      // Waypoint check: player crosses line (in world X)
      const nextWpX = waypointX(waypointIndex);
      if (player.x >= nextWpX) {
        waypointIndex++;
        wpDisplay.textContent = waypointIndex.toString();

        // Ensure new segments exist and spawn a new wave
        ensureSegmentsAroundCamera();
        spawnWave(waypointIndex);

        // Small reward for progress (optional feel-good)
        player.hp = clamp(player.hp + 4, 0, player.maxHp);
      }

      // Player facing
      const dmx = mouse.x - player.x;
      const dmy = mouse.y - player.y;
      player.angle = Math.atan2(dmy, dmx);

      // Player i-frames
      player.iFrames = Math.max(0, player.iFrames - dt);

      // Movement input
      let mvx = 0, mvy = 0;
      if (keys.w) mvy -= 1;
      if (keys.s) mvy += 1;
      if (keys.a) mvx -= 1;
      if (keys.d) mvx += 1;

      const mag = hypot(mvx, mvy) || 1;
      mvx /= mag; mvy /= mag;

      // Bump velocity decay
      const bumpDecay = Math.pow(0.0007, dt);
      player.bumpVelX *= bumpDecay;
      player.bumpVelY *= bumpDecay;

      player.x += (mvx * player.speed + player.bumpVelX) * dt;
      player.y += (mvy * player.speed + player.bumpVelY) * dt;

      // Pressure: prevent staying too far behind camera
      const behind = camera.x - player.x;
      if (behind > BACK_SOFT_LIMIT) {
        // Soft push forward (rubber band)
        player.x += (behind - BACK_SOFT_LIMIT) * 1.6 * dt;
      }
      if (behind > BACK_HARD_LIMIT) {
        // If you fall way behind, you lose.
        handleGameOver();
      }

      // Clamp to tunnel walls
      clampToTunnel(player);

      // Player obstacle collisions
      const nearbyObs = getNearbyObstacles(player.x);
      for (const r of nearbyObs) {
        circleVsAABBResolve(player, player.radius, r);
        clampToTunnel(player);
      }

      // Shooting
      if (mouse.isDown) {
        const t = performance.now() / 1000;
        if (t - lastShotTime >= SHOT_COOLDOWN) {
          shootBullet();
          lastShotTime = t;
        }
      }

      // Bullets update + obstacle collision
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.prevX = b.x; b.prevY = b.y;

        b.x += b.vx * dt;
        b.y += b.vy * dt;
        b.life -= dt;

        // Remove if out of tunnel vertical bounds too far
        if (b.y < TUNNEL_TOP - 120 || b.y > TUNNEL_BOTTOM + 120) {
          bullets.splice(i, 1);
          continue;
        }

        // Bullet hits obstacles: stop it
        const obs = getNearbyObstacles(b.x);
        let hitObs = false;
        for (const r of obs) {
          // Swept-ish: check segment vs expanded rect by bullet radius
          // Simple approximation: test current point inside rect expanded
          const ex = r.x - b.radius, ey = r.y - b.radius, ew = r.w + b.radius * 2, eh = r.h + b.radius * 2;
          const insideNow = (b.x >= ex && b.x <= ex + ew && b.y >= ey && b.y <= ey + eh);
          const insidePrev = (b.prevX >= ex && b.prevX <= ex + ew && b.prevY >= ey && b.prevY <= ey + eh);
          if (insideNow || insidePrev) { hitObs = true; break; }
        }
        if (hitObs) {
          bullets.splice(i, 1);
          continue;
        }

        if (b.life <= 0) bullets.splice(i, 1);
      }

      // Enemies update: move styles + collisions
      const now = performance.now() / 1000;

      // Cleanup enemies that are far behind camera
      for (let i = enemies.length - 1; i >= 0; i--) {
        if (enemies[i].x < camera.x - (VIRTUAL_WIDTH / 2 + 900)) {
          enemies.splice(i, 1);
        }
      }

      for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i];

        e.hitFlash = Math.max(0, e.hitFlash - dt);

        // Knockback decay
        const kd = Math.pow(0.0008, dt);
        e.knockX *= kd;
        e.knockY *= kd;

        // Targeting vectors
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const dist = hypot(dx, dy) || 1;
        const tx = dx / dist;
        const ty = dy / dist;

        // Default velocities
        let vx = 0, vy = 0;

        // Style logic (deterministic parameters baked into enemy)
        if (e.style === "chaser") {
          vx = tx * e.baseSpeed;
          vy = ty * e.baseSpeed;

        } else if (e.style === "zigzag") {
          // Moves forward (right) and oscillates vertically, still slightly attracted to player
          const phase = e.phase + (now - e.t0) * e.wobbleFreq;
          const osc = Math.sin(phase) * e.wobbleAmp;
          vx = (0.92 * e.baseSpeed) + tx * (0.35 * e.baseSpeed);
          vy = (ty * 0.40 * e.baseSpeed) + osc;

        } else if (e.style === "dasher") {
          // Periodic dash bursts toward player’s x with some y correction
          e.dashTimer += dt;
          const t = e.dashTimer % e.dashPeriod;
          const dashing = (t < e.dashDuration);

          const boost = dashing ? e.dashBoost : 0.75;
          vx = tx * e.baseSpeed * boost + 0.35 * e.baseSpeed;
          vy = ty * e.baseSpeed * (dashing ? 0.55 : 0.30);

        } else if (e.style === "drifter") {
          // Slow float that prefers lane denial: drifts to player y, but tries to sit near player x+offset
          const desiredX = player.x + 220; // “in your way” behavior
          const ddx = desiredX - e.x;
          const dd = Math.abs(ddx) + 1;
          const dirX = ddx / dd;

          vx = dirX * (0.85 * e.baseSpeed) + 0.25 * e.baseSpeed;
          vy = (ty * 0.45 * e.baseSpeed) + e.driftBias * 30;

        } else if (e.style === "skitter") {
          // Fast erratic nuisance: biased forward, jitter in y, low-ish HP naturally via size
          const seedRand = makeRng((e.seed ^ (Math.floor(now * 8) >>> 0)) >>> 0);
          const j = (seedRand() * 2 - 1) * (60 + e.jitter * 140);

          vx = 1.05 * e.baseSpeed + tx * 0.25 * e.baseSpeed;
          vy = ty * 0.30 * e.baseSpeed + j;
        }

        // Apply knockback
        vx += e.knockX;
        vy += e.knockY;

        // Integrate
        e.x += vx * dt;
        e.y += vy * dt;

        // Clamp to tunnel walls
        clampToTunnel(e);

        // Enemy obstacle collision (push out)
        const obs = getNearbyObstacles(e.x);
        for (const r of obs) {
          const res = circleVsAABBResolve(e, e.radius, r);
          if (res.hit) {
            // Slight bounce in y if we hit something (keeps them from sticking)
            e.knockY += res.ny * 120;
          }
          clampToTunnel(e);
        }
      }

      // Enemy repulsion (reduces unfair stacks)
      for (let i = 0; i < enemies.length; i++) {
        for (let j = i + 1; j < enemies.length; j++) {
          const a = enemies[i], b = enemies[j];
          const dx = b.x - a.x, dy = b.y - a.y;
          const d = hypot(dx, dy) || 1;
          const minD = a.radius + b.radius;
          const overlap = minD - d;
          if (overlap > 0) {
            const nx = dx / d, ny = dy / d;
            const push = overlap * 0.35;
            a.x -= nx * push * 0.5; a.y -= ny * push * 0.5;
            b.x += nx * push * 0.5; b.y += ny * push * 0.5;
          }
        }
      }

      // Player/enemy contact damage (arcadey, not glue)
      for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i];
        const dx = e.x - player.x;
        const dy = e.y - player.y;
        const d = hypot(dx, dy) || 1;
        const combined = e.radius + player.radius;

        if (d < combined) {
          // Separate a bit immediately
          const nx = dx / d, ny = dy / d;
          const push = (combined - d) * 0.9;
          player.x -= nx * push;
          player.y -= ny * push;
          clampToTunnel(player);

          if (player.iFrames <= 0) {
            // Damage scales with enemy size and current waypoint
            const sizeFactor = clamp(e.radius / 22, 0.7, 2.4);
            const dmg = Math.round(10 * sizeFactor + waypointIndex * 0.18);

            player.hp -= dmg;
            player.iFrames = 0.55;

            // Knockback away
            player.bumpVelX -= nx * (520 / sizeFactor);
            player.bumpVelY -= ny * (520 / sizeFactor);

            // Enemy also jolts
            e.knockX += nx * (240 * sizeFactor);
            e.knockY += ny * (240 * sizeFactor);

            playSfx("playerHit", 0.85);

            if (player.hp <= 0) {
              player.hp = 0;
              handleGameOver();
              break;
            }
          }
        }
      }

      // Bullets vs enemies (swept)
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];

        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];

          const hitR = e.radius + b.radius * 1.35;
          if (segmentHitsCircle(b.prevX, b.prevY, b.x, b.y, e.x, e.y, hitR)) {
            e.hp -= b.damage;
            e.hitFlash = 0.08;
            playSfx("enemyHit", 0.65);

            // Knock enemy in bullet direction
            const vx = b.x - b.prevX;
            const vy = b.y - b.prevY;
            const vlen = hypot(vx, vy) || 1;
            const nx = vx / vlen;
            const ny = vy / vlen;

            const resist = clamp(e.radius / 26, 0.8, 2.6);
            e.knockX += nx * (560 / resist);
            e.knockY += ny * (560 / resist);

            bullets.splice(j, 1);

            if (e.hp <= 0) {
              score += 10 + Math.round(e.maxHp * 0.7) + waypointIndex;
              enemies.splice(i, 1);
            }
            break;
          }
        }
      }

      // UI
      hpDisplay.textContent = Math.max(0, player.hp).toFixed(0);
      scoreDisplay.textContent = score.toString();
      enemyDisplay.textContent = enemies.length.toString();
      wpDisplay.textContent = waypointIndex.toString();
    }

    // ---------------------------
    // Drawing
    // ---------------------------
    function drawGridTunnelFloor() {
      // Subtle scrolling grid that reads like a “tunnel floor”
      // Grid aligned to world coords for stability.
      const left = camera.x - VIRTUAL_WIDTH / 2;
      const right = camera.x + VIRTUAL_WIDTH / 2;
      const top = TUNNEL_TOP;
      const bottom = TUNNEL_BOTTOM;

      // Background inside tunnel
      ctx.fillStyle = "rgba(0,0,0,1)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Dark vignette outside tunnel
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.92)";
      const tunnelTopS = sy(TUNNEL_TOP);
      const tunnelBottomS = sy(TUNNEL_BOTTOM);
      ctx.fillRect(0, 0, canvas.width, tunnelTopS);
      ctx.fillRect(0, tunnelBottomS, canvas.width, canvas.height - tunnelBottomS);
      ctx.restore();

      // Tunnel floor panel (very subtle)
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgba(6, 10, 18, 1)";
      ctx.fillRect(0, tunnelTopS, canvas.width, tunnelBottomS - tunnelTopS);
      ctx.restore();

      // Grid lines
      const minor = 60;
      const major = 240;

      // Minor
      ctx.save();
      ctx.lineWidth = 1;

      function drawLines(spacing, alpha, width) {
        ctx.lineWidth = width;
        ctx.strokeStyle = `rgba(160, 190, 255, ${alpha})`;

        let x = Math.floor(left / spacing) * spacing;
        for (; x <= right; x += spacing) {
          const px = sx(x);
          ctx.beginPath();
          ctx.moveTo(px, sy(top));
          ctx.lineTo(px, sy(bottom));
          ctx.stroke();
        }

        let y = Math.floor(top / spacing) * spacing;
        for (; y <= bottom; y += spacing) {
          const py = sy(y);
          ctx.beginPath();
          ctx.moveTo(0, py);
          ctx.lineTo(canvas.width, py);
          ctx.stroke();
        }
      }

      drawLines(minor, 0.08, 1);
      drawLines(major, 0.14, 2);
      ctx.restore();

      // Tunnel walls
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, sy(TUNNEL_TOP));
      ctx.lineTo(canvas.width, sy(TUNNEL_TOP));
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, sy(TUNNEL_BOTTOM));
      ctx.lineTo(canvas.width, sy(TUNNEL_BOTTOM));
      ctx.stroke();
      ctx.restore();
    }

    function drawObstacles() {
      // Draw nearby obstacles for performance
      const leftX = camera.x - VIRTUAL_WIDTH / 2 - 100;
      const rightX = camera.x + VIRTUAL_WIDTH / 2 + 100;

      const si0 = worldSegIndex(leftX);
      const si1 = worldSegIndex(rightX);

      for (let si = si0; si <= si1; si++) {
        const seg = segments.get(si);
        if (!seg) continue;

        for (const r of seg.obstacles) {
          // Only draw if in view
          if (r.x + r.w < leftX || r.x > rightX) continue;

          const x = sx(r.x);
          const y = sy(r.y);
          const w = (r.w / VIRTUAL_WIDTH) * canvas.width;
          const h = (r.h / VIRTUAL_HEIGHT) * canvas.height;

          // Slight neon-ish obstruction feel
          ctx.save();
          ctx.fillStyle = "rgba(25, 35, 55, 0.95)";
          ctx.fillRect(x, y, w, h);

          ctx.strokeStyle = "rgba(140, 180, 255, 0.25)";
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);

          // Subtle inner highlight
          ctx.strokeStyle = "rgba(255, 255, 255, 0.10)";
          ctx.lineWidth = 1;
          ctx.strokeRect(x + 2, y + 2, w - 4, h - 4);

          ctx.restore();
        }
      }
    }

    function drawWaypointGate() {
      // Draw the upcoming waypoint as a faint vertical beacon
      const nextX = waypointX(waypointIndex);
      const px = sx(nextX);

      // Only if visible
      if (px < -50 || px > canvas.width + 50) return;

      const top = sy(TUNNEL_TOP);
      const bottom = sy(TUNNEL_BOTTOM);

      ctx.save();
      ctx.globalAlpha = 0.85;

      // Glow columns
      const grad = ctx.createLinearGradient(px, 0, px, canvas.height);
      grad.addColorStop(0, "rgba(0,0,0,0)");
      grad.addColorStop(0.25, "rgba(120, 220, 255, 0.15)");
      grad.addColorStop(0.50, "rgba(120, 220, 255, 0.22)");
      grad.addColorStop(0.75, "rgba(120, 220, 255, 0.15)");
      grad.addColorStop(1, "rgba(0,0,0,0)");

      ctx.fillStyle = grad;
      ctx.fillRect(px - 18, top, 36, bottom - top);

      ctx.strokeStyle = "rgba(120, 220, 255, 0.45)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(px, top);
      ctx.lineTo(px, bottom);
      ctx.stroke();

      ctx.restore();
    }

    function drawEnemyHealthBar(e, scaleFactor) {
      const barW = (e.radius * 2) * scaleFactor;
      const barH = 6;
      const pad = 2;

      const x = sx(e.x) - barW / 2;
      const y = sy(e.y) - (e.radius * scaleFactor) - 14;

      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.fillRect(x - pad, y - pad, barW + pad * 2, barH + pad * 2);

      const pct = e.maxHp > 0 ? (e.hp / e.maxHp) : 0;
      ctx.fillStyle = "rgba(90,255,120,0.9)";
      ctx.fillRect(x, y, barW * clamp(pct, 0, 1), barH);

      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = 1;
      ctx.strokeRect(x - pad, y - pad, barW + pad * 2, barH + pad * 2);
    }

    function drawEntities() {
      const scaleFactor = canvas.width / VIRTUAL_WIDTH;

      // Bullets
      for (const b of bullets) {
        ctx.beginPath();
        ctx.arc(sx(b.x), sy(b.y), b.radius * scaleFactor, 0, Math.PI * 2);
        ctx.fillStyle = "#ffdd55";
        ctx.fill();
      }

      // Enemies (no visible hitbox circles)
      for (const e of enemies) {
        const rr = e.radius * scaleFactor;
        const ex = sx(e.x);
        const ey = sy(e.y);

        if (e.img && e.img.complete && e.img.naturalWidth > 0) {
          ctx.save();
          ctx.imageSmoothingEnabled = true;

          if (e.hitFlash > 0) {
            const t = clamp(e.hitFlash / 0.08, 0, 1);
            ctx.globalAlpha = lerp(1.0, 0.62, t);
          }

          ctx.drawImage(e.img, ex - rr, ey - rr, rr * 2, rr * 2);
          ctx.restore();
        } else {
          // fallback placeholder (still not a circle)
          ctx.save();
          ctx.fillStyle = "rgba(255, 80, 80, 0.85)";
          ctx.fillRect(ex - rr, ey - rr, rr * 2, rr * 2);
          ctx.restore();
        }

        drawEnemyHealthBar(e, scaleFactor);
      }

      // Player
      const pr = player.radius * scaleFactor;
      ctx.beginPath();
      ctx.arc(sx(player.x), sy(player.y), pr, 0, Math.PI * 2);
      ctx.fillStyle = (player.iFrames > 0) ? "rgba(85,170,255,0.75)" : "#55aaff";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#ffffff";
      ctx.stroke();

      // Gun direction
      const gunLen = player.radius + 12;
      const gx = player.x + Math.cos(player.angle) * gunLen;
      const gy = player.y + Math.sin(player.angle) * gunLen;

      ctx.beginPath();
      ctx.moveTo(sx(player.x), sy(player.y));
      ctx.lineTo(sx(gx), sy(gy));
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawBackPressureWarning() {
      // Visual cue if player is lagging behind camera
      const behind = camera.x - player.x;
      const t = clamp((behind - (BACK_SOFT_LIMIT - 120)) / 220, 0, 1);
      if (t <= 0) return;

      ctx.save();
      ctx.globalAlpha = 0.28 * t;

      // Red gradient on left side
      const grad = ctx.createLinearGradient(0, 0, canvas.width * 0.35, 0);
      grad.addColorStop(0, "rgba(255, 40, 40, 1)");
      grad.addColorStop(1, "rgba(255, 40, 40, 0)");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width * 0.35, canvas.height);

      ctx.restore();
    }

    function draw() {
      // World background
      drawGridTunnelFloor();

      // Obstacles + waypoint gate
      drawObstacles();
      drawWaypointGate();

      // Entities
      drawEntities();

      // Pressure warning
      drawBackPressureWarning();

      // Game over overlay
      if (isGameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.45)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    // ---------------------------
    // Boot + main loop
    // ---------------------------
    // Set initial camera to player
    camera.x = player.x + 240;
    camera.y = (TUNNEL_TOP + TUNNEL_BOTTOM) / 2;

    // Pre-generate initial segments and spawn first wave at waypoint 0 (ahead of start)
    ensureSegmentsAroundCamera();
    spawnWave(0);

    let lastTime = performance.now();

    function gameLoop(t) {
      const dt = clamp((t - lastTime) / 1000, 0, 0.05);
      lastTime = t;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
