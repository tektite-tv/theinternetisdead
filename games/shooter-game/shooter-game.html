<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Bananaman Shooter v1.54</title>
<style>
  html, body { margin:0; padding:0; background:black; overflow:hidden; color:#0f0; font-family:monospace; }
  canvas { display:block; }
  #overlay{
    position:absolute; top:10px; left:10px; font-size:14px; line-height:1.4; pointer-events:none;
    text-shadow:0 0 6px rgba(0,255,0,0.35);
   display:none; /* HUD hidden by default (toggle with /) */
  }


  #uiRoot{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
  .panel{
    pointer-events:auto;
    width:min(520px, 92vw);
    border:1px solid rgba(0,255,0,0.35);
    border-radius:14px;
    background: rgba(0,0,0,0.72);
    box-shadow: 0 0 28px rgba(0,255,0,0.08);
    padding: 18px 18px 16px;
    text-align:center;
  }
  .title{ font-size:26px; letter-spacing:1px; margin:4px 0 10px; }
  .subimg{
    width:120px; height:120px; display:block; margin:0 auto 10px;
    image-rendering:pixelated; filter: drop-shadow(0 0 8px rgba(0,255,0,0.18));
  }
  .btnRow{ display:flex; gap:10px; justify-content:center; margin-top:12px; flex-wrap:wrap; }
  button{
    font-family:monospace; color:#0f0; background:rgba(0,0,0,0.55);
    border:1px solid rgba(0,255,0,0.45);
    padding:10px 14px; border-radius:12px; cursor:pointer; min-width:160px;
  }
  button:hover{ background: rgba(0,255,0,0.08); }
  .smallBtn{ min-width:120px; padding:8px 12px; border-radius:10px; }
  .optionsGrid{ display:grid; grid-template-columns:1fr; gap:12px; text-align:left; margin-top:10px; }
  .optRow{ border:1px solid rgba(0,255,0,0.2); border-radius:12px; padding:10px 12px; background: rgba(0,0,0,0.35); }
  .optLabel{ display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; font-size:14px; }
  input[type="range"]{ width:100%; accent-color:#00ff66; }
  .hint{ opacity:0.8; font-size:12px; margin-top:10px; line-height:1.35; }

  /* OPTIONS MENU: keep it on-screen, scroll if needed */
  #optionsMenu.panel{ max-height:88vh; overflow:auto; }
  #optionsMenu .title{ font-size:22px; margin:2px 0 8px; }
  #optionsMenu .optionsGrid{ gap:8px; }
  #optionsMenu .optRow{ padding:8px 10px; }
  #optionsMenu .optLabel{ margin-bottom:6px; }
  #optionsMenu .hint{ margin-top:6px; line-height:1.25; }

  @media (max-height: 700px){
    #optionsMenu.panel{ padding:12px; }
    #optionsMenu .title{ font-size:20px; }
    #optionsMenu .optionsGrid{ gap:6px; }
    #optionsMenu .optRow{ padding:7px 9px; }
  }

  .statusLine{ margin-top:10px; font-size:12px; opacity:0.9; }

  /* =======================
     HUD Corner Slots (v1.54)
  ======================= */
  .cornerSlot{
    position:absolute;
    min-width:120px;
    height:86px;
    padding:8px 10px;
    border:2px solid rgba(0,255,0,0.55);
    border-radius:12px;
    background: rgba(0,0,0,0.55);
    box-shadow: 0 0 18px rgba(0,255,0,0.10);
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    gap:4px;
    pointer-events:none;
  }
  .cornerSlot .subtxt{
    font-family: "Courier New", monospace;
    font-size:12px;
    line-height:1;
    opacity:0.95;
    color:#0f0;
    text-align:center;
  }
  #livesSlot img{
    width:40px; height:40px;
    image-rendering:pixelated;
    filter: drop-shadow(0 0 8px rgba(0,255,0,0.20));
  }


  .livesButton{
    flex-direction:row;
    justify-content:center;
    gap:8px;
  }
  .livesLabel{
    font-family:"Courier New", monospace;
    font-size:12px;
    color:#00ff66;
    opacity:0.95;
    white-space:nowrap;
  }

  #deathOverlay{
    position:absolute;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background: rgba(255,0,0,0.22);
    pointer-events:auto;
  }
  #deathPanel{
    width:min(520px, 92vw);
    border:3px solid rgba(255,0,0,0.65);
    border-radius:16px;
    background: rgba(0,0,0,0.72);
    padding: 18px 18px 16px;
    text-align:center;
    box-shadow: 0 0 36px rgba(255,0,0,0.14);
  }
  #deathTitle{
    font-family:"Courier New", monospace;
    font-weight:900;
    font-size:56px;
    letter-spacing:2px;
    color:#ff4444;
    text-shadow: 0 0 10px rgba(255,0,0,0.25);
  }
  #btnRestart{
    margin-top:14px;
    font-family:"Courier New", monospace;
    font-size:20px;
    font-weight:800;
    color:#ffdddd;
    background: rgba(0,0,0,0.55);
    border:2px solid rgba(255,0,0,0.55);
    padding:10px 18px;
    border-radius:14px;
    cursor:pointer;
  }
  #btnRestart:hover{ background: rgba(255,0,0,0.10); }



  #pauseOverlay{
    position:absolute;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background: rgba(0,0,0,0.55);
    pointer-events:none;
    z-index: 90;
  }
  #pausePanel{
    width:min(520px, 92vw);
    border:3px solid rgba(0,255,0,0.65);
    border-radius:16px;
    background: rgba(0,0,0,0.72);
    padding: 18px 18px 16px;
    text-align:center;
    box-shadow: 0 0 36px rgba(0,255,0,0.14);
  }
  #pauseTitle{
    font-family:"Courier New", monospace;
    font-weight:900;
    font-size:56px;
    letter-spacing:2px;
    color:#00ff66;
    text-shadow: 0 0 10px rgba(0,255,0,0.25);
  }
  #pauseHint{
    margin-top:10px;
    font-family:monospace;
    font-size:14px;
    opacity:0.9;
    color:#b6ffcf;
  }


  /* v1.54: keep HUD off the menu and keep menu clickable */
  #uiRoot{ z-index: 50; }
  #deathOverlay{ z-index: 100; }
  #livesSlot{ display:none; }
  #powerupSlot{ display:none; }


/* Centered wave label (replaces old Stage/Waves HUD) */
#stageHud{
  position: absolute;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  font: bold 20px monospace;
  z-index: 50;
  text-shadow: 0 0 8px rgba(0,0,0,0.65);
  pointer-events: none;
}

</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="overlay"></div>

<div id="stageHud" style="
  position:absolute;
  top:10px;
  left:10px;
  font-family:monospace;
  font-size:14px;
  color:#00ff66;
  text-shadow:0 0 6px rgba(0,255,0,0.35);
  pointer-events:none;
  z-index:20;
"></div>


<div id="livesSlot" class="cornerSlot livesButton" style="left:14px; bottom:14px;">
  <span class="livesLabel">LIVES:</span>
  <img src="/media/images/gifs/bananarama.gif" alt="lives"/>
  <div id="livesText" class="subtxt">x3</div>
</div>

<div id="powerupSlot" class="cornerSlot" style="right:14px; bottom:14px; display:none;">
  <div id="powerupEmoji" style="font-size:34px; line-height:1;">üí•</div>
  <div id="powerupHint" class="subtxt">Press Q</div>
</div>

<div id="deathOverlay">
  <div id="deathPanel">
    <div id="deathTitle">YOU DIED</div>
    <button id="btnRestart">Restart</button>
  </div>
</div>


<div id="pauseOverlay">
  <div id="pausePanel">
    <div id="pauseTitle">PAUSED</div>
    <div id="pauseHint">Press ESC to resume</div>
    <button id="btnPauseQuit" style="
      margin-top:16px;
      font-family:monospace;
      font-size:18px;
      font-weight:800;
      color:#0f0;
      background: rgba(0,0,0,0.55);
      border:2px solid rgba(0,255,0,0.55);
      padding:10px 18px;
      border-radius:14px;
      cursor:pointer;
      pointer-events:auto;
    ">Quit to Menu</button>
  </div>
</div>


<div id="uiRoot">
  <div id="startMenu" class="panel">
    <div class="title">Bananaman Shooter <span style="font-size:14px; opacity:0.75;">(v1.54)</span></div>
    <img class="subimg" src="/media/images/gifs/bananarama.gif" alt="bananarama" />
    <div class="hint">Move: A/D or ‚¨Ö‚û° ¬∑ Aim: Mouse/Touch ¬∑ Shoot: Space/Click ¬∑ ESC: Menu ¬∑ HUD: /</div>
    <div class="btnRow">
      <button id="btnStart">Start Game</button>
      <button id="btnOptions">Options</button>
    </div>
    <div id="assetStatus" class="statusLine">Loading enemy images...</div>
  </div>

  <div id="optionsMenu" class="panel" style="display:none;">
    <div class="title">OPTIONS</div>

    
    <div class="optionsGrid">
      <div class="optRow">
        <div class="optLabel"><span>Starting Lives</span><span id="livesVal">3</span></div>
        <input id="livesSlider" type="range" min="0" max="20" value="3" step="1" />
      </div>

      <div class="optRow">
        <div class="optLabel"><span>Starting Hearts</span><span id="heartsVal">4</span></div>
        <input id="heartsSlider" type="range" min="1" max="12" value="4" step="1" />
        <div class="hint">Hearts = max hits per life. More hearts = smaller damage per hit.</div>
      </div>

      <div class="optRow">
        <div class="optLabel"><span>Starting Shields</span><span id="shieldsVal">0</span></div>
        <input id="shieldsSlider" type="range" min="0" max="10" value="0" step="1" />
        <div class="hint">Shields act like extra one-hit armor pips (üõ°Ô∏è) next to your hearts.</div>
      </div>

      <div class="optRow">
        <div class="optLabel"><span>Starting Bombs</span><span id="bombsVal">0</span></div>
        <input id="bombsSlider" type="range" min="0" max="20" value="0" step="1" />
      </div>

      <div class="optRow" style="gap:10px;">
        <label style="display:flex; align-items:center; gap:10px; font-size:14px; opacity:0.95; cursor:pointer;">
          <input id="infiniteToggle" type="checkbox" style="transform:scale(1.2);" />
          <span>Infinite (no damage, no resource consumption)</span>
        </label>
        <div class="hint">For testing, chaos, or avoiding consequences. Pick one.</div>
      
      <div class="optRow" style="gap:10px;">
        <label style="display:flex; align-items:center; gap:10px; font-size:14px; opacity:0.95; cursor:pointer;">
          <input id="bossModeCheckbox" type="checkbox" style="transform:scale(1.2);" />
          <span>Boss Mode (start on Wave 11)</span>
        </label>
        <div class="hint">Starts you on the Wave 11 boss fight for practice/testing.</div>
      </div>

</div>
    </div>

    <div class="btnRow" style="margin-top:14px;">
      <button id="btnBack" class="smallBtn">Back</button>
      <button id="btnApply" class="smallBtn">Apply</button>
    </div>
  </div>
</div>

<script>
/* ======================================================================
  PROJECT CHANGELOG / REMOVAL LOG
========================================================================
[REMOVAL LOG]

- 2025-12-17 | v1.54.1
  Fixed: Game not starting / enemy images not loading due to runtime error.
  Cause: resize() called resetStarfield() before starLayers const initialized (TDZ).
  Fix: Initialize starfield definitions before resize() runs; make resize() safe.

- 2025-12-17 | v1.54.3
  Undo: v1.54.2 "simplified demo" version (removed menus/options/combat/etc.).
  Reason: User requested undo; restored full game build.
  Added: Player size increase + enforced vertical padding between formation and player.
  Location: player sizing, spawnEnemies baseY, update() formation Y clamp.

- 2025-12-17 | v1.54.4
  Added: Responsive desktop spacing so enemy formation uses screen width better.
  Added: Hard top-of-screen clamp so enemies stay visible even after step-downs.
  Tweaked: Reduced enemy base size + breathing scale to prevent overlap on desktop.
  Tweaked: Formation edge detection uses predicted next position to avoid clipping.


- 2025-12-17 | v1.54
  Added: Galaga-like enemy descent (continuous downward pressure) + predictable wobble.
  Tweaked: Enemy formation clamped to ~top half of screen (prevents encroaching into player zone).
  Tweaked: Increased base enemy spacing (X/Y) for clearer separation.
  Added: Wave banner ("WAVE 1", "WAVE 2", etc.) shown on start and after wave clears.
  Tweaked: Difficulty scaling per wave (enemy horizontal speed, descent speed, step-down).


- 2025-12-17 | v1.54
  Added: Wave spawn scaling: Wave 1 = 1 enemy, then doubles each wave (capped).
  Tweaked: FUN MODE: more lives, slower enemy pressure, slower swoops, faster bullets, gentler scaling.
  Added: Dynamic formation packing: auto-cols/rows + auto enemy sizing to fit top-zone area.
  Kept: Galaga-style 'swoop' attackers: individual enemies break formation, dive toward the player, then return.
  Kept: Main formation stays in the top zone; only swoopers can enter player space.
  Tweaked: Player fire rate increases each wave (cooldown decreases).


- 2025-12-17 | v1.54
  Tweaked: Player bullets are slightly larger than enemy bullets (visual clarity).
  Added: Player bullets can collide with enemy bullets; both are deleted on contact (counter-shot mechanic).

- 2025-12-17 | v1.54
  Added: Always-on player health bar under the player.
  Changed: Health replaces lives. Each enemy hit drains 25% health (4 hits total).
  Added: On death, player explodes into violent pixel-dust particles and returns to menu.



- 2025-12-17 | v1.54
  Fix: Restored any accidentally removed gameplay systems while adding UI and powerups.
  Kept: 360¬∞ aim + orbit triangle, straight bullets, bullet-vs-bullet cancel, Galaga formation + swoops, wave sizing 1/2/4/6/..., HUD toggle, menus/options.
  Added: Lives box (bottom-left), powerup slot with 'Press Q', YOU DIED overlay + Restart reset, UFO 25% wave spawn with 3-hit color cycle + fade granting üí•, Q bomb drop (+ flash then AoE + knockback), health bar (4 hits per life), pixel-dust death.
- 2025-12-19 | v1.54
  Changed: üí• bomb is now a short-range shot (spawns ahead of player in aim direction).
  Changed: Bomb detonates immediately on first enemy contact and can multi-kill enemies in the blast radius.

- 2025-12-19 | v1.54
  Added: Bomb-killing a dragon.gif enemy grants a one-time +25% "armor" pip next to the hearts HUD.
  Behavior: The armor absorbs the next hit (any damage) and then flips to ‚ùå briefly.

====================================================================== */


/* =======================
   Paths (EDIT IF NEEDED)
======================= */
const GIF_BASE = "/media/images/gifs/";
const AUDIO_HIT = "/media/audio/hitmarker.mp3";
const AUDIO_OOF = "/media/audio/oof.mp3";


/* =======================
   Audio
======================= */
const AUDIO_BG_MUSIC = "/media/audio/spaceinvaders.mp3";
const AUDIO_DEATH_YELL = "/media/audio/link-yell.mp3";

// Background music (loops). We start it on the first user interaction (autoplay rules).
const musicBg = new Audio(AUDIO_BG_MUSIC);
musicBg.loop = true;
musicBg.preload = "auto";
musicBg.volume = 0.6;

// Death yell (plays once when GAME OVER screen appears)
const sfxDeath = new Audio(AUDIO_DEATH_YELL);
sfxDeath.preload = "auto";
sfxDeath.volume = 0.9;

// Global mute toggle (M key)
let audioMuted = false;

function applyMuteState(){
  const m = !!audioMuted;
  musicBg.muted = m;
  sfxDeath.muted = m;
  sfxHit.muted = m;
  sfxOof.muted = m;
}

function tryPlayWithRetry(audioEl, retries=20, delayMs=80){
  if (!audioEl || audioMuted) return;
  try{
    audioEl.muted = !!audioMuted;
  }catch(e){}
  try{
    const p = audioEl.play();
    if (p && typeof p.catch === "function"){
      p.catch(() => {
        // Some browsers reject play() briefly even when audio is "unlocked".
        // We retry a handful of times so the sound lands as soon as it's allowed.
        if (retries > 0){
          setTimeout(() => tryPlayWithRetry(audioEl, retries - 1, delayMs), delayMs);
        }
      });
    }
  }catch(e){
    if (retries > 0){
      setTimeout(() => tryPlayWithRetry(audioEl, retries - 1, delayMs), delayMs);
    }
  }
}

function ensureMusicPlaying(restart=false){
  // Start/resume looping background music immediately when gameplay begins.
  // "restart=true" forces it back to the beginning.
  try{
    if (restart){
      musicBg.currentTime = 0;
    }
    musicBg.loop = true;
  }catch(e){}
  if (audioMuted) return;
  try{
    // If already playing and not restarting, leave it alone.
    if (!restart && !musicBg.paused) return;
    musicBg.play().catch(()=>{});
  }catch(e){}
}

function stopMusic(){
  try{
    musicBg.pause();
    musicBg.currentTime = 0;
  }catch(e){}
}

function playDeathYell(){
  if (audioMuted) return;
  try{
    sfxDeath.currentTime = 0;
  }catch(e){}
  // Try immediately, then retry briefly to avoid "plays only after next keypress" behavior.
  tryPlayWithRetry(sfxDeath, 30, 60);
}

/* =======================
   Player Firing Tuning
======================= */
const BASE_PLAYER_FIRE_COOLDOWN = 0.26; // seconds (wave scaling reduces this)
const PLAYER_BULLET_SPEED  = 8.0; // pixels per frame-ish (magnitude); direction comes from aim

function getPlayerFireCooldown(){
  // v1.54: player shoots faster every wave (lower cooldown)
  return Math.max(0.14, BASE_PLAYER_FIRE_COOLDOWN * Math.pow(0.94, (wave-1)));
}

/* =======================
   Canvas + Globals
======================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const overlay = document.getElementById("overlay");
const livesSlot = document.getElementById("livesSlot");
const livesText = document.getElementById("livesText");
const powerupSlot = document.getElementById("powerupSlot");
const powerupHint = document.getElementById("powerupHint");
;
const deathOverlay = document.getElementById("deathOverlay");
const btnRestart = document.getElementById("btnRestart");

let hudVisible = false;

// =======================
// Pause (v1.54)
// - ESC toggles pause while playing.
// - Freezes gameplay updates and input-driven actions.
// =======================
const pauseOverlay = document.getElementById("pauseOverlay");
let isPaused = false;
const btnPauseQuit = document.getElementById("btnPauseQuit");
if (btnPauseQuit){
  btnPauseQuit.addEventListener("click", () => {
    // Unpause and return to start menu
    setPaused(false);
    stopMusic();
    showMenu();
  });
}

function setPaused(p){
  isPaused = !!p;
  if (pauseOverlay) pauseOverlay.style.display = isPaused ? "flex" : "none";

  // v1.54: pause ALSO pauses the looping music (resume continues from same timestamp)
  try{
    if (isPaused){
      if (!musicBg.paused) musicBg.pause();
    } else {
      // only resume if we're in gameplay and not muted
      if (gameState === STATE.PLAYING && !audioMuted) musicBg.play().catch(()=>{});
    }
  }catch(e){}

  // When pausing, clear held movement keys so you don't "drift" on resume.
  if (isPaused){
    for (const k in keys) keys[k] = false;
  }
}

function togglePause(){
  if (gameState !== STATE.PLAYING) return;
  if (isDead) return; // don't pause during death freeze/respawn
  if (deathOverlay && deathOverlay.style.display === "flex") return; // don't pause on GAME OVER
  setPaused(!isPaused);
}


// =======================
// Right-Click Shield (v1.54)
// - Hold RIGHT MOUSE to raise a neon rainbow shield ring.
// - Shield blocks/bounces enemy contact + enemy bullets.
// - Uses "shield HP" so bullets don't erase it instantly.
// - Shield persists while held; only drops on release or when HP is depleted.
// - 30s cooldown after releasing or after shield breaks.
// =======================
let shieldActive = false;
let shieldHolding = false;

// HP model (more sane than "3 hits" when bullets are flying)
let shieldHP = 0;
const SHIELD_HP_MAX = 120;             // "reasonable amount" of damage before it breaks
const SHIELD_BULLET_DMG = 6;           // bullets nibble, they don't annihilate
const SHIELD_COLLISION_DMG = 18;       // ramming the shield costs more
let shieldCooldown = 0;                // seconds remaining
const SHIELD_COOLDOWN_SECS = 30;
const SHIELD_RADIUS_MULT = 0.78;       // relative to player size

// If focus/pointer events get weird, don't insta-drop the shield.
// Give a short grace period before forcing it off.
let shieldHoldGrace = 0;
const SHIELD_HOLD_GRACE_SECS = 0.25;

function canActivateShield(){
  return (gameState === STATE.PLAYING && !isDead && shieldCooldown <= 0 && !shieldActive);
}
function startShield(){
  shieldActive = true;
  // v1.54: If you let go earlier, keep remaining HP for next time.
  // Only refill to full when it was fully broken (shieldHP == 0) and cooldown has expired.
  if (shieldHP <= 0) shieldHP = SHIELD_HP_MAX;
  shieldHoldGrace = SHIELD_HOLD_GRACE_SECS;
}
function stopShield(startCooldown=false){
  // v1.54: Releasing shield should NOT trigger cooldown and should NOT erase remaining HP.
  if (shieldActive){
    shieldActive = false;
    shieldHoldGrace = 0;
    if (startCooldown) shieldCooldown = SHIELD_COOLDOWN_SECS;
  }
}
function shieldApplyDamage(dmg){
  if (!shieldActive) return;
  shieldHP = Math.max(0, shieldHP - Math.max(0, dmg));
  if (shieldHP <= 0){
    // v1.54: Cooldown ONLY when the shield breaks.
    stopShield(false);
  }
}
 // v1.54.5: HUD hidden by default; toggle with / (Slash)

let time = 0;
let score = 0;
// v1.54: "Spectral Funk" tuning knob (because humans love naming sliders like they're mixtapes).
// 1000 = baseline. Higher = spicier enemies (faster patterns + smarter shots). Lower = chill mode.
const SPECTRAL_FUNK = 1000;
const FUNK = Math.max(0.25, Math.min(2.5, SPECTRAL_FUNK / 1000));

let lives = 0; // extra lives (decremented when health hits 0)
let frogKills = 0; // counts frog kills; every 3 frogs awards +1 life
let health = 1.0; // 0..1 (4 hits -> 0)
let MAX_HEARTS = 4; // v1.54: configurable hearts per life
let HIT_DAMAGE = 0.25; // 25% per hit (4 hearts = one life)

// =======================
// Dragon Bomb-Kill Armor (v1.54)
// - If a dragon.gif enemy is killed by the BOMB blast, grant a one-time +25% armor.
// - Armor absorbs the next hit, then turns into an ‚ùå briefly next to the hearts HUD.
// =======================
let bonusArmor = 0;              // 0 or 0.25
let bonusArmorBrokenT = 0;       // seconds remaining to show ‚ùå
let shieldPips = 0;            // v1.54: extra one-hit armor pips
let isDead = false;
let deathTimer = 0;
let deathGameOver = false;
let deathYellPlayed = false;
const deathParticles = [];


let wave = 1;
let firstBossSpawned = false; // track first boss size



function getStageInfo(wave){
  if (wave <= 10){
    return { stage: 1, start: 0, end: 10 };
  } else if (wave <= 20){
    return { stage: 2, start: 11, end: 20 };
  } else {
    return { stage: 3, start: 21, end: 30 };
  }
}


// v1.54: formation dimensions are dynamic per wave (wave 1 = 1 enemy, then doubles)
let formationCols = 1;
let formationRows = 1;
// v1.54: debug-only numbers shown in the HUD overlay
let ENEMY_COLS = formationCols;
let ENEMY_ROWS = formationRows;
// v1.54: wave banner (big text popup)
let waveBanner = { text:"", t:0, color:"#00ff66" };

function getWaveLabel(n){
  // Wave label rules:
  // - Waves 1-10: "Wave N"
  // - Wave 11: "Boss Mode" (red)
  // - Waves 12-21: "INSANITY WAVE: K" where K = n-11
  if (n === 11) return { text:"Boss Mode", color:"#ff3333" };
  if (n >= 12 && n <= 21) return { text:"INSANITY WAVE: " + (n - 11), color:"#ffffff" };
  return { text:"Wave " + n, color:"#ffffff" };
}

function showWaveBanner(n){
  const lab = getWaveLabel(n);
  waveBanner.text = lab.text;
  waveBanner.color = lab.color;
  waveBanner.t = 1.35;
}

const STATE = { MENU:"menu", OPTIONS:"options", PLAYING:"playing", WIN:"win" };
let gameState = STATE.MENU;
let gameWon = false;

// Powerup state (v1.54)
let ufo = null;
let bomb = null;
let bombsCount = 0;
let infiniteModeActive = false;


/* =======================
   Utility
======================= */
function rand(min, max){ return min + Math.random() * (max - min); }

function isDragonEnemy(e){
  return !!(e && e.img && e.img.src && e.img.src.toLowerCase().includes("dragon.gif"));
}

// =======================
// Enemy hit feedback (v1.54)
// - flash red briefly when damaged
// - fade out when killed (instead of instantly vanishing)
// NOTE: This only touches canvas drawing + enemy objects; it will not mess with menus.
// =======================
const ENEMY_HIT_FLASH_SECS = 0.12;   // how long the red flash lasts
const ENEMY_DEATH_FADE_SECS = 0.35;  // how long the death fade lasts

function enemyMarkHit(e){
  if (!e) return;
  e.hitFlash = ENEMY_HIT_FLASH_SECS;
}


function drawFloatingTexts(ctx){
  if (!window._floatTexts || window._floatTexts.length === 0) return;
  ctx.save();
  ctx.font = "16px monospace";
  ctx.textAlign = "center";
  for (let i = window._floatTexts.length - 1; i >= 0; i--){
    const f = window._floatTexts[i];
    f.t += (window._dt || 0.016);
    const a = Math.max(0, 1 - (f.t / f.ttl));
    const yy = f.y - (f.t * 28);
    ctx.globalAlpha = a;
    ctx.fillText(f.text, f.x, yy);
    if (f.t >= f.ttl) window._floatTexts.splice(i, 1);
  }
  ctx.restore();
}

function spawnFloatingText(x, y, text, ttl=0.9){
  // Lightweight popup text. Stored in particles array if available, otherwise ignored gracefully.
  if (!window._floatTexts) window._floatTexts = [];
  window._floatTexts.push({x, y, text, t:0, ttl});
}

function enemyKill(e, source){
  if (!e || e.dying) return;
  e.dying = true;
  e.fade = 1;
  e.fadeRate = 1 / ENEMY_DEATH_FADE_SECS;

  // Freeze where it died so the formation doesn't yoink it around while fading.
  e.lockX = e.x; e.lockY = e.y;
  e.lockW = e.w; e.lockH = e.h;
  e.swoop = null;

  // One-time kill side effects.
  if (!e._killAwarded){
    e._killAwarded = true;
    if (source === "bomb" && isDragonEnemy(e)) grantBonusArmor();

    if (e.isFrog){
      healPlayer(0.50);

      // Extra life system: every 3 frog kills, award +1 life.
      frogKills += 1;
      if (frogKills % 3 === 0){
        lives += 1;
        livesText.textContent = "x" + lives;
        // Optional tiny feedback burst (kept simple and non-breaking).
        if (typeof spawnFloatingText === 'function') spawnFloatingText(e.x, e.y - 18, "+1 LIFE", 0.85);
        if (typeof playSfx === 'function') playSfx(sfxHit);
      }
    }
score += 10;
    playSfx(sfxHit);
  }
}

function enemyApplyDamage(e, dmg, source){
  if (!e) return;
  enemyMarkHit(e);
  e.hp = (typeof e.hp === "number") ? e.hp : 1;
  e.hp -= Math.max(0, dmg|0);
  if (e.hp <= 0){
    enemyKill(e, source);
  }
}

function grantBonusArmor(){
  // Do not stack. Just refresh.
  bonusArmor = 0.25;
  bonusArmorBrokenT = 0;
}

function breakBonusArmor(){
  bonusArmor = 0;
  bonusArmorBrokenT = 1.8;
}

/* =======================
   UFO + Bomb Powerup (v1.54)
   - 25% chance to spawn at wave start
   - UFO takes 3 hits: red -> green -> blue -> fade
   - On fade, grants üí• item (Press Q)
   - Press Q drops a flashing + that explodes after 3 flashes (0.5s each)
======================= */

function shouldForceUFOForWave(w){
  // v1.54: Always spawn a UFO on key milestone waves.
  // v1.55: Wave 11 is now a boss wave, so don't force a UFO there.
  return (w === 21);
}

function trySpawnUFO(force=false){
  if (ufo) return; // only one at a time
  // v1.54: Force-spawn on wave 11 and 21 (or when explicitly forced).
  if (!force && !shouldForceUFOForWave(wave) && Math.random() > 0.25) return;

  // Spawn near top area, tiny and fast.
  ufo = {
    x: rand(30, canvas.width - 30),
    y: rand(40, 110),
    vx: rand(-420, 420) / 60, // px/frame-ish
    vy: rand(260, 520) / 60,
    r: 10,
    hits: 0,
    stage: 0, // 0 none, 1 red, 2 green, 3 blue
    fade: 0,
    strobeT: 0
  };

  // Ensure it's actually moving.
  if (Math.abs(ufo.vx) < 2) ufo.vx = (ufo.vx < 0 ? -2.5 : 2.5);
}

function ufoColorForStage(stage){
  if (stage === 1) return "rgba(255,60,60,1)";
  if (stage === 2) return "rgba(60,255,120,1)";
  if (stage === 3) return "rgba(80,140,255,1)";
  return null;
}

function updateUFO(dt){
  if (!ufo) return;

  // If fading, just fade out and then grant powerup.
  if (ufo.fade > 0){
    ufo.fade += dt;
    if (ufo.fade >= 0.55){
      ufo = null;
      bombsCount += 1;
      powerupSlot.style.display = "flex";
    }
    return;
  }

  // Move + bounce around the top half.
  ufo.x += ufo.vx;
  ufo.y += ufo.vy;

  const left = 16, right = canvas.width - 16, top = 30, bottom = canvas.height * 0.48;
  if (ufo.x < left){ ufo.x = left; ufo.vx *= -1; }
  if (ufo.x > right){ ufo.x = right; ufo.vx *= -1; }
  if (ufo.y < top){ ufo.y = top; ufo.vy *= -1; }
  if (ufo.y > bottom){ ufo.y = bottom; ufo.vy *= -1; }

  // "Avoid the player's movement toward it": if player is moving toward UFO, add a shove away.
  const movingLeft  = (keys["a"] || keys["arrowleft"]);
  const movingRight = (keys["d"] || keys["arrowright"]);
  const toward =
    (movingLeft  && player.x > ufo.x) ||
    (movingRight && player.x < ufo.x);

  if (toward){
    const away = Math.sign(ufo.x - player.x) || (Math.random() < 0.5 ? -1 : 1);
    ufo.vx += away * (0.65 + 0.35 * FUNK);
    // clamp
    ufo.vx = Math.max(-9.5, Math.min(9.5, ufo.vx));
  }

  ufo.strobeT += dt;
}

function drawUFO(){
  if (!ufo) return;

  const strobe = Math.floor(time * 22) % 2 === 0;
  const baseFill = strobe ? "#fff" : "#000";
  const col = ufoColorForStage(ufo.stage);

  const alpha = (ufo.fade > 0) ? Math.max(0, 1 - (ufo.fade / 0.55)) : 1;

  ctx.save();
  ctx.globalAlpha = alpha;

  ctx.translate(ufo.x, ufo.y);

  // core strobe oval
  ctx.fillStyle = baseFill;
  ctx.beginPath();
  ctx.ellipse(0, 0, 14, 7, 0, 0, Math.PI * 2);
  ctx.fill();

  // colored "shield" ring for hit streak feedback
  if (col){
    ctx.strokeStyle = col;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.ellipse(0, 0, 16, 9, 0, 0, Math.PI * 2);
    ctx.stroke();
  }

  ctx.restore();
}

function dropBomb(){
  if (isPaused) return;
  if (!infiniteModeActive && bombsCount <= 0) return;
  if (bomb) return; // only one active

  bombsCount = 0;
  powerupSlot.style.display = "none";

  // v1.54: Bomb is now a short-range "shot" that travels a bit in the aim direction.
  // It detonates immediately on first enemy contact, and the explosion can wipe MULTIPLE enemies.
  const dx = Math.cos(aimAngleSmoothed);
  const dy = Math.sin(aimAngleSmoothed);

  const spawnDist = player.w * 0.55;
  const maxTravel = 140;          // "short distance ahead" (px)
  const speed = 900;              // px/sec while flying (feels snappy)

  bomb = {
    x: player.x + dx * spawnDist,
    y: player.y + dy * spawnDist,
    vx: dx * speed,
    vy: dy * speed,
    travel: 0,
    maxTravel,
    r: 12,

    mode: "flying",               // "flying" -> "armed" -> "exploding"
    flashT: 0,
    flashOn: true,

    exploding: false,
    rad: 0,
    alpha: 0.0
  };
}

function explodeBomb(){
  if (!bomb) return;
  bomb.exploding = true;
  bomb.mode = "exploding";
  bomb.rad = 0;
  bomb.alpha = 0.55;
}

function bombHitsEnemy(){
  if (!bomb || bomb.exploding) return false;
  // Check contact against all enemies (both while flying and while armed).
  for (let i = enemies.length - 1; i >= 0; i--){
    const e = enemies[i];
    if (e.dying) continue;
    const rx = e.x - e.w/2, ry = e.y - e.h/2;

    // Treat bomb as a circle hitting an enemy rect.
    if (circleRect(bomb.x, bomb.y, bomb.r, rx, ry, e.w, e.h)){
      // Detonate at the point of contact.
      explodeBomb();
      return true;
    }
  }
  return false;
}

function updateBomb(dt){
  if (!bomb) return;

  // Flash toggle (used for both flying + armed for readability)
  bomb.flashT += dt;
  if (bomb.flashT >= 0.12){
    bomb.flashT -= 0.12;
    bomb.flashOn = !bomb.flashOn;
  }

  if (!bomb.exploding){
    if (bomb.mode === "flying"){
      // Move forward for a short distance.
      const stepX = bomb.vx * dt;
      const stepY = bomb.vy * dt;

      bomb.x += stepX;
      bomb.y += stepY;

      bomb.travel += Math.hypot(stepX, stepY);

      // If it hits an enemy while flying, detonate instantly.
      if (bombHitsEnemy()) return;

      // After maxTravel, stop and become an "armed mine" that detonates on contact.
      if (bomb.travel >= bomb.maxTravel){
        bomb.mode = "armed";
        bomb.vx = 0;
        bomb.vy = 0;
      }
    } else if (bomb.mode === "armed"){
      // Stationary: detonate on first enemy contact.
      bombHitsEnemy();
    }
  } else {
    // expand shockwave
    bomb.rad += (560 + 220 * FUNK) * dt;
    bomb.alpha = Math.max(0, bomb.alpha - dt * 0.60);

    // Apply damage + knockback ONCE at the start of explosion
    if (!bomb.didDamage){
      bomb.didDamage = true;

      // Radius: 1.7 enemy widths (use average current enemy size or fallback)
      const enemySize = enemies.length ? enemies.reduce((s,e)=>s+e.size,0)/enemies.length : 44;
      const radius = enemySize * 1.7;

      // v1.54: multi-kill blast. Also supports future "hp > 1" enemies by dealing damage instead of auto-delete.
      const BOMB_DAMAGE = 2;

      for (let i = enemies.length - 1; i >= 0; i--){
        const e = enemies[i];
        if (e.dying) continue;
        const dx = e.x - bomb.x;
        const dy = e.y - bomb.y;
        const d2 = dx*dx + dy*dy;

        if (d2 <= radius*radius){
          // damage/kill (flash red, then fade out if killed)
          enemyApplyDamage(e, BOMB_DAMAGE, "bomb");
        } else {
          // knockback ring: if within 2.2x radius, shove outward a bit (keeps it fun)
          const r2 = (radius * 2.2);
          if (d2 <= r2*r2){
            const d = Math.max(1, Math.sqrt(d2));
            const push = (radius * 0.55) / d;
            e.col += (dx / d) * push * 0.02;
            e.row += (dy / d) * push * 0.02;
          }
        }
      }
    }

    if (bomb.alpha <= 0){
      bomb = null;
    }
  }
}

function drawBomb(){
  if (!bomb) return;

  if (!bomb.exploding){
    // v1.54: flying/armed bomb (flashing plus)
    ctx.save();
    ctx.translate(bomb.x, bomb.y);

    // Slightly different color when armed vs flying so you can read it at a glance.
    const isArmed = (bomb.mode === "armed");
    const onCol  = isArmed ? "rgba(255,80,80,0.95)" : "rgba(255,255,0,0.95)";
    const offCol = isArmed ? "rgba(255,255,255,0.70)" : "rgba(255,60,60,0.95)";

    ctx.fillStyle = bomb.flashOn ? onCol : offCol;
    ctx.fillRect(-4, -16, 8, 32);
    ctx.fillRect(-16, -4, 32, 8);

    // tiny outline circle so it reads even when the plus is edge-on
    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, bomb.r, 0, Math.PI * 2);
    ctx.stroke();

    ctx.restore();
  } else {
    // explosion circle
    ctx.save();
    ctx.globalAlpha = bomb.alpha;
    ctx.fillStyle = "rgba(255,0,0,0.20)";
    ctx.beginPath();
    ctx.arc(bomb.x, bomb.y, bomb.rad, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

/* =======================
   Parallax Starfield (safe init order)
======================= */
const starLayers = [
  { count: 180, baseSpeedY: 40,  parallaxX: 0.35, sizeMin: 1, sizeMax: 2 },
  { count: 120, baseSpeedY: 80,  parallaxX: 0.60, sizeMin: 1, sizeMax: 3 },
  { count: 70,  baseSpeedY: 140, parallaxX: 0.90, sizeMin: 2, sizeMax: 4 }
];

let stars = [];
let playerVxSmoothed = 0;
let starfieldReady = false;

function resetStarfield(){
  stars = starLayers.map(layer => {
    const arr = [];
    for (let i = 0; i < layer.count; i++){
      arr.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        s: rand(layer.sizeMin, layer.sizeMax),
        vyMul: rand(0.7, 1.3)
      });
    }
    return arr;
  });
  starfieldReady = true;
}

function updateStarfield(dt, keys, playerSpeed){
  if (!starfieldReady) return;

  let vxIntent = 0;
  if (gameState === STATE.PLAYING){
    if (keys["a"] || keys["arrowleft"])  vxIntent -= 1;
    if (keys["d"] || keys["arrowright"]) vxIntent += 1;
  } else {
    vxIntent = 0.15 * Math.sin(time * 0.6);
  }

  const targetVx = vxIntent * playerSpeed * 55;
  playerVxSmoothed += (targetVx - playerVxSmoothed) * Math.min(1, dt * 8);

  for (let li = 0; li < starLayers.length; li++){
    const layer = starLayers[li];
    const arr = stars[li];

    const driftX = -playerVxSmoothed * layer.parallaxX;
    const driftY = layer.baseSpeedY;

    for (const st of arr){
      st.x += driftX * dt;
      st.y += driftY * st.vyMul * dt;

      if (st.y > canvas.height + 10) st.y = -10;
      if (st.x < -10) st.x = canvas.width + 10;
      if (st.x > canvas.width + 10) st.x = -10;
    }
  }
}

function drawStarfield(){
  // v1.54: Stage 2+ visual shift (wave >= 11)
  const isStage2Plus = (gameState === STATE.PLAYING && wave >= 11);

  // Background
  ctx.fillStyle = isStage2Plus ? "#300" : "#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  if (!starfieldReady) return;

  for (let li = 0; li < starLayers.length; li++){
    const arr = stars[li];
    const alpha = li === 0 ? 0.35 : (li === 1 ? 0.55 : 0.85);

    // v1.54: Keep stars white for maximum contrast (even in Stage 2+)
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;

    for (const st of arr){
      ctx.fillRect(st.x, st.y, st.s, st.s);
    }
  }
}

/* =======================
   Resize
======================= */
function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // v1.54.3+: only bottom-anchor in menus; gameplay keeps spawn position
  if (gameState !== STATE.PLAYING){
    player.y = getPlayerAlignedY();
  }

  resetStarfield();
}
window.addEventListener("resize", resize);

/* =======================
   HUD/Player Alignment
   - Keep the bottom of the player aligned to the top of the hearts HUD (DOM element),
     regardless of fullscreen, browser chrome, or embedding under a site banner.
======================= */
function getHeartsTopInCanvas(){
  const heartsEl = document.getElementById("heartsHud");
  if (!heartsEl) return canvas.height - 60;
  const hRect = heartsEl.getBoundingClientRect();
  const cRect = canvas.getBoundingClientRect();
  // Convert viewport pixels to canvas pixel space. This assumes 1:1 CSS sizing for the canvas.
  return (hRect.top - cRect.top);
}

function getPlayerAlignedY(gapPx = 6){
  const heartsTop = getHeartsTopInCanvas();
  // player.y is CENTER-based, so subtract half-height.
  let y = heartsTop - (player.h / 2) - gapPx;
  // Clamp to canvas bounds
  y = Math.max(player.h/2, Math.min(canvas.height - player.h/2, y));
  return y;
}

/* =======================
   Audio
======================= */
const sfxHit = new Audio(AUDIO_HIT);
const sfxOof = new Audio(AUDIO_OOF);
sfxHit.preload = "auto";
sfxOof.preload = "auto";
sfxHit.volume = 0.7;
sfxOof.volume = 0.8;

let audioUnlocked = false;
function unlockAudioOnce(){
  if (audioUnlocked) return;
  audioUnlocked = true;
  try{
    sfxHit.muted = true;
    sfxHit.play().then(() => { sfxHit.pause(); sfxHit.currentTime = 0; sfxHit.muted = false; }).catch(()=>{ sfxHit.muted = false; });

    sfxOof.muted = true;
    sfxOof.play().then(() => { sfxOof.pause(); sfxOof.currentTime = 0; sfxOof.muted = false; }).catch(()=>{ sfxOof.muted = false; });
  }catch(e){}

  // Prime music/death audio once the browser allows it.
  try{
    // Prime the death yell audio once the browser allows it.
    sfxDeath.muted = true;
    sfxDeath.play().then(()=>{ sfxDeath.pause(); sfxDeath.currentTime = 0; sfxDeath.muted = false; }).catch(()=>{ sfxDeath.muted = false; });
  }catch(e){}

  applyMuteState();
  ensureMusicPlaying();
}
function playSfx(a){
  if (audioMuted) return;
  try{
    const c = a.cloneNode();
    c.volume = a.volume;
    c.muted = !!audioMuted;
    c.play().catch(()=>{});
  }catch(e){}
}

/* =======================
   UI
======================= */
const uiRoot = document.getElementById("uiRoot");
const startMenu = document.getElementById("startMenu");
const optionsMenu = document.getElementById("optionsMenu");
const assetStatus = document.getElementById("assetStatus");

const btnStart = document.getElementById("btnStart");
const btnOptions = document.getElementById("btnOptions");
const btnBack = document.getElementById("btnBack");
const btnApply = document.getElementById("btnApply");

  // =======================
  // Start Options (v1.54)
  // =======================
  const livesSlider = document.getElementById("livesSlider");
  const heartsSlider = document.getElementById("heartsSlider");
  const shieldsSlider = document.getElementById("shieldsSlider");
  const bombsSlider = document.getElementById("bombsSlider");
  const infiniteToggle = document.getElementById("infiniteToggle");
  const bossModeCheckbox = document.getElementById("bossModeCheckbox");

  const livesVal = document.getElementById("livesVal");
  const heartsVal = document.getElementById("heartsVal");
  const shieldsVal = document.getElementById("shieldsVal");
  const bombsVal = document.getElementById("bombsVal");

  // Saved settings (persist for the session)
  let START_LIVES = 3;
  let START_HEARTS = 4;
  let START_SHIELDS = 0;
  let START_BOMBS = 0;
  let INFINITE_MODE = false;
  let START_WAVE = 1; // 1 normally, 11 when Boss Mode is enabled

  function syncStartOptionsLabels(){
    livesVal.textContent = livesSlider.value;
    heartsVal.textContent = heartsSlider.value;
    shieldsVal.textContent = shieldsSlider.value;
    bombsVal.textContent = bombsSlider.value;
  }

  [livesSlider, heartsSlider, shieldsSlider, bombsSlider].forEach(s => {
    s.addEventListener("input", syncStartOptionsLabels);
  });
  infiniteToggle.addEventListener("change", () => {});
  syncStartOptionsLabels();
function showMenu(){
  setPaused(false);
  deathYellPlayed = false;
  gameState = STATE.MENU;
  // v1.54: drop shield when entering menus
  shieldHolding = false;
  stopShield(false);

  deathOverlay.style.display = "none";
  // v1.54: HUD should not appear on the menu
  livesSlot.style.display = "none";
  powerupSlot.style.display = "none";

  startMenu.style.display = "block";
  optionsMenu.style.display = "none";
  uiRoot.style.display = "flex";
}

function restartRun(){
  setPaused(false);
  // Restart music immediately when restarting a run.
  ensureMusicPlaying(true);
  // v1.54: Hard reset from GAME OVER screen (full reset to beginning)
  deathOverlay.style.display = "none";
  bombsCount = 0;
  bomb = null;
  ufo = null;
  powerupSlot.style.display = "none";
  startGame();
}
function showOptions(){
  setPaused(false);
  gameState = STATE.OPTIONS;
    // v1.54: populate start options UI with saved settings
  livesSlider.value = START_LIVES;
  heartsSlider.value = START_HEARTS;
  shieldsSlider.value = START_SHIELDS;
  bombsSlider.value = START_BOMBS;
  infiniteToggle.checked = !!INFINITE_MODE;
  if (bossModeCheckbox) bossModeCheckbox.checked = (START_WAVE === 11);
  syncStartOptionsLabels();

// v1.54: drop shield when entering menus
  shieldHolding = false;
  stopShield(false);

  // v1.54: hide HUD in menus
  livesSlot.style.display = "none";
  powerupSlot.style.display = "none";

  startMenu.style.display = "none";
  optionsMenu.style.display = "block";
  uiRoot.style.display = "flex";
}
function startGame(){
  setPaused(false);
  unlockAudioOnce();
  // Start looping music exactly when the game starts.
  ensureMusicPlaying(true);
  gameState = STATE.PLAYING;
  uiRoot.style.display = "none";
  deathOverlay.style.display = "none";

  // v1.54: show HUD only in-game
  livesSlot.style.display = "flex";
  powerupSlot.style.display = "none";

  score = 0;
  frogKills = 0;

  // v1.54: Apply starting settings from OPTIONS menu
  infiniteModeActive = !!INFINITE_MODE;

  lives = Math.max(0, parseInt(START_LIVES, 10) || 0);
  livesText.textContent = "x" + lives;

  MAX_HEARTS = Math.max(1, parseInt(START_HEARTS, 10) || 4);
  HIT_DAMAGE = 1 / MAX_HEARTS;

  health = 1.0;

  // Spawn player mid-screen, above hearts HUD
  player.x = canvas.width / 2;
  player.y = getPlayerAlignedY();

  shieldPips = Math.max(0, parseInt(START_SHIELDS, 10) || 0);

  bombsCount = Math.max(0, parseInt(START_BOMBS, 10) || 0);
  powerupSlot.style.display = (infiniteModeActive || bombsCount > 0) ? "flex" : "none";
  if (powerupHint){
    if (infiniteModeActive) powerupHint.textContent = "Press Q (‚àû)";
    else powerupHint.textContent = "Press Q" + (bombsCount > 1 ? (" x" + bombsCount) : "");
  }

  health = 1.0;

  // Spawn player mid-screen, above hearts HUD
  player.x = canvas.width / 2;
  player.y = getPlayerAlignedY();
  bonusArmor = 0;
  bonusArmorBrokenT = 0;
  isDead = false;
  deathTimer = 0;
  deathGameOver = false;
  deathYellPlayed = false;
  deathParticles.length = 0;

  wave = START_WAVE;
  showWaveBanner(wave);
bullets.length = 0;
  enemyBullets.length = 0;
  fireCooldown = 0;

  bombsCount = 0;
  bomb = null;
  ufo = null;

  resetFormation();
  updateHearts();
spawnEnemies();
  trySpawnUFO();

  window.focus();
}

btnStart.addEventListener("click", startGame);
btnOptions.addEventListener("click", showOptions);
btnBack.addEventListener("click", showMenu);
btnApply.addEventListener("click", () => {
  // v1.54: Save start settings (lives/hearts/shields/bombs + infinite)
  START_LIVES = parseInt(livesSlider.value, 10);
  START_HEARTS = parseInt(heartsSlider.value, 10);
  START_SHIELDS = parseInt(shieldsSlider.value, 10);
  START_BOMBS = parseInt(bombsSlider.value, 10);
  INFINITE_MODE = !!infiniteToggle.checked;
  START_WAVE = (bossModeCheckbox && bossModeCheckbox.checked) ? 11 : 1;

  // Keep the UI labels in sync and return to the main menu.
  syncStartOptionsLabels();
  showMenu();
});

btnRestart.addEventListener("click", () => {
  restartRun();
});


function setAssetStatus(msg){ assetStatus.textContent = msg; }

/* =======================
   Player (v1.54.3 bigger)
======================= */
const playerImg = new Image();
playerImg.src = GIF_BASE + "bananarama.gif";

// v1.54.3 sizing + anchoring
const PLAYER_SIZE = 72;                 // was 48
const PLAYER_BOTTOM_MARGIN = 100;
const PLAYER_SPAWN_Y_FACTOR = 0.95; // middle-ish, above hearts HUD       // gives breathing room vs browser UI
const FORMATION_PLAYER_GAP = 160;       // v1.54: no longer enforced (kept for tuning/experiments)

const player = {
  x: 0,
  y: 0,
  w: PLAYER_SIZE,
  h: PLAYER_SIZE,
  speed: 6,
  invuln: 0
};

const keys = {};
let fireCooldown = 0;

/* =======================
   Aim (v1.54: 360¬∞ aim)
   - Mouse / touch sets an aim point.
   - We smooth the aim angle so the triangle feels less twitchy.
======================= */
let aimX = 0;
let aimY = 0;
let aimAngle = -Math.PI/2;
let aimAngleSmoothed = -Math.PI/2;

function normAngle(a){
  while (a > Math.PI) a -= Math.PI * 2;
  while (a < -Math.PI) a += Math.PI * 2;
  return a;
}

function setAimFromClient(clientX, clientY){
  const r = canvas.getBoundingClientRect();
  aimX = clientX - r.left;
  aimY = clientY - r.top;
  aimAngle = Math.atan2(aimY - player.y, aimX - player.x);
}

/* =======================
   Enemy Images from index.json
======================= */
let enemyImages = [];
let assetsReady = false;

const FALLBACK_URLS = [
  GIF_BASE + "frog.gif",
  GIF_BASE + "skeleton.gif",
  GIF_BASE + "dragon.gif",
  GIF_BASE + "firework.gif"
];

function preloadImages(urls){
  return new Promise((resolve) => {
    const imgs = [];
    let done = 0;
    if (!urls.length) resolve(imgs);

    urls.forEach((url) => {
      const img = new Image();
      img.onload = () => { done++; if (done === urls.length) resolve(imgs); };
      img.onerror = () => { done++; if (done === urls.length) resolve(imgs); };
      img.src = url;
      imgs.push(img);
    });
  });
}

async function loadEnemyImagesFromIndex(){
  try{
    setAssetStatus("Fetching index.json...");
    const res = await fetch(GIF_BASE + "index.json", { cache: "no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);

    const list = await res.json();
    if (!Array.isArray(list)) throw new Error("index.json not an array");

    const urls = list
      .filter(name => typeof name === "string" && name.toLowerCase().endsWith(".gif"))
      .map(name => GIF_BASE + name);

    if (!urls.length) throw new Error("No gifs in index.json");

    setAssetStatus(`Preloading ${urls.length} enemy images...`);
    let imgs = await preloadImages(urls);
    imgs = imgs.filter(img => img && img.naturalWidth > 0);
    if (!imgs.length) throw new Error("All enemy images failed to load");

    enemyImages = imgs;
    assetsReady = true;
    setAssetStatus(`Loaded ${enemyImages.length} enemy images ‚úÖ`);
  }catch(err){
    console.warn("Failed to load index.json enemy list:", err);
    setAssetStatus("Failed to load index.json. Using fallback images.");
    let imgs = await preloadImages(FALLBACK_URLS);
    enemyImages = imgs.filter(img => img && img.naturalWidth > 0);
    assetsReady = true;
  }
}
loadEnemyImagesFromIndex();

/* =======================
   Enemies + Formation Movement
======================= */
const BASE_SPACING_X = 105;

function getSpacingX(){
  // v1.54.4: Responsive horizontal spacing (desktop-friendly)
  const maxFormationWidth = canvas.width * 0.82;     // use most of the screen width
  const cols = Math.max(1, formationCols - 1);       // gaps between columns (dynamic per wave)
  return Math.min(120, Math.max(80, maxFormationWidth / cols));
}

function getSpacingY(){
  // v1.54: Responsive vertical spacing based on current wave formation size
  const maxFormationHeight = canvas.height * 0.38; // keep formation mostly in top zone
  const rows = Math.max(1, formationRows - 1);
  return Math.min(110, Math.max(45, maxFormationHeight / rows));
}


let enemies = [];

const formation = { xOffset:0, yOffset:0, dir:1, speed:1.2, stepDown:18, descentSpeed:12, boundsPad:40 };

function resetFormation(){
  formation.xOffset = 0;
  formation.yOffset = 0;
  formation.dir = 1;

  // v1.54: challenge/fun rebalance.
  // Horizontal sweep ramps, but capped so it stays readable.
  formation.speed = (0.95 + (wave-1) * 0.09) * FUNK;
  formation.speed = Math.min(2.2, formation.speed);

  // Step-down stays modest (most threat comes from swoops + bullets, not a doom-wall).
  formation.stepDown = 10 + Math.min(10, (wave-1) * 0.75);

  // Gentle downward pressure, capped hard to keep enemies mostly in the top zone.
  formation.descentSpeed = 3.5 + Math.min(10, (wave-1) * 1.25);
}

// v1.54: When an enemy dies, re-pack the remaining enemies into a tidy rectangle
// v1.54: Disabled by default because it turns the game into 'hold fire in one lane to win' mode.
// (no "missing tooth" gaps in the grid).
function compactEnemyGrid(){
  const count = enemies.length;
  if (!count){
    formationCols = 1;
    formationRows = 1;
    return;
  }

  // Mirror the spawn-time packing logic, but WITHOUT nuking the wave.
  const zoneW = canvas.width * 0.82;
  const zoneH = canvas.height * 0.38;

  const idealCols = Math.ceil(Math.sqrt(count * (zoneW / Math.max(1, zoneH))));
  formationCols = Math.max(1, Math.min(count, idealCols));
  formationRows = Math.max(1, Math.ceil(count / formationCols));

  // Re-assign slots in order so the formation closes ranks.
  for (let i = 0; i < enemies.length; i++){
    enemies[i].row = Math.floor(i / formationCols);
    enemies[i].col = i % formationCols;
  }
}


function randEnemyImg(){
  if (!enemyImages.length) return playerImg;
  return enemyImages[Math.floor(Math.random() * enemyImages.length)];
}

function spawnBossWave11(additive=false){
  // additive=true means "spawn the boss group on top of whatever enemies already exist"
  // (used for waves 12+). In that case we must NOT wipe the current wave's enemies or
  // clobber the formation grid settings.
  const prevEnemies = enemies;
  const prevCols = formationCols;
  const prevRows = formationRows;

  if (!additive){
    enemies = [];
    // Boss wave doesn't use the grid for gameplay, but other code expects these.
    formationCols = 1;
    formationRows = 1;
  }

  const baseY = 110; // keep boss in the top zone

  const zoneW = canvas.width * 0.82;
  const zoneH = canvas.height * 0.38;

  // Base "normal enemy" sizing in this zone.
  const baseSize = Math.max(26, Math.min(62, Math.min(zoneW/12, zoneH/7)));

  // Boss: noticeably bigger than everything else (requested).
  const isFirstBoss = !firstBossSpawned;
  const bossSize = isFirstBoss
    ? Math.max(baseSize * 4.0, 130)   // big intro boss
    : Math.max(baseSize * 2.0, 65);   // smaller recurring boss
  firstBossSpawned = true;

  const bossImg = new Image();
  bossImg.src = GIF_BASE + "180px-NO_U_cycle.gif";

  // Shared HP for core + orbiters (requested).
  const BOSS_HP = isFirstBoss
    ? 9   // big first boss = 3x hits
    : 1;  // small recurring bosses = 1 hit

  // Core boss: uses normal enemy damage system, but has more HP.
  const boss = {
    row:0, col:0, baseY,
    img: bossImg,
    isFrog:false,
    size: bossSize,
    hp: BOSS_HP,
    hitFlash:0,
    dying:false,
    fade:1,
    fadeRate:0,
    lockX:0, lockY:0, lockW:0, lockH:0,
    _killAwarded:false,
    x: canvas.width/2, y: baseY + 40, w:0, h:0,
    fx:0, fy:0,
    swoop:null,
    swoopCooldown: 9999,
    // Boss-wave behaviour flags/state
    isBossCore:true,
    bossWave:true,
    // Sporadic movement
    mx: canvas.width/2,
    my: baseY + 40,
    tx: canvas.width/2,
    ty: baseY + 40,
    moveTimer: 0,
    moveSpeed: 220,
    dashChance: 0.22,
    // Orbiting shield ring
    orbitAngle: 0,
    orbitSpeed: 1.7,
    orbitRadius: Math.max(52, bossSize * 0.62),
    shieldsAlive: 4
  };
  enemies.push(boss);

  // Shields: 4 copies of the same GIF orbiting around the boss.
  // They do NOT move independently; their x/y is forced each frame.
  const shieldSize = Math.max(baseSize * 1.25, 44);

  for (let i = 0; i < 4; i++){
    const shield = {
      row:0, col:0, baseY,
      img: bossImg,
      isFrog:false,
      size: shieldSize,
      hp: BOSS_HP,
      hitFlash:0,
      dying:false,
      fade:1,
      fadeRate:0,
      lockX:0, lockY:0, lockW:0, lockH:0,
      _killAwarded:false,
      x: boss.x, y: boss.y, w:0, h:0,
      fx:0, fy:0,
      swoop:null,
      swoopCooldown: 9999,
      isBossShield:true,
      bossWave:true,
      bossRef: boss,
      orbitIndex: i,
      // Shield shooting (predictable pattern)
      shootInterval: 1.2,
      shootTimer: i * 0.25
    };
    enemies.push(shield);
  }

  // Restore formation settings if we were additive.
  if (additive){
    formationCols = prevCols;
    formationRows = prevRows;
    // ensure we're still writing into the live enemies array reference
    enemies = prevEnemies;
  }
}


function spawnEnemies(){
  // v1.55+: Boss wave / additive boss waves
  if (wave === 11){
    spawnBossWave11(false);
    return;
  }

  enemies = [];
  const baseY = 80; // start higher (top zone)

  // v1.54: Wave sizing
  // Wave 1 spawns 1 enemy, then doubles each wave (2x previous).
  // We cap it to keep browsers from melting into a puddle.
  const MAX_WAVE_ENEMIES = 128;
// v1.54: Balanced wave sizing (requested):
// Wave 1: 1 enemy
// Wave 2: 2 enemies
// Wave 3: 4 enemies
// Wave 4+: add +2 each wave (6, 8, 10, ...)
function getEnemyCountForWave(w){
  if (w === 1) return 1;
  if (w === 2) return 2;
  if (w === 3) return 4;
  return 4 + (w - 3) * 2;
}
const count = Math.min(MAX_WAVE_ENEMIES, getEnemyCountForWave(wave));

  // v1.54: Dynamically pack the formation into the enemy zone by shrinking spacing + size.
  // Keep the "formation area" mostly in the top half.
  const zoneW = canvas.width * 0.82;
  const zoneH = canvas.height * 0.38;

  // Choose columns/rows to fit the count into the zone with a roughly square-ish grid.
  const idealCols = Math.ceil(Math.sqrt(count * (zoneW / Math.max(1, zoneH))));
  formationCols = Math.max(1, Math.min(count, idealCols));
  formationRows = Math.max(1, Math.ceil(count / formationCols));

  // Compute a size that fits nicely in each cell.
  const cellW = zoneW / formationCols;
  const cellH = zoneH / formationRows;
  const baseSize = Math.max(18, Math.min(56, Math.min(cellW, cellH) * 0.60));

  for (let i = 0; i < count; i++){
    const r = Math.floor(i / formationCols);
    const c = i % formationCols;

    const img = randEnemyImg();
    const isFrog = (img && img.src && img.src.toLowerCase().includes("frog.gif"));

    enemies.push({ row:r, col:c, baseY, img, isFrog, size:baseSize, hp:1, hitFlash:0, dying:false, fade:1, fadeRate:0, lockX:0, lockY:0, lockW:0, lockH:0, _killAwarded:false, x:0,y:0,w:0,h:0,
      fx:0, fy:0, // formation-space position (computed each frame)
      swoop:null, // {t,dur,phase, sx,sy, c1x,c1y, ex,ey}
      swoopCooldown: rand(1.0, 3.0) // seconds until eligible to swoop
    });
  }

  if (wave > 11){ spawnBossWave11(true); }
}

/* =======================
   Bullets
======================= */
const bullets = [];
const enemyBullets = [];

// v1.54 PERF GUARDRAILS:
// When bullet counts explode, the nested bullet-vs-bullet collision check can get expensive.
// Cap counts to keep the game smooth instead of freezing when chaos spikes.
const MAX_PLAYER_BULLETS = 90;
const MAX_ENEMY_BULLETS  = 140;

function shoot(){
  if (isPaused) return;
  // v1.54: cannot shoot while shield is active
  if (shieldActive) return;
  if (fireCooldown > 0) return;

  // v1.54: fire in the current aim direction (defaults upward if aim is unset)
  const dx = Math.cos(aimAngleSmoothed);
  const dy = Math.sin(aimAngleSmoothed);

  const spawnDist = (player.w * 0.42);
  // v1.54: cap bullets to prevent performance spikes
  if (bullets.length >= MAX_PLAYER_BULLETS){
    bullets.splice(0, bullets.length - MAX_PLAYER_BULLETS + 1);
  }
  bullets.push({

    x: player.x + dx * spawnDist,
    y: player.y + dy * spawnDist,
    vx: dx * PLAYER_BULLET_SPEED,
    vy: dy * PLAYER_BULLET_SPEED,
    r: 5
  });

  // v1.54: faster firing as waves increase
  fireCooldown = getPlayerFireCooldown();
}


let enemyShootTimer = 0;
function enemyTryShoot(dt){
  enemyShootTimer -= dt;
  if (enemyShootTimer > 0) return;

  const alive = enemies.length;

  // v1.54: shot pacing is less spammy early, more spicy later.
  // FUNK scales the aggression (1000 = baseline).
  const base = Math.max(
    0.16,
    (0.72 - wave*0.05 - Math.min(0.28, alive*0.0016)) / FUNK
  );

  // Add a tiny bit of variance so it doesn't feel like a metronome.
  enemyShootTimer = base * (0.85 + Math.random()*0.35);

  if (!enemies.length) return;

  // Shoot source selection.
  // Boss wave: shoot from the core so the orbiting shields stay 'shieldy' instead of acting like turrets.
  let e = null;
  if (wave === 11){
    e = enemies.find(x => x && x.isBossCore);
  }
  if (!e){
    // Classic arcade chaos: shoot from a random alive enemy.
    e = enemies[Math.floor(Math.random() * enemies.length)];
  }

  // Straight-line shots, but slightly aimed (vx is constant, so still a straight path).
  const dx = (player.x - e.x);
  const vx = Math.max(-3.2, Math.min(3.2, dx * 0.012)); // gentle lead
  const vy = (5.6 + wave*0.45) * FUNK;

  // v1.54: cap enemy bullets to prevent the counter-shot collision loop from going nuclear
  if (enemyBullets.length >= MAX_ENEMY_BULLETS){
    enemyBullets.splice(0, enemyBullets.length - MAX_ENEMY_BULLETS + 1);
  }
  enemyBullets.push({ x: e.x, y: e.y + e.h/2 + 6, vx, vy, r: 4 });
}


let swoopTimer = 0;

/*
  v1.54: Galaga-like swoop attackers.
  The *formation* is clamped to the top zone.
  Individual enemies can temporarily dive into the player zone ("swoop") and then return.
*/
function tryStartSwoop(dt){
  // tick per-enemy cooldowns
  for (const e of enemies){
    if (e.swoopCooldown > 0) e.swoopCooldown = Math.max(0, e.swoopCooldown - dt);
  }

  swoopTimer -= dt;
  if (swoopTimer > 0) return;

  // How often a swoop starts (faster on higher waves)
  const interval = Math.max(0.7, 2.0 - wave * 0.12);
  swoopTimer = interval;

  // Limit simultaneous swoopers so it stays readable.
  const maxSwoopers = Math.min(4, Math.max(1, Math.floor((1 + (wave-1) / 3) * (0.9 + 0.25*(FUNK-1)))));
  const currentlySwooping = enemies.reduce((n, e) => n + (e.swoop ? 1 : 0), 0);
  if (currentlySwooping >= maxSwoopers) return;

  // Pick an eligible enemy.
  const candidates = enemies.filter(e => !e.swoop && e.swoopCooldown <= 0);
  if (!candidates.length) return;

  const e = candidates[Math.floor(Math.random() * candidates.length)];

  // Start at current formation position (fx/fy computed in update loop).
  const sx = e.fx || e.x;
  const sy = e.fy || e.y;

  // End near player area, but not *below* the player.
  const endY = Math.min(canvas.height * 0.90, player.y - 40);
  const endX = Math.max(40, Math.min(canvas.width - 40, player.x + rand(-140, 140)));

  // Control point makes an arcing dive (sideways + down).
  const c1x = sx + rand(-220, 220);
  const c1y = sy + rand(140, 260);

  // Duration scales with wave (faster dives later).
  const dur = Math.max(1.1, 1.75 - wave * 0.03);

  e.swoop = { t:0, dur, phase:"down", sx, sy, c1x, c1y, ex:endX, ey:endY };
  e.swoopCooldown = Math.max(1.2, 3.0 - wave * 0.10); // wait before it can swoop agai

}


function quadBezier(t, a, b, c){
  // (1-t)^2 a + 2(1-t)t b + t^2 c
  const mt = 1 - t;
  return (mt*mt)*a + (2*mt*t)*b + (t*t)*c;
}


/* =======================
   Collision helpers
======================= */
function circleRect(cx, cy, cr, rx, ry, rw, rh){
  const testX = Math.max(rx, Math.min(cx, rx+rw));
  const testY = Math.max(ry, Math.min(cy, ry+rh));
  const dx = cx - testX;
  const dy = cy - testY;
  return (dx*dx + dy*dy) <= cr*cr;
}

function spawnPlayerDeath(isGameOver){
  // v1.54+: violent pixel-dust death
  isDead = true;
  deathGameOver = !!isGameOver;
  deathTimer = deathGameOver ? 1.2 : 0.85;

  const n = 160;
  for (let i = 0; i < n; i++){
    const ang = Math.random() * Math.PI * 2;
    const spd = 140 + Math.random() * 520;
    deathParticles.push({
      x: player.x + rand(-player.w*0.15, player.w*0.15),
      y: player.y + rand(-player.h*0.15, player.h*0.15),
      vx: Math.cos(ang) * spd,
      vy: Math.sin(ang) * spd,
      life: 0.55 + Math.random()*0.55,
      s: 1 + Math.random()*3
    });
  }
}

function damagePlayer(){
  if (player.invuln > 0 || isDead) return;

  // v1.54: Infinite mode means consequences are cancelled.
  if (infiniteModeActive){
    playSfx(sfxHit);
    player.invuln = 0.15;
    return;
  }

  // v1.54: shield pips absorb one hit (before health)
  if (shieldPips > 0){
    shieldPips = Math.max(0, shieldPips - 1);
    playSfx(sfxHit);
    player.invuln = 0.35;
    return;
  }

  // v1.54: bonus armor absorbs one hit
  if (bonusArmor > 0){
    breakBonusArmor();
    playSfx(sfxHit);
    player.invuln = 0.35;
    return;
  }

  // Each hit drains HIT_DAMAGE health (MAX_HEARTS hearts per life).
  health = Math.max(0, health - HIT_DAMAGE);
  player.invuln = 1.00;
  playSfx(sfxOof);

  if (health <= 0){
    // Lose a life and explode into pixel dust.
    lives = Math.max(0, lives - 1);
    spawnPlayerDeath(lives <= 0);
  }
}

/* =======================
   Input
======================= */

// Prevent right-click context menu so holding RMB can be used for shield.
window.addEventListener("contextmenu", (e) => {
  if (e.target === canvas) e.preventDefault();
}, { passive:false });


function toggleFullscreen(){
  const elem = document.documentElement;
  if (!document.fullscreenElement){
    if (elem.requestFullscreen) elem.requestFullscreen();
  } else {
    if (document.exitFullscreen) document.exitFullscreen();
  }
}

window.addEventListener("keydown", (e) => {
  unlockAudioOnce();
  if (e.code === "Space") e.preventDefault();

  // v1.54.5: HUD toggle (Slash key) - hidden by default
  if (e.code === "Slash"){
    hudVisible = !hudVisible;
    overlay.style.display = hudVisible ? "block" : "none";
  }

  const k = e.key.toLowerCase();
  keys[k] = true;

  if (k === "m"){
    audioMuted = !audioMuted;
    applyMuteState();
    // If unmuting, try to resume background music.
    if (!audioMuted) ensureMusicPlaying();
  }

  if (e.code === "Space" && gameState === STATE.PLAYING) shoot();
  if (e.key === "f" || e.key === "F") toggleFullscreen();
  if ((e.key === "q" || e.key === "Q") && gameState === STATE.PLAYING) dropBomb();
  if (k === "escape"){
    // v1.54: ESC pauses/resumes instead of opening the menu
    togglePause();
  }
}, { passive:false });

window.addEventListener("keyup", (e) => { keys[e.key.toLowerCase()] = false; });

canvas.addEventListener("pointermove", (e) => {
  // v1.54: aim follows pointer (mouse or touch)
  setAimFromClient(e.clientX, e.clientY);
});

canvas.addEventListener("pointerdown", (e) => {
  unlockAudioOnce();
  // v1.54: clicking also aims and shoots
  setAimFromClient(e.clientX, e.clientY);

  // v1.54: RIGHT CLICK hold = shield
  // Note: pointer events use button 2 for right mouse.
  if (e.button === 2){
    e.preventDefault();
    shieldHolding = true;
    if (canActivateShield()) startShield();
    return;
  }

  if (gameState === STATE.PLAYING) shoot();
});

canvas.addEventListener("pointerup", (e) => {
  // Release RMB shield
  if (e.button === 2){
    shieldHolding = false;
    // v1.54: Releasing it just deactivates; cooldown only happens if it BREAKS.
    if (shieldActive) stopShield(false);
  }
});

/* =======================
   Update + Draw
======================= */
function update(dt){
  time += dt;

  if (bonusArmorBrokenT > 0) bonusArmorBrokenT = Math.max(0, bonusArmorBrokenT - dt);

  // starfield updates always
  updateStarfield(dt, keys, player.speed);

  // PAUSE_GUARD_v1_51: freeze gameplay updates while paused
  if (gameState === STATE.PLAYING && isPaused) return;

  if (gameState !== STATE.PLAYING) return;

  // v1.54: shield cooldown + hold logic
  if (shieldCooldown > 0) shieldCooldown = Math.max(0, shieldCooldown - dt);

  if (shieldActive){
    if (shieldHolding){
      shieldHoldGrace = SHIELD_HOLD_GRACE_SECS; // refresh grace while held
    } else {
      shieldHoldGrace = Math.max(0, shieldHoldGrace - dt);
      if (shieldHoldGrace <= 0){
        // v1.54: If RMB isn't held for a bit, drop shield WITHOUT cooldown (HP is saved).
        stopShield(false);
      }
    }
  }

  // v1.54: death particles update + lockout
  if (isDead){
    deathTimer -= dt;

    // update particles
    for (let i = deathParticles.length - 1; i >= 0; i--){
      const p = deathParticles[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 520 * dt; // gravity
      if (p.life <= 0) deathParticles.splice(i, 1);
    }

    if (deathTimer <= 0){
      if (deathGameOver){
        // GAME OVER overlay
        deathOverlay.style.display = "flex";
        // v1.54: death yell fires exactly when YOU DIED appears
        stopMusic();
        playDeathYell();
        stopMusic();
      } else {
        // Respawn for next life (keep wave/enemies as-is)
        isDead = false;
        deathGameOver = false;
  deathYellPlayed = false;
        deathParticles.length = 0;
        health = 1.0;

  // Spawn player mid-screen, above hearts HUD
  player.x = canvas.width / 2;
  player.y = getPlayerAlignedY();
        player.invuln = 1.25;
      }
    }
    return; // freeze gameplay while dead
  }

  if (player.invuln > 0) player.invuln = Math.max(0, player.invuln - dt);
  if (fireCooldown > 0) fireCooldown = Math.max(0, fireCooldown - dt);

  if (waveBanner.t > 0) waveBanner.t = Math.max(0, waveBanner.t - dt);

  // player move
  if (keys["a"] || keys["arrowleft"]) player.x -= player.speed;
  if (keys["d"] || keys["arrowright"]) player.x += player.speed;
  player.x = Math.max(player.w/2, Math.min(canvas.width - player.w/2, player.x));

  // Keep player vertically aligned to the hearts HUD
  player.y = getPlayerAlignedY();

  // v1.54: smooth the aim angle (shortest-path wrap) for nicer feel
  const da = normAngle(aimAngle - aimAngleSmoothed);
  aimAngleSmoothed = normAngle(aimAngleSmoothed + da * Math.min(1, dt * 18));

  updateUFO(dt);
  updateBomb(dt);

  // formation movement bounds depend on breathing spacing
  const breath = Math.sin(time * 2) * 0.5 + 0.5;
  const spacingX = getSpacingX() * (1 + breath * 0.25);

  const formationWidth = (formationCols - 1) * spacingX;

  // v1.54.4: predict next X so we don't clip enemies on wider desktop layouts
  const nextXOffset = formation.xOffset + (formation.dir * formation.speed);

  const leftEdgeNext  = canvas.width/2 - formationWidth/2 + nextXOffset;
  const rightEdgeNext = canvas.width/2 + formationWidth/2 + nextXOffset;

  if (leftEdgeNext < formation.boundsPad){
    formation.dir = 1;
    formation.xOffset += 2;
    formation.yOffset += formation.stepDown;
  } else if (rightEdgeNext > canvas.width - formation.boundsPad){
    formation.dir = -1;
    formation.xOffset -= 2;
    formation.yOffset += formation.stepDown;
  } else {
    formation.xOffset = nextXOffset;
  }

  // v1.54: always drift downward toward the player (Galaga pressure)
  formation.yOffset += formation.descentSpeed * dt;

  // update bullets
  for (let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    b.x += b.vx;
    b.y += b.vy;
    if (b.x < -80 || b.x > canvas.width + 80 || b.y < -80 || b.y > canvas.height + 80) bullets.splice(i, 1);
  }

  for (let i = enemyBullets.length - 1; i >= 0; i--){
    const b = enemyBullets[i];
    b.x += (b.vx || 0);
    b.y += b.vy;
    if (enemyBullets[i].y > canvas.height + 60) enemyBullets.splice(i, 1);
  }


  // v1.54: player bullet <-> enemy bullet collision (both vanish on contact)
  // This prevents bullet spam from feeling unfair and adds a satisfying "counter-shot" mechanic.
  for (let pi = bullets.length - 1; pi >= 0; pi--){
    const p = bullets[pi];
    for (let ei = enemyBullets.length - 1; ei >= 0; ei--){
      const e = enemyBullets[ei];
      const dx = p.x - e.x;
      const dy = p.y - e.y;
      const rr = (p.r + e.r);
      // v1.54: cheap early-outs to avoid expensive nested collision work when bullets are far apart
      if (dy > rr + 6 || dy < -rr - 6) continue;
      if (dx > rr + 6 || dx < -rr - 6) continue;
      if (dx*dx + dy*dy <= rr*rr){
        bullets.splice(pi, 1);
        enemyBullets.splice(ei, 1);
        break; // player bullet is gone, move to next one
      }
    }
  }

  // v1.54: attempt to launch swoop attackers
  // Boss wave uses its own movement, no swoops.
  if (wave !== 11) tryStartSwoop(dt);

  // compute enemy positions
  const spacingY = getSpacingY() * (1 + breath * 0.15);
  const formationHeight = (formationRows - 1) * spacingY;

  const startX = canvas.width/2 - formationWidth/2 + formation.xOffset;

  // v1.54.3: base spawn Y from each enemy, plus formation yOffset
  // then clamp so the formation bottom never gets too close to player
  let baseY = 80 + formation.yOffset;

// Keep enemies in the TOP half-ish of the screen.
// We still drift downward (Galaga pressure), but we *cap* the formation so it doesn't
// invade the player's space like it's paying rent down there.
const TOP_SAFE_MARGIN = 60;
const ENEMY_ZONE_MAX_Y = canvas.height * 0.48; // ~top half with a little buffer

// Clamp TOP
if (baseY < TOP_SAFE_MARGIN){
  formation.yOffset += (TOP_SAFE_MARGIN - baseY);
  baseY = TOP_SAFE_MARGIN;
}

// Clamp BOTTOM (based on full formation height)
const maxBaseY = ENEMY_ZONE_MAX_Y - formationHeight;
if (baseY > maxBaseY){
  // pull the whole formation back up
  formation.yOffset -= (baseY - maxBaseY);
  baseY = maxBaseY;
  // if the formation is too tall to fit, at least respect the top margin
  if (baseY < TOP_SAFE_MARGIN) baseY = TOP_SAFE_MARGIN;
}


// Boss wave controller: sporadic movement + orbiting shield ring.
// We compute boss.x/y directly, then force shields to orbit it.
let bossCore = enemies.find(x => x && x.isBossCore && !x.dying);
if (bossCore){
  if (bossCore){
    // Update sporadic target selection
    bossCore.moveTimer -= dt;

    const left = 70;
    const right = canvas.width - 70;
    const top = 70;
    const bottom = canvas.height * 0.36;

    if (bossCore.moveTimer <= 0){
      const dash = Math.random() < bossCore.dashChance;
      bossCore.tx = rand(left, right);
      bossCore.ty = rand(top, bottom);

      // Occasionally do a more dramatic "dash" by picking a farther target + higher speed.
      const baseSpeed = dash ? rand(520, 760) : rand(200, 340);
      bossCore.moveSpeed = baseSpeed * FUNK;

      // Short, snappy pacing feels more "alive"
      bossCore.moveTimer = dash ? rand(0.35, 0.6) : rand(0.55, 1.15);

      // Small randomness in orbit speed so it doesn't feel like a perfect clock
      bossCore.orbitSpeed = rand(1.35, 2.25);
    }

    // Move toward target (ease-ish)
    const dx = bossCore.tx - bossCore.mx;
    const dy = bossCore.ty - bossCore.my;
    const dist = Math.hypot(dx, dy) || 1;

    const step = Math.min(dist, bossCore.moveSpeed * dt);
    bossCore.mx += (dx / dist) * step;
    bossCore.my += (dy / dist) * step;

    // Apply to render positions
    bossCore.x = bossCore.mx;
    bossCore.y = bossCore.my;

    // Orbit angle
    bossCore.orbitAngle += dt * bossCore.orbitSpeed;

    // Shield firing pattern: each orbiter shoots on a fixed cadence with a fixed spread.
    // This makes a predictable 'screen sweep' pattern rather than random snipes.
    for (const s of enemies){
      if (!s || s.dying) continue;
      if (!s.isBossShield || s.bossRef !== bossCore) continue;
      if (typeof s.shootTimer !== 'number') s.shootTimer = 0;
      s.shootTimer -= dt;
      if (s.shootTimer <= 0){
        // Fixed vx by index: [-3, -1, 1, 3] (scaled), always downward.
        const vxMap = [-3, -1, 1, 3];
        const idx = Math.max(0, Math.min(3, (s.orbitIndex|0)));
        const vx = vxMap[idx] * 1.15 * FUNK;
        const vy = (6.4 + wave * 0.35) * FUNK;
        if (enemyBullets.length >= MAX_ENEMY_BULLETS){
          enemyBullets.splice(0, enemyBullets.length - MAX_ENEMY_BULLETS + 1);
        }
        enemyBullets.push({ x: s.x, y: s.y + s.h/2 + 6, vx, vy, r: 4 });
        const interval = (typeof s.shootInterval === 'number') ? s.shootInterval : 1.2;
        s.shootTimer += interval;
      }
    }

    // Count alive shields (for invulnerability logic)
    let alive = 0;
    for (const s of enemies){
      if (s && s.isBossShield && !s.dying) alive++;
    }
    bossCore.shieldsAlive = alive;
  }
} else {
  // If the boss core is gone (killed/fading), any remaining orbiters should NOT become
  // a second full-health "boss". Make them a 1-hit cleanup target.
  for (const s of enemies){
    if (!s || s.dying) continue;
    if (!s.isBossShield) continue;
    if (!s.bossRef || s.bossRef.dying || (typeof s.bossRef.hp === "number" && s.bossRef.hp <= 0)){
      s.hp = 1;
      s.isBossShield = false;
      s.isBossRemnant = true;
      s.bossWave = false;
      s.bossRef = null;
      // stop shield firing
      s.shootTimer = 9999;
      s.shootInterval = 9999;
    }
  }
}

  for (const e of enemies){
    if (assetsReady && enemyImages.length && e.img === playerImg) e.img = randEnemyImg();

    const scale = 1 + breath * 0.18;
    const size = e.size * scale;

    // v1.54: predictable formation wobble (non-random, just annoying)
    const wobbleAmpX = 6 + Math.min(14, wave * 1.2);
    const wobbleAmpY = 3 + Math.min(10, wave * 0.7);
    const wobbleX = Math.sin(time * (0.9 + wave*0.03) + e.row * 0.7) * wobbleAmpX;
    const wobbleY = Math.cos(time * (1.1 + wave*0.02) + e.col * 0.6) * wobbleAmpY;


e.fx = startX + e.col * spacingX + wobbleX;
e.fy = baseY + e.row * spacingY + wobbleY;

// Boss group: override formation positioning with custom behaviour.
if (bossCore){
  if (e.isBossCore){
    e.fx = e.x;
    e.fy = e.y;
  } else if (e.isBossShield && e.bossRef){
    // Orbit around the core at 90¬∞ intervals.
    const core = e.bossRef;
    const ang = (core.orbitAngle || 0) + (e.orbitIndex || 0) * (Math.PI / 2);
    const r = core.orbitRadius || 70;

    e.fx = core.x + Math.cos(ang) * r;
    e.fy = core.y + Math.sin(ang) * r;
  }
}

if (!e.swoop){
      // Normal formation tracking.
      e.x = e.fx;
      e.y = e.fy;
    } else {
      // Swoop motion: dive down along a bezier arc, then return back to formation.
      e.swoop.t += dt;
      const u = Math.min(1, e.swoop.t / e.swoop.dur);

      if (e.swoop.phase === "down"){
        e.x = quadBezier(u, e.swoop.sx, e.swoop.c1x, e.swoop.ex);
        e.y = quadBezier(u, e.swoop.sy, e.swoop.c1y, e.swoop.ey);

        if (u >= 1){
          // Switch to return phase.
          e.swoop.phase = "up";
          e.swoop.t = 0;
          e.swoop.dur = Math.max(0.75, e.swoop.dur * 0.85);

          // Return target is the *current* formation slot (fx/fy),
          // so the enemy rejoins smoothly even if the formation moved.
          e.swoop.sx = e.x;
          e.swoop.sy = e.y;
          e.swoop.ex = e.fx;
          e.swoop.ey = e.fy;
          // new control point arcs upward.
          e.swoop.c1x = e.x + rand(-200, 200);
          e.swoop.c1y = Math.max(60, e.y - rand(160, 260));
        }
      } else {
        // Return-to-formation arc
        e.x = quadBezier(u, e.swoop.sx, e.swoop.c1x, e.swoop.ex);
        e.y = quadBezier(u, e.swoop.sy, e.swoop.c1y, e.swoop.ey);

        if (u >= 1){
          // Back in formation.
          e.swoop = null;
          e.x = e.fx;
          e.y = e.fy;
        }
      }
    }

    e.w = size;
    e.h = size;
  }

  // bullet -> enemy collision
  for (let bi = bullets.length - 1; bi >= 0; bi--){
    const b = bullets[bi];
    // v1.54+: bullet -> UFO collision (3-hit color cycle, then fade + powerup)
    if (ufo && ufo.fade === 0){
      const dxU = b.x - ufo.x;
      const dyU = b.y - ufo.y;
      const rrU = (b.r + ufo.r);
      if (dxU*dxU + dyU*dyU <= rrU*rrU){
        bullets.splice(bi, 1);
        ufo.hits += 1;
        ufo.stage = Math.min(3, ufo.hits); // 1 red, 2 green, 3 blue
        if (ufo.hits >= 3){
          ufo.fade = 0.001; // start fade-out
        }
        playSfx(sfxHit);
        continue; // bullet consumed
      }
    }

    for (let ei = enemies.length - 1; ei >= 0; ei--){
      const e = enemies[ei];

const rx = e.x - e.w/2, ry = e.y - e.h/2;

if (e.dying) continue;

// Boss wave: the orbiting shields protect the core.
if (wave === 11 && e.isBossCore){
  // If any shield is still alive, the core ignores direct hits.
  const shieldsAlive = (e.shieldsAlive ?? enemies.reduce((n, s) => n + (s && s.isBossShield && !s.dying ? 1 : 0), 0));
  if (shieldsAlive > 0) continue;
}

if (circleRect(b.x, b.y, b.r, rx, ry, e.w, e.h)){
        enemyApplyDamage(e, 1, "bullet");
        // Bullet consumed on hit.
        bullets.splice(bi, 1);
        break;
      }
    }
  }

  // enemy bullet -> player collision
  const prx = player.x - player.w/2, pry = player.y - player.h/2;
  const shieldR = player.w * SHIELD_RADIUS_MULT;

  for (let i = enemyBullets.length - 1; i >= 0; i--){
    const b = enemyBullets[i];

    // v1.54: shield blocks bullets (counts as a "hit" on the shield)
    if (shieldActive){
      const dx = b.x - player.x;
      const dy = b.y - player.y;
      const rr = (shieldR + b.r);
      if (dx*dx + dy*dy <= rr*rr){
        enemyBullets.splice(i, 1);
        shieldApplyDamage(SHIELD_BULLET_DMG);
        continue;
      }
    }

    if (circleRect(b.x, b.y, b.r, prx, pry, player.w, player.h)){
      enemyBullets.splice(i, 1);
      damagePlayer();
    }
  }

  // enemy contact damage

  // v1.54: shield makes enemies bounce off the player (and consumes shield hits on impact)
  if (shieldActive){
    const shieldR = player.w * SHIELD_RADIUS_MULT;
    for (const e of enemies){
      const dx = e.x - player.x;
      const dy = e.y - player.y;
      // approximate enemy radius from its sprite size
      const er = Math.max(e.w, e.h) * 0.45;
      const rr = shieldR + er;
      const d2 = dx*dx + dy*dy;

      if (d2 <= rr*rr){
        const d = Math.max(1, Math.sqrt(d2));
        const nx = dx / d;
        const ny = dy / d;

        // Push enemy out to the ring boundary
        e.x = player.x + nx * (rr + 2);
        e.y = player.y + ny * (rr + 2);

        // If it's swooping, cancel its swoop so it doesn't keep clipping the shield.
        if (e.swoop){
          e.swoop = null;
        }

        // Nudge its formation slot slightly away so it doesn't immediately re-collide
        e.col += nx * 0.35;
        e.row += ny * 0.25;

        shieldApplyDamage(SHIELD_BULLET_DMG);
        // If shield died from this hit, stop bouncing for this frame.
        if (!shieldActive) break;
      }
    }
  }

  if (player.invuln <= 0){
    for (const e of enemies){
      const rx = e.x - e.w/2, ry = e.y - e.h/2;
      const overlap =
        prx < rx + e.w &&
        prx + player.w > rx &&
        pry < ry + e.h &&
        pry + player.h > ry;
      if (overlap){ damagePlayer(); break; }
    }
  }

  enemyTryShoot(dt);

  // Enemy hit flash + death fade timers (v1.54)
  for (let i = enemies.length - 1; i >= 0; i--){
    const e = enemies[i];

    // Hit flash timer
    if (e.hitFlash > 0){
      e.hitFlash = Math.max(0, e.hitFlash - dt);
    }

    // Death fade timer
    if (e.dying){
      // Keep the corpse where it died while fading out.
      if (typeof e.lockX === "number") e.x = e.lockX;
      if (typeof e.lockY === "number") e.y = e.lockY;
      if (typeof e.lockW === "number" && e.lockW > 0) e.w = e.lockW;
      if (typeof e.lockH === "number" && e.lockH > 0) e.h = e.lockH;

      const rate = (e.fadeRate && e.fadeRate > 0) ? e.fadeRate : (1 / ENEMY_DEATH_FADE_SECS);
      e.fade = Math.max(0, (typeof e.fade === "number" ? e.fade : 1) - dt * rate);

      if (e.fade <= 0){
        enemies.splice(i, 1);
      }
    }
  }


  // wave clear
  if (enemies.length === 0){
    // If player beat INSANITY WAVE: 10 (wave 21), show a win screen.
    if (wave === 21){
      gameWon = true;
      gameState = STATE.WIN;
      return;
    }

    wave += 1;
    showWaveBanner(wave);

    resetFormation();
    spawnEnemies();
    trySpawnUFO();
  }
}


function healPlayer(amount){
  // Heal up to 100%. Used by frog enemies.
  if (isDead) return;
  health = Math.min(1, health + amount);
}


function drawShieldRing(){
  if (!(gameState === STATE.PLAYING && shieldActive)) return;

  const r = player.w * SHIELD_RADIUS_MULT;
  const segments = 72;
  const baseHue = (time * 180) % 360; // shifting rainbow
  ctx.save();
  ctx.translate(player.x, player.y);

  // Outer glow
  ctx.lineWidth = 6;
  ctx.shadowBlur = 18;
  ctx.shadowColor = "rgba(0,255,255,0.35)";

  for (let i = 0; i < segments; i++){
    const a0 = (i / segments) * Math.PI * 2;
    const a1 = ((i + 1) / segments) * Math.PI * 2;
    const hue = (baseHue + i * (360 / segments)) % 360;
    ctx.strokeStyle = `hsla(${hue}, 100%, 60%, 0.95)`;
    ctx.beginPath();
    ctx.arc(0, 0, r, a0, a1);
    ctx.stroke();
  }

  // Small inner ring to make it feel "contained"
  ctx.shadowBlur = 10;
  ctx.lineWidth = 2.5;
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.beginPath();
  ctx.arc(0, 0, r - 6, 0, Math.PI*2);
  ctx.stroke();

  // Shield HP pips (more pips = more remaining shield)
  const PIPS = 6;
  const pipR = 3.2;
  const hpPerPip = SHIELD_HP_MAX / PIPS;
  const filled = Math.max(0, Math.min(PIPS, Math.ceil(shieldHP / hpPerPip)));

  for (let i = 0; i < PIPS; i++){
    const on = (i < filled);
    const px = (i - (PIPS-1)/2) * 10;
    const py = -r - 12;
    ctx.fillStyle = on ? "rgba(0,255,255,0.9)" : "rgba(0,255,255,0.18)";
    ctx.beginPath();
    ctx.arc(px, py, pipR, 0, Math.PI*2);
    ctx.fill();
  }

  ctx.restore();
}

function draw(){
  drawStarfield();

  // v1.54+: draw player death particles
  if (deathParticles.length){
    ctx.save();
    ctx.fillStyle = "#ff0";
    for (const p of deathParticles){
      ctx.globalAlpha = Math.max(0, Math.min(1, p.life));
      ctx.fillRect(p.x, p.y, p.s, p.s);
    }
    ctx.restore();
  }

  // v1.54: Wave banner popup
  if (gameState === STATE.PLAYING && waveBanner.t > 0){
    const p = Math.min(1, waveBanner.t / 1.35);
    const alpha = Math.min(1, 0.2 + p);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.font = "bold 48px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = waveBanner.color || "#00ff66";
    ctx.shadowColor = "rgba(0,255,102,0.35)";
    ctx.shadowBlur = 12;
    ctx.fillText(waveBanner.text, canvas.width/2, Math.max(60, canvas.height*0.12));
    ctx.restore();
  }

  // v1.54: death particles
  if (deathParticles.length){
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    for (const p of deathParticles){
      ctx.globalAlpha = Math.max(0, Math.min(1, p.life));
      ctx.fillRect(p.x - p.s/2, p.y - p.s/2, p.s, p.s);
    }
    ctx.restore();
  }

  // player flicker on invulnerability
  const flicker = player.invuln > 0 && Math.floor(time * 20) % 2 === 0;
  if (gameState === STATE.PLAYING){
    if (!flicker){
      ctx.drawImage(playerImg, player.x - player.w/2, player.y - player.h/2, player.w, player.h);
    }
  } else {
    ctx.drawImage(playerImg, player.x - player.w/2, player.y - player.h/2, player.w, player.h);
  }

    // v1.54: shield ring (RMB hold)
  drawShieldRing();

// v1.54: always-on health bar under the player (4 hits total)
  if (gameState === STATE.PLAYING){
    const barW = player.w;
    const barH = 7;
    const bx = player.x - barW/2;
    const by = player.y + player.h/2 + 10;

    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.fillRect(bx-1, by-1, barW+2, barH+2);

    ctx.fillStyle = "rgba(255,0,0,0.22)";
    ctx.fillRect(bx, by, barW, barH);

    ctx.fillStyle = "rgba(0,255,102,0.85)";
    ctx.fillRect(bx, by, barW * Math.max(0, Math.min(1, health)), barH);
    ctx.restore();
  }

// v1.54: aim indicator (yellow triangle orbiting around player, pointing where you're aiming)
if (gameState === STATE.PLAYING){
  const a = aimAngleSmoothed;
  const orbitR = player.w * 0.62;
  const tx = player.x + Math.cos(a) * orbitR;
  const ty = player.y + Math.sin(a) * orbitR;

  ctx.save();
  ctx.translate(tx, ty);
  ctx.rotate(a); // point outward
  ctx.fillStyle = "rgba(255,255,0,0.95)";
  ctx.beginPath();
  ctx.moveTo(16, 0);     // tip
  ctx.lineTo(-8, -7);    // base left
  ctx.lineTo(-8, 7);     // base right
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

  // UFO + bomb
  drawUFO();
  drawBomb();

  // enemies
  for (const e of enemies){
    // v1.54: frog enemies get a pulsing green aura ring
    if (e.isFrog){
      const pulse = 1 + 0.12 * Math.sin(time * 6.0);
      const r = Math.max(e.w, e.h) * 0.70 * pulse;
      ctx.save();
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "rgba(0,255,0,0.10)";
      ctx.strokeStyle = "rgba(0,255,0,0.45)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(e.x, e.y, r, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }
    // v1.54: enemy flash red on hit + fade out on death
    const ex = e.x - e.w/2, ey = e.y - e.h/2;
    const alpha = (e.dying ? Math.max(0, Math.min(1, e.fade)) : 1);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.drawImage(e.img, ex, ey, e.w, e.h);

    if (e.hitFlash > 0){
      const p = Math.max(0, Math.min(1, e.hitFlash / ENEMY_HIT_FLASH_SECS));
      ctx.globalCompositeOperation = "source-atop";
      ctx.fillStyle = `rgba(255,0,0,${0.28 * p})`;
      ctx.fillRect(ex, ey, e.w, e.h);
    }
    ctx.restore();
  }

  // bullets (player)
  // v1.54: draw as simple circles (no text/letter-like shapes)
  ctx.fillStyle = "#ff0";
  for (const b of bullets){
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fill();
  }

  // bullets (enemy)
  ctx.fillStyle = "rgba(255,0,0,0.95)";
  for (const b of enemyBullets){
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.fill();
  }
  // v1.54: keep debug grid numbers aligned with current formation
  ENEMY_ROWS = formationRows;
  ENEMY_COLS = formationCols;

  overlay.innerHTML =
    `Bananaman Shooter v1.54<br>` +
    `State: ${gameState}<br>` +
    `Score: ${score} | Health: ${Math.round(health*100)}% | Wave: ${wave}<br>` +
    `Shield: ${shieldActive ? (Math.round((shieldHP/SHIELD_HP_MAX)*100) + "%") : "off"} | CD: ${shieldCooldown.toFixed(1)}s<br>` +
    `Enemies: ${enemies.length} (${ENEMY_ROWS}x${ENEMY_COLS})<br>` +
    `Enemy pool: ${enemyImages.length || 0} images<br>` +
    `Bullets: ${bullets.length} | Enemy Bullets: ${enemyBullets.length}<br>` +
    `Fire CD: ${fireCooldown.toFixed(2)}s (target ${getPlayerFireCooldown().toFixed(2)}s)<br>` +
    `Player: ${player.w}px | Gap: ${FORMATION_PLAYER_GAP}px<br>` +
    `ESC: Menu`;

  // v1.54: corner HUD updates
  livesText.textContent = "x" + lives;
  powerupSlot.style.display = (infiniteModeActive || bombsCount > 0) ? "flex" : "none";
  if (gameState === STATE.PLAYING){
    const info = getStageInfo(wave);
    const clampedWave = Math.min(wave, info.end);
    const lab = getWaveLabel(wave);
    const stageHudEl = document.getElementById("stageHud");
    stageHudEl.textContent = lab.text;
    stageHudEl.style.color = lab.color;
  } else {
    document.getElementById("stageHud").textContent = "";
  }

}

let lastT = performance.now();

function updateHearts(){
  // v1.54: Hearts are configurable (MAX_HEARTS), and shields/bomb-armor show here too.
  const maxH = Math.max(1, MAX_HEARTS|0);
  const dmg = Math.max(0.0001, HIT_DAMAGE || (1/maxH));

  // Convert 0..1 health into "filled hearts" count.
  const hearts = Math.max(0, Math.min(maxH, Math.ceil(health / dmg)));

  const full = "‚ù§Ô∏è";
  const empty = "‚ùå";
  let out = "";
  for (let i = 0; i < maxH; i++){
    out += (i < hearts ? full : empty) + " ";
  }

  // v1.54: shield pips (one-hit armor) next to hearts
  if (shieldPips > 0){
    const show = Math.min(10, shieldPips);
    out += "  " + "üõ°Ô∏è ".repeat(show);
    if (shieldPips > 10) out += "x" + shieldPips + " ";
  }

  // v1.54: bonus armor indicator next to hearts
  let armorIcon = "";
  if (bonusArmor > 0) armorIcon = "üõ°Ô∏è";
  else if (bonusArmorBrokenT > 0) armorIcon = "‚ùå";
  if (armorIcon) out += "  " + armorIcon;

  // v1.54: infinite marker so you remember you're cheating
  if (infiniteModeActive) out += "  ‚ôæÔ∏è";

  const el = document.getElementById("heartsHud");
  if (el) el.textContent = out.trim();
}

function loop(t){
  const dt = Math.min(0.033, (t - lastT) / 1000);
  lastT = t;
  update(dt);
  draw();
  updateHearts();
  requestAnimationFrame(loop);
}

/* =======================
   Boot
======================= */
player.x = canvas.width / 2;
player.y = getPlayerAlignedY();

// v1.54: default aim straight up until the player moves the pointer
aimX = player.x;
aimY = player.y - 200;
aimAngle = -Math.PI/2;
aimAngleSmoothed = -Math.PI/2;

resetStarfield();
resize(); // also resets starfield + anchors player
showMenu();
powerupSlot.style.display = "none";
spawnEnemies();
updateHearts();

requestAnimationFrame(loop);</script>

<div id="heartsHud" style="
position:fixed;
bottom:12px;
left:50%;
transform:translateX(-50%);
font-size:28px;
letter-spacing:6px;
pointer-events:none;
z-index:9999;
">‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è</div>
</body>

</html>
