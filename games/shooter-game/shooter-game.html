<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Galaga-ish Clone v1.25</title>
<style>
  html, body { margin:0; padding:0; background:black; overflow:hidden; color:#0f0; font-family:monospace; }
  canvas { display:block; }
  #overlay{
    position:absolute; top:10px; left:10px; font-size:14px; line-height:1.4; pointer-events:none;
    text-shadow:0 0 6px rgba(0,255,0,0.35);
   display:none; /* HUD hidden by default (toggle with /) */
  }


  #uiRoot{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
  .panel{
    pointer-events:auto;
    width:min(520px, 92vw);
    border:1px solid rgba(0,255,0,0.35);
    border-radius:14px;
    background: rgba(0,0,0,0.72);
    box-shadow: 0 0 28px rgba(0,255,0,0.08);
    padding: 18px 18px 16px;
    text-align:center;
  }
  .title{ font-size:26px; letter-spacing:1px; margin:4px 0 10px; }
  .subimg{
    width:120px; height:120px; display:block; margin:0 auto 10px;
    image-rendering:pixelated; filter: drop-shadow(0 0 8px rgba(0,255,0,0.18));
  }
  .btnRow{ display:flex; gap:10px; justify-content:center; margin-top:12px; flex-wrap:wrap; }
  button{
    font-family:monospace; color:#0f0; background:rgba(0,0,0,0.55);
    border:1px solid rgba(0,255,0,0.45);
    padding:10px 14px; border-radius:12px; cursor:pointer; min-width:160px;
  }
  button:hover{ background: rgba(0,255,0,0.08); }
  .smallBtn{ min-width:120px; padding:8px 12px; border-radius:10px; }
  .optionsGrid{ display:grid; grid-template-columns:1fr; gap:12px; text-align:left; margin-top:10px; }
  .optRow{ border:1px solid rgba(0,255,0,0.2); border-radius:12px; padding:10px 12px; background: rgba(0,0,0,0.35); }
  .optLabel{ display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; font-size:14px; }
  input[type="range"]{ width:100%; accent-color:#00ff66; }
  .hint{ opacity:0.8; font-size:12px; margin-top:10px; line-height:1.35; }
  .statusLine{ margin-top:10px; font-size:12px; opacity:0.9; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="overlay"></div>

<div id="uiRoot">
  <div id="startMenu" class="panel">
    <div class="title">GALAGA-ISH CLONE</div>
    <img class="subimg" src="/media/images/gifs/bananarama.gif" alt="bananarama" />
    <div class="hint">Move: A/D or 猬 路 Aim: Mouse/Touch 路 Shoot: Space/Click 路 ESC: Menu 路 HUD: /</div>
    <div class="btnRow">
      <button id="btnStart">Start Game</button>
      <button id="btnOptions">Options</button>
    </div>
    <div id="assetStatus" class="statusLine">Loading enemy images...</div>
  </div>

  <div id="optionsMenu" class="panel" style="display:none;">
    <div class="title">OPTIONS</div>

    <div class="optionsGrid">
      <div class="optRow">
        <div class="optLabel"><span>Enemy Rows</span><span id="rowsVal">4</span></div>
        <input id="rowsSlider" type="range" min="1" max="10" value="4" step="1" />
      </div>

      <div class="optRow">
        <div class="optLabel"><span>Enemy Columns</span><span id="colsVal">6</span></div>
        <input id="colsSlider" type="range" min="1" max="14" value="6" step="1" />
      </div>

      <div class="optRow">
        <div class="optLabel"><span>Total Enemies</span><span id="totalVal">24</span></div>
        <div class="hint">Rows  Columns. More enemies = more chaos.</div>
      </div>
    </div>

    <div class="btnRow" style="margin-top:14px;">
      <button id="btnBack" class="smallBtn">Back</button>
      <button id="btnApply" class="smallBtn">Apply</button>
    </div>
  </div>
</div>

<script>
/* ======================================================================
  PROJECT CHANGELOG / REMOVAL LOG
========================================================================
[REMOVAL LOG]

- 2025-12-17 | v1.12.1
  Fixed: Game not starting / enemy images not loading due to runtime error.
  Cause: resize() called resetStarfield() before starLayers const initialized (TDZ).
  Fix: Initialize starfield definitions before resize() runs; make resize() safe.

- 2025-12-17 | v1.12.3
  Undo: v1.12.2 "simplified demo" version (removed menus/options/combat/etc.).
  Reason: User requested undo; restored full game build.
  Added: Player size increase + enforced vertical padding between formation and player.
  Location: player sizing, spawnEnemies baseY, update() formation Y clamp.

- 2025-12-17 | v1.12.4
  Added: Responsive desktop spacing so enemy formation uses screen width better.
  Added: Hard top-of-screen clamp so enemies stay visible even after step-downs.
  Tweaked: Reduced enemy base size + breathing scale to prevent overlap on desktop.
  Tweaked: Formation edge detection uses predicted next position to avoid clipping.


- 2025-12-17 | v1.14
  Added: Galaga-like enemy descent (continuous downward pressure) + predictable wobble.
  Tweaked: Enemy formation clamped to ~top half of screen (prevents encroaching into player zone).
  Tweaked: Increased base enemy spacing (X/Y) for clearer separation.
  Added: Wave banner ("WAVE 1", "WAVE 2", etc.) shown on start and after wave clears.
  Tweaked: Difficulty scaling per wave (enemy horizontal speed, descent speed, step-down).


- 2025-12-17 | v1.17
  Added: Wave spawn scaling: Wave 1 = 1 enemy, then doubles each wave (capped).
  Tweaked: FUN MODE: more lives, slower enemy pressure, slower swoops, faster bullets, gentler scaling.
  Added: Dynamic formation packing: auto-cols/rows + auto enemy sizing to fit top-zone area.
  Kept: Galaga-style 'swoop' attackers: individual enemies break formation, dive toward the player, then return.
  Kept: Main formation stays in the top zone; only swoopers can enter player space.
  Tweaked: Player fire rate increases each wave (cooldown decreases).


- 2025-12-17 | v1.23
  Tweaked: Player bullets are slightly larger than enemy bullets (visual clarity).
  Added: Player bullets can collide with enemy bullets; both are deleted on contact (counter-shot mechanic).

- 2025-12-17 | v1.25
  Added: Tiny strobing UFO bonus target has 25% chance to spawn at wave start.
  Added: UFO requires 3 consecutive hits (same UFO): turns red -> green -> blue, then fades away.
  Added: On UFO fade-out completion, grants a bomb power-up icon () in a bottom-right item slot.
====================================================================== */


/* =======================
   Paths (EDIT IF NEEDED)
======================= */
const GIF_BASE = "/media/images/gifs/";
const AUDIO_HIT = "/media/audio/hitmarker.mp3";
const AUDIO_OOF = "/media/audio/oof.mp3";

/* =======================
   Player Firing Tuning
======================= */
const BASE_PLAYER_FIRE_COOLDOWN = 0.26; // seconds (wave scaling reduces this)
const PLAYER_BULLET_SPEED  = 8.0; // pixels per frame-ish (magnitude); direction comes from aim

function getPlayerFireCooldown(){
  // v1.13: player shoots faster every wave (lower cooldown)
  return Math.max(0.14, BASE_PLAYER_FIRE_COOLDOWN * Math.pow(0.94, (wave-1)));
}

/* =======================
   Canvas + Globals
======================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const overlay = document.getElementById("overlay");

let hudVisible = false; // v1.12.5: HUD hidden by default; toggle with / (Slash)

let time = 0;
let score = 0;
// v1.22: "Spectral Funk" tuning knob (because humans love naming sliders like they're mixtapes).
// 1000 = baseline. Higher = spicier enemies (faster patterns + smarter shots). Lower = chill mode.
const SPECTRAL_FUNK = 1000;
const FUNK = Math.max(0.25, Math.min(2.5, SPECTRAL_FUNK / 1000));

let lives = 5;
let wave = 1;

// v1.17: formation dimensions are dynamic per wave (wave 1 = 1 enemy, then doubles)
let formationCols = 1;
let formationRows = 1;


// v1.13: wave banner (big text popup)
let waveBanner = { text:"", t:0 };
function showWaveBanner(n){ waveBanner.text = "WAVE " + n; waveBanner.t = 1.35; }

const STATE = { MENU:"menu", OPTIONS:"options", PLAYING:"playing" };
let gameState = STATE.MENU;

/* =======================
   Utility
======================= */
function rand(min, max){ return min + Math.random() * (max - min); }

// v1.24: Tiny fast UFO (25% chance on wave start).
// - Spawns near top, bounces quickly, strobes black/white.
// - No powerups in this build: shooting it grants score and removes it.
function trySpawnUFO(){
  // 25% chance at wave start
  if (Math.random() > 0.25) { ufo = null;
  hasBomb = false; return; }

  ufo = {
    x: rand(40, canvas.width - 40),
    y: 70,
    r: 10,
    vx: rand(-7.0, 7.0),
    vy: rand(5.0, 8.0),
    phase: 0,

    // v1.25: 3-hit "color ladder" (red -> green -> blue), then fade away and grant bomb power-up
    hits: 0,
    stage: 0,        // 0=strobe, 1=red, 2=green, 3=blue
    fading: false,
    alpha: 1,
    grantBombOnVanish: false
  };
}
  ufo = {
    x: rand(40, canvas.width - 40),
    y: 70,
    r: 10,
    vx: rand(-7.0, 7.0),
    vy: rand(5.0, 8.0),
    phase: 0
  };
}


/* =======================
   Parallax Starfield (safe init order)
======================= */
const starLayers = [
  { count: 180, baseSpeedY: 40,  parallaxX: 0.35, sizeMin: 1, sizeMax: 2 },
  { count: 120, baseSpeedY: 80,  parallaxX: 0.60, sizeMin: 1, sizeMax: 3 },
  { count: 70,  baseSpeedY: 140, parallaxX: 0.90, sizeMin: 2, sizeMax: 4 }
];

let stars = [];
let playerVxSmoothed = 0;
let starfieldReady = false;

function resetStarfield(){
  stars = starLayers.map(layer => {
    const arr = [];
    for (let i = 0; i < layer.count; i++){
      arr.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        s: rand(layer.sizeMin, layer.sizeMax),
        vyMul: rand(0.7, 1.3)
      });
    }
    return arr;
  });
  starfieldReady = true;
}

function updateStarfield(dt, keys, playerSpeed){
  if (!starfieldReady) return;

  let vxIntent = 0;
  if (gameState === STATE.PLAYING){
    if (keys["a"] || keys["arrowleft"])  vxIntent -= 1;
    if (keys["d"] || keys["arrowright"]) vxIntent += 1;
  } else {
    vxIntent = 0.15 * Math.sin(time * 0.6);
  }

  const targetVx = vxIntent * playerSpeed * 55;
  playerVxSmoothed += (targetVx - playerVxSmoothed) * Math.min(1, dt * 8);

  for (let li = 0; li < starLayers.length; li++){
    const layer = starLayers[li];
    const arr = stars[li];

    const driftX = -playerVxSmoothed * layer.parallaxX;
    const driftY = layer.baseSpeedY;

    for (const st of arr){
      st.x += driftX * dt;
      st.y += driftY * st.vyMul * dt;

      if (st.y > canvas.height + 10) st.y = -10;
      if (st.x < -10) st.x = canvas.width + 10;
      if (st.x > canvas.width + 10) st.x = -10;
    }
  }
}

function drawStarfield(){
  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  if (!starfieldReady) return;

  for (let li = 0; li < starLayers.length; li++){
    const arr = stars[li];
    const alpha = li === 0 ? 0.35 : (li === 1 ? 0.55 : 0.85);
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    for (const st of arr){
      ctx.fillRect(st.x, st.y, st.s, st.s);
    }
  }
}

/* =======================
   Resize
======================= */
function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // v1.12.3: keep player anchored nicely after resizes
  player.y = canvas.height - PLAYER_BOTTOM_MARGIN;

  resetStarfield();
}
window.addEventListener("resize", resize);

/* =======================
   Audio
======================= */
const sfxHit = new Audio(AUDIO_HIT);
const sfxOof = new Audio(AUDIO_OOF);
sfxHit.preload = "auto";
sfxOof.preload = "auto";
sfxHit.volume = 0.7;
sfxOof.volume = 0.8;

let audioUnlocked = false;
function unlockAudioOnce(){
  if (audioUnlocked) return;
  audioUnlocked = true;
  try{
    sfxHit.muted = true;
    sfxHit.play().then(() => { sfxHit.pause(); sfxHit.currentTime = 0; sfxHit.muted = false; }).catch(()=>{ sfxHit.muted = false; });

    sfxOof.muted = true;
    sfxOof.play().then(() => { sfxOof.pause(); sfxOof.currentTime = 0; sfxOof.muted = false; }).catch(()=>{ sfxOof.muted = false; });
  }catch(e){}
}
function playSfx(a){
  try{
    const c = a.cloneNode();
    c.volume = a.volume;
    c.play().catch(()=>{});
  }catch(e){}
}

/* =======================
   UI
======================= */
const uiRoot = document.getElementById("uiRoot");
const startMenu = document.getElementById("startMenu");
const optionsMenu = document.getElementById("optionsMenu");
const assetStatus = document.getElementById("assetStatus");

const btnStart = document.getElementById("btnStart");
const btnOptions = document.getElementById("btnOptions");
const btnBack = document.getElementById("btnBack");
const btnApply = document.getElementById("btnApply");

const rowsSlider = document.getElementById("rowsSlider");
const colsSlider = document.getElementById("colsSlider");
const rowsVal = document.getElementById("rowsVal");
const colsVal = document.getElementById("colsVal");
const totalVal = document.getElementById("totalVal");

let ENEMY_ROWS = parseInt(rowsSlider.value, 10);
let ENEMY_COLS = parseInt(colsSlider.value, 10);

function syncOptionsLabels(){
  rowsVal.textContent = rowsSlider.value;
  colsVal.textContent = colsSlider.value;

  // v1.17: sliders still display a grid size, but waves now control actual spawn count (1, 2, 4, 8...)
  const sliderTotal = (parseInt(rowsSlider.value,10) * parseInt(colsSlider.value,10));
  const waveTotal = Math.min(256, Math.pow(2, (wave - 1)));
  totalVal.textContent = sliderTotal.toString() + " | wave spawn: " + waveTotal.toString();
}
rowsSlider.addEventListener("input", syncOptionsLabels);
colsSlider.addEventListener("input", syncOptionsLabels);
syncOptionsLabels();

function showMenu(){
  gameState = STATE.MENU;
  startMenu.style.display = "block";
  optionsMenu.style.display = "none";
  uiRoot.style.display = "flex";
}
function showOptions(){
  gameState = STATE.OPTIONS;
  startMenu.style.display = "none";
  optionsMenu.style.display = "block";
  uiRoot.style.display = "flex";
}
function startGame(){
  unlockAudioOnce();
  gameState = STATE.PLAYING;
  uiRoot.style.display = "none";

  score = 0; lives = 3; wave = 1;
  showWaveBanner(1);
  bullets.length = 0;
  enemyBullets.length = 0;
  fireCooldown = 0;
  ufo = null;

  resetFormation();
  spawnEnemies();
  trySpawnUFO();
window.focus();
}

btnStart.addEventListener("click", startGame);
btnOptions.addEventListener("click", showOptions);
btnBack.addEventListener("click", showMenu);
btnApply.addEventListener("click", () => {
  ENEMY_ROWS = parseInt(rowsSlider.value, 10);
  ENEMY_COLS = parseInt(colsSlider.value, 10);
  resetFormation();
  spawnEnemies();
    trySpawnUFO();
});

function setAssetStatus(msg){ assetStatus.textContent = msg; }

/* =======================
   Player (v1.12.3 bigger)
======================= */
const playerImg = new Image();
playerImg.src = GIF_BASE + "bananarama.gif";

// v1.12.3 sizing + anchoring
const PLAYER_SIZE = 72;                 // was 48
const PLAYER_BOTTOM_MARGIN = 100;       // gives breathing room vs browser UI
const FORMATION_PLAYER_GAP = 160;       // v1.13: no longer enforced (kept for tuning/experiments)

const player = {
  x: 0,
  y: 0,
  w: PLAYER_SIZE,
  h: PLAYER_SIZE,
  speed: 6,
  invuln: 0
};

const keys = {};
let fireCooldown = 0;

/* =======================
   Aim (v1.19: 360掳 aim)
   - Mouse / touch sets an aim point.
   - We smooth the aim angle so the triangle feels less twitchy.
======================= */
let aimX = 0;
let aimY = 0;
let aimAngle = -Math.PI/2;
let aimAngleSmoothed = -Math.PI/2;

function normAngle(a){
  while (a > Math.PI) a -= Math.PI * 2;
  while (a < -Math.PI) a += Math.PI * 2;
  return a;
}

function setAimFromClient(clientX, clientY){
  const r = canvas.getBoundingClientRect();
  aimX = clientX - r.left;
  aimY = clientY - r.top;
  aimAngle = Math.atan2(aimY - player.y, aimX - player.x);
}

/* =======================
   Enemy Images from index.json
======================= */
let enemyImages = [];
let assetsReady = false;

const FALLBACK_URLS = [
  GIF_BASE + "frog.gif",
  GIF_BASE + "skeleton.gif",
  GIF_BASE + "dragon.gif",
  GIF_BASE + "firework.gif"
];

function preloadImages(urls){
  return new Promise((resolve) => {
    const imgs = [];
    let done = 0;
    if (!urls.length) resolve(imgs);

    urls.forEach((url) => {
      const img = new Image();
      img.onload = () => { done++; if (done === urls.length) resolve(imgs); };
      img.onerror = () => { done++; if (done === urls.length) resolve(imgs); };
      img.src = url;
      imgs.push(img);
    });
  });
}

async function loadEnemyImagesFromIndex(){
  try{
    setAssetStatus("Fetching index.json...");
    const res = await fetch(GIF_BASE + "index.json", { cache: "no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);

    const list = await res.json();
    if (!Array.isArray(list)) throw new Error("index.json not an array");

    const urls = list
      .filter(name => typeof name === "string" && name.toLowerCase().endsWith(".gif"))
      .map(name => GIF_BASE + name);

    if (!urls.length) throw new Error("No gifs in index.json");

    setAssetStatus(`Preloading ${urls.length} enemy images...`);
    let imgs = await preloadImages(urls);
    imgs = imgs.filter(img => img && img.naturalWidth > 0);
    if (!imgs.length) throw new Error("All enemy images failed to load");

    enemyImages = imgs;
    assetsReady = true;
    setAssetStatus(`Loaded ${enemyImages.length} enemy images `);
  }catch(err){
    console.warn("Failed to load index.json enemy list:", err);
    setAssetStatus("Failed to load index.json. Using fallback images.");
    let imgs = await preloadImages(FALLBACK_URLS);
    enemyImages = imgs.filter(img => img && img.naturalWidth > 0);
    assetsReady = true;
  }
}
loadEnemyImagesFromIndex();

/* =======================
   Enemies + Formation Movement
======================= */
const BASE_SPACING_X = 105;

function getSpacingX(){
  // v1.12.4: Responsive horizontal spacing (desktop-friendly)
  const maxFormationWidth = canvas.width * 0.82;     // use most of the screen width
  const cols = Math.max(1, formationCols - 1);       // gaps between columns (dynamic per wave)
  return Math.min(120, Math.max(80, maxFormationWidth / cols));
}

function getSpacingY(){
  // v1.17: Responsive vertical spacing based on current wave formation size
  const maxFormationHeight = canvas.height * 0.38; // keep formation mostly in top zone
  const rows = Math.max(1, formationRows - 1);
  return Math.min(110, Math.max(45, maxFormationHeight / rows));
}


let enemies = [];

const formation = { xOffset:0, yOffset:0, dir:1, speed:1.2, stepDown:18, descentSpeed:12, boundsPad:40 };

function resetFormation(){
  formation.xOffset = 0;
  formation.yOffset = 0;
  formation.dir = 1;

  // v1.22: challenge/fun rebalance.
  // Horizontal sweep ramps, but capped so it stays readable.
  formation.speed = (0.95 + (wave-1) * 0.09) * FUNK;
  formation.speed = Math.min(2.2, formation.speed);

  // Step-down stays modest (most threat comes from swoops + bullets, not a doom-wall).
  formation.stepDown = 10 + Math.min(10, (wave-1) * 0.75);

  // Gentle downward pressure, capped hard to keep enemies mostly in the top zone.
  formation.descentSpeed = 3.5 + Math.min(10, (wave-1) * 1.25);
}

// v1.19: When an enemy dies, re-pack the remaining enemies into a tidy rectangle
// v1.22: Disabled by default because it turns the game into 'hold fire in one lane to win' mode.
// (no "missing tooth" gaps in the grid).
function compactEnemyGrid(){
  const count = enemies.length;
  if (!count){
    formationCols = 1;
    formationRows = 1;
    return;
  }

  // Mirror the spawn-time packing logic, but WITHOUT nuking the wave.
  const zoneW = canvas.width * 0.82;
  const zoneH = canvas.height * 0.38;

  const idealCols = Math.ceil(Math.sqrt(count * (zoneW / Math.max(1, zoneH))));
  formationCols = Math.max(1, Math.min(count, idealCols));
  formationRows = Math.max(1, Math.ceil(count / formationCols));

  // Re-assign slots in order so the formation closes ranks.
  for (let i = 0; i < enemies.length; i++){
    enemies[i].row = Math.floor(i / formationCols);
    enemies[i].col = i % formationCols;
  }
}


function randEnemyImg(){
  if (!enemyImages.length) return playerImg;
  return enemyImages[Math.floor(Math.random() * enemyImages.length)];
}

function spawnEnemies(){
  enemies = [];
  const baseY = 80; // start higher (top zone)

  // v1.17: Wave sizing
  // Wave 1 spawns 1 enemy, then doubles each wave (2x previous).
  // We cap it to keep browsers from melting into a puddle.
  const MAX_WAVE_ENEMIES = 128;
// v1.19: Balanced wave sizing (requested):
// Wave 1: 1 enemy
// Wave 2: 2 enemies
// Wave 3: 4 enemies
// Wave 4+: add +2 each wave (6, 8, 10, ...)
function getEnemyCountForWave(w){
  if (w === 1) return 1;
  if (w === 2) return 2;
  if (w === 3) return 4;
  return 4 + (w - 3) * 2;
}
const count = Math.min(MAX_WAVE_ENEMIES, getEnemyCountForWave(wave));

  // v1.17: Dynamically pack the formation into the enemy zone by shrinking spacing + size.
  // Keep the "formation area" mostly in the top half.
  const zoneW = canvas.width * 0.82;
  const zoneH = canvas.height * 0.38;

  // Choose columns/rows to fit the count into the zone with a roughly square-ish grid.
  const idealCols = Math.ceil(Math.sqrt(count * (zoneW / Math.max(1, zoneH))));
  formationCols = Math.max(1, Math.min(count, idealCols));
  formationRows = Math.max(1, Math.ceil(count / formationCols));

  // Compute a size that fits nicely in each cell.
  const cellW = zoneW / formationCols;
  const cellH = zoneH / formationRows;
  const baseSize = Math.max(18, Math.min(56, Math.min(cellW, cellH) * 0.60));

  for (let i = 0; i < count; i++){
    const r = Math.floor(i / formationCols);
    const c = i % formationCols;

    enemies.push({ row:r, col:c, baseY, img: randEnemyImg(), size:baseSize, hp:1, x:0,y:0,w:0,h:0,
      fx:0, fy:0, // formation-space position (computed each frame)
      swoop:null, // {t,dur,phase, sx,sy, c1x,c1y, ex,ey}
      swoopCooldown: rand(1.0, 3.0) // seconds until eligible to swoop
    });
  }
}

/* =======================
   Bullets
======================= */
let ufo = null; // v1.25: optional bonus target (25% chance each wave)
let hasBomb = false; // v1.25: earned by destroying the UFO (3 hits), shows  in bottom-right slot

const bullets = [];
const enemyBullets = [];

function shoot(){
  if (fireCooldown > 0) return;

  // v1.19: fire in the current aim direction (defaults upward if aim is unset)
  const dx = Math.cos(aimAngleSmoothed);
  const dy = Math.sin(aimAngleSmoothed);

  const spawnDist = (player.w * 0.42);
  bullets.push({
    x: player.x + dx * spawnDist,
    y: player.y + dy * spawnDist,
    vx: dx * PLAYER_BULLET_SPEED,
    vy: dy * PLAYER_BULLET_SPEED,
    r: 5
  });

  // v1.13: faster firing as waves increase
  fireCooldown = getPlayerFireCooldown();
}


let enemyShootTimer = 0;
function enemyTryShoot(dt){
  enemyShootTimer -= dt;
  if (enemyShootTimer > 0) return;

  const alive = enemies.length;

  // v1.22: shot pacing is less spammy early, more spicy later.
  // FUNK scales the aggression (1000 = baseline).
  const base = Math.max(
    0.16,
    (0.72 - wave*0.05 - Math.min(0.28, alive*0.0016)) / FUNK
  );

  // Add a tiny bit of variance so it doesn't feel like a metronome.
  enemyShootTimer = base * (0.85 + Math.random()*0.35);

  if (!enemies.length) return;

  // Shoot from a random alive enemy (classic arcade chaos).
  const e = enemies[Math.floor(Math.random() * enemies.length)];

  // Straight-line shots, but slightly aimed (vx is constant, so still a straight path).
  const dx = (player.x - e.x);
  const vx = Math.max(-3.2, Math.min(3.2, dx * 0.012)); // gentle lead
  const vy = (5.6 + wave*0.45) * FUNK;

  enemyBullets.push({ x: e.x, y: e.y + e.h/2 + 6, vx, vy, r: 4 });
}


let swoopTimer = 0;

/*
  v1.15: Galaga-like swoop attackers.
  The *formation* is clamped to the top zone.
  Individual enemies can temporarily dive into the player zone ("swoop") and then return.
*/
function tryStartSwoop(dt){
  // tick per-enemy cooldowns
  for (const e of enemies){
    if (e.swoopCooldown > 0) e.swoopCooldown = Math.max(0, e.swoopCooldown - dt);
  }

  swoopTimer -= dt;
  if (swoopTimer > 0) return;

  // How often a swoop starts (faster on higher waves)
  const interval = Math.max(0.7, 2.0 - wave * 0.12);
  swoopTimer = interval;

  // Limit simultaneous swoopers so it stays readable.
  const maxSwoopers = Math.min(4, Math.max(1, Math.floor((1 + (wave-1) / 3) * (0.9 + 0.25*(FUNK-1)))));
  const currentlySwooping = enemies.reduce((n, e) => n + (e.swoop ? 1 : 0), 0);
  if (currentlySwooping >= maxSwoopers) return;

  // Pick an eligible enemy.
  const candidates = enemies.filter(e => !e.swoop && e.swoopCooldown <= 0);
  if (!candidates.length) return;

  const e = candidates[Math.floor(Math.random() * candidates.length)];

  // Start at current formation position (fx/fy computed in update loop).
  const sx = e.fx || e.x;
  const sy = e.fy || e.y;

  // End near player area, but not *below* the player.
  const endY = Math.min(canvas.height * 0.90, player.y - 40);
  const endX = Math.max(40, Math.min(canvas.width - 40, player.x + rand(-140, 140)));

  // Control point makes an arcing dive (sideways + down).
  const c1x = sx + rand(-220, 220);
  const c1y = sy + rand(140, 260);

  // Duration scales with wave (faster dives later).
  const dur = Math.max(1.1, 1.75 - wave * 0.03);

  e.swoop = { t:0, dur, phase:"down", sx, sy, c1x, c1y, ex:endX, ey:endY };
  e.swoopCooldown = Math.max(1.2, 3.0 - wave * 0.10); // wait before it can swoop again
}

function quadBezier(t, a, b, c){
  // (1-t)^2 a + 2(1-t)t b + t^2 c
  const mt = 1 - t;
  return (mt*mt)*a + (2*mt*t)*b + (t*t)*c;
}


/* =======================
   Collision helpers
======================= */
function circleRect(cx, cy, cr, rx, ry, rw, rh){
  const testX = Math.max(rx, Math.min(cx, rx+rw));
  const testY = Math.max(ry, Math.min(cy, ry+rh));
  const dx = cx - testX;
  const dy = cy - testY;
  return (dx*dx + dy*dy) <= cr*cr;
}

function damagePlayer(){
  if (player.invuln > 0) return;
  lives -= 1;
  player.invuln = 1.20;
  playSfx(sfxOof);
  if (lives <= 0) showMenu();
}

/* =======================
   Input
======================= */
window.addEventListener("keydown", (e) => {
  unlockAudioOnce();
  if (e.code === "Space") e.preventDefault();

  // v1.12.5: HUD toggle (Slash key) - hidden by default
  if (e.code === "Slash"){
    hudVisible = !hudVisible;
    overlay.style.display = hudVisible ? "block" : "none";
  }

  const k = e.key.toLowerCase();
  keys[k] = true;

  if (e.code === "Space" && gameState === STATE.PLAYING) shoot();
  if (k === "escape") showMenu();
}, { passive:false });

window.addEventListener("keyup", (e) => { keys[e.key.toLowerCase()] = false; });

canvas.addEventListener("pointermove", (e) => {
  // v1.19: aim follows pointer (mouse or touch)
  setAimFromClient(e.clientX, e.clientY);
});

canvas.addEventListener("pointerdown", (e) => {
  unlockAudioOnce();
  // v1.19: clicking also aims and shoots
  setAimFromClient(e.clientX, e.clientY);
  if (gameState === STATE.PLAYING) shoot();
});

/* =======================
   Update + Draw
======================= */
function update(dt){
  time += dt;

  // starfield updates always
  updateStarfield(dt, keys, player.speed);

  if (gameState !== STATE.PLAYING) return;

  if (player.invuln > 0) player.invuln = Math.max(0, player.invuln - dt);
  if (fireCooldown > 0) fireCooldown = Math.max(0, fireCooldown - dt);

  if (waveBanner.t > 0) waveBanner.t = Math.max(0, waveBanner.t - dt);

  // player move
  if (keys["a"] || keys["arrowleft"]) player.x -= player.speed;
  if (keys["d"] || keys["arrowright"]) player.x += player.speed;
  player.x = Math.max(player.w/2, Math.min(canvas.width - player.w/2, player.x));

// v1.24: Update UFO (tiny fast bonus target)
if (ufo){
  ufo.phase += dt * 14;

  // Move
  ufo.x += ufo.vx;
  ufo.y += ufo.vy;

  // Bounce in a top-zone box
  const minX = 18, maxX = canvas.width - 18;
  const minY = 40, maxY = canvas.height * 0.42;

  if (ufo.x < minX){ ufo.x = minX; ufo.vx *= -1; }
  if (ufo.x > maxX){ ufo.x = maxX; ufo.vx *= -1; }
  if (ufo.y < minY){ ufo.y = minY; ufo.vy *= -1; }
  if (ufo.y > maxY){ ufo.y = maxY; ufo.vy *= -1; }

  // Mild avoidance: if the player is moving toward it, nudge away horizontally
  const playerMoveDir = (keys["a"] || keys["arrowleft"]) ? -1 : ((keys["d"] || keys["arrowright"]) ? 1 : 0);
  if (playerMoveDir !== 0){
    const toward = (playerMoveDir < 0 && ufo.x < player.x) || (playerMoveDir > 0 && ufo.x > player.x);
    if (toward){
      ufo.vx += Math.sign(ufo.x - player.x) * 0.25;
      ufo.vx = Math.max(-9, Math.min(9, ufo.vx));
    }
  }

  // v1.25: fade away after the 3rd hit and grant power-up when fully vanished
  if (ufo.fading){
    ufo.alpha = Math.max(0, ufo.alpha - dt * 1.9);
    // keep it lively while fading
    ufo.vx *= 0.997;
    ufo.vy *= 0.997;

    if (ufo.alpha <= 0){
      const grant = ufo.grantBombOnVanish;
      ufo = null;
      if (grant) hasBomb = true;
    }
  } else {
    ufo.alpha = 1;
  }
}

  // v1.19: smooth the aim angle (shortest-path wrap) for nicer feel
  const da = normAngle(aimAngle - aimAngleSmoothed);
  aimAngleSmoothed = normAngle(aimAngleSmoothed + da * Math.min(1, dt * 18));

  // formation movement bounds depend on breathing spacing
  const breath = Math.sin(time * 2) * 0.5 + 0.5;
  const spacingX = getSpacingX() * (1 + breath * 0.25);

  const formationWidth = (formationCols - 1) * spacingX;

  // v1.12.4: predict next X so we don't clip enemies on wider desktop layouts
  const nextXOffset = formation.xOffset + (formation.dir * formation.speed);

  const leftEdgeNext  = canvas.width/2 - formationWidth/2 + nextXOffset;
  const rightEdgeNext = canvas.width/2 + formationWidth/2 + nextXOffset;

  if (leftEdgeNext < formation.boundsPad){
    formation.dir = 1;
    formation.xOffset += 2;
    formation.yOffset += formation.stepDown;
  } else if (rightEdgeNext > canvas.width - formation.boundsPad){
    formation.dir = -1;
    formation.xOffset -= 2;
    formation.yOffset += formation.stepDown;
  } else {
    formation.xOffset = nextXOffset;
  }

  // v1.13: always drift downward toward the player (Galaga pressure)
  formation.yOffset += formation.descentSpeed * dt;

  // update bullets
  for (let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    b.x += b.vx;
    b.y += b.vy;
    if (b.x < -80 || b.x > canvas.width + 80 || b.y < -80 || b.y > canvas.height + 80) bullets.splice(i, 1);
  }

  for (let i = enemyBullets.length - 1; i >= 0; i--){
    const b = enemyBullets[i];
    b.x += (b.vx || 0);
    b.y += b.vy;
    if (enemyBullets[i].y > canvas.height + 60) enemyBullets.splice(i, 1);
  }


  // v1.23: player bullet <-> enemy bullet collision (both vanish on contact)
  // This prevents bullet spam from feeling unfair and adds a satisfying "counter-shot" mechanic.
  for (let pi = bullets.length - 1; pi >= 0; pi--){
    const p = bullets[pi];
    for (let ei = enemyBullets.length - 1; ei >= 0; ei--){
      const e = enemyBullets[ei];
      const dx = p.x - e.x;
      const dy = p.y - e.y;
      const rr = (p.r + e.r);
      if (dx*dx + dy*dy <= rr*rr){
        bullets.splice(pi, 1);
        enemyBullets.splice(ei, 1);
        break; // player bullet is gone, move to next one
      }
    }
  }

  // v1.15: attempt to launch swoop attackers
  tryStartSwoop(dt);

  // compute enemy positions
  const spacingY = getSpacingY() * (1 + breath * 0.15);
  const formationHeight = (formationRows - 1) * spacingY;

  const startX = canvas.width/2 - formationWidth/2 + formation.xOffset;

  // v1.12.3: base spawn Y from each enemy, plus formation yOffset
  // then clamp so the formation bottom never gets too close to player
  let baseY = 80 + formation.yOffset;

// Keep enemies in the TOP half-ish of the screen.
// We still drift downward (Galaga pressure), but we *cap* the formation so it doesn't
// invade the player's space like it's paying rent down there.
const TOP_SAFE_MARGIN = 60;
const ENEMY_ZONE_MAX_Y = canvas.height * 0.48; // ~top half with a little buffer

// Clamp TOP
if (baseY < TOP_SAFE_MARGIN){
  formation.yOffset += (TOP_SAFE_MARGIN - baseY);
  baseY = TOP_SAFE_MARGIN;
}

// Clamp BOTTOM (based on full formation height)
const maxBaseY = ENEMY_ZONE_MAX_Y - formationHeight;
if (baseY > maxBaseY){
  // pull the whole formation back up
  formation.yOffset -= (baseY - maxBaseY);
  baseY = maxBaseY;
  // if the formation is too tall to fit, at least respect the top margin
  if (baseY < TOP_SAFE_MARGIN) baseY = TOP_SAFE_MARGIN;
}


  for (const e of enemies){
    if (assetsReady && enemyImages.length && e.img === playerImg) e.img = randEnemyImg();

    const scale = 1 + breath * 0.18;
    const size = e.size * scale;

    // v1.13: predictable formation wobble (non-random, just annoying)
    const wobbleAmpX = 6 + Math.min(14, wave * 1.2);
    const wobbleAmpY = 3 + Math.min(10, wave * 0.7);
    const wobbleX = Math.sin(time * (0.9 + wave*0.03) + e.row * 0.7) * wobbleAmpX;
    const wobbleY = Math.cos(time * (1.1 + wave*0.02) + e.col * 0.6) * wobbleAmpY;

    e.fx = startX + e.col * spacingX + wobbleX;
    e.fy = baseY + e.row * spacingY + wobbleY;

    if (!e.swoop){
      // Normal formation tracking.
      e.x = e.fx;
      e.y = e.fy;
    } else {
      // Swoop motion: dive down along a bezier arc, then return back to formation.
      e.swoop.t += dt;
      const u = Math.min(1, e.swoop.t / e.swoop.dur);

      if (e.swoop.phase === "down"){
        e.x = quadBezier(u, e.swoop.sx, e.swoop.c1x, e.swoop.ex);
        e.y = quadBezier(u, e.swoop.sy, e.swoop.c1y, e.swoop.ey);

        if (u >= 1){
          // Switch to return phase.
          e.swoop.phase = "up";
          e.swoop.t = 0;
          e.swoop.dur = Math.max(0.75, e.swoop.dur * 0.85);

          // Return target is the *current* formation slot (fx/fy),
          // so the enemy rejoins smoothly even if the formation moved.
          e.swoop.sx = e.x;
          e.swoop.sy = e.y;
          e.swoop.ex = e.fx;
          e.swoop.ey = e.fy;
          // new control point arcs upward.
          e.swoop.c1x = e.x + rand(-200, 200);
          e.swoop.c1y = Math.max(60, e.y - rand(160, 260));
        }
      } else {
        // Return-to-formation arc
        e.x = quadBezier(u, e.swoop.sx, e.swoop.c1x, e.swoop.ex);
        e.y = quadBezier(u, e.swoop.sy, e.swoop.c1y, e.swoop.ey);

        if (u >= 1){
          // Back in formation.
          e.swoop = null;
          e.x = e.fx;
          e.y = e.fy;
        }
      }
    }

    e.w = size;
    e.h = size;
  }

  // bullet -> enemy collision
  for (let bi = bullets.length - 1; bi >= 0; bi--){
    const b = bullets[bi];

    // v1.25: Player bullets can hit the UFO. It takes 3 hits:
    // hit 1 -> red, hit 2 -> green, hit 3 -> blue then it fades away and grants .
    if (ufo && !ufo.fading){
      const dxu = b.x - ufo.x;
      const dyu = b.y - ufo.y;
      const rr = (b.r + ufo.r);
      if (dxu*dxu + dyu*dyu <= rr*rr){
        bullets.splice(bi, 1);

        ufo.hits += 1;
        ufo.stage = Math.min(3, ufo.hits);

        if (ufo.hits >= 3){
          ufo.fading = true;
          ufo.grantBombOnVanish = true;
        }

        playSfx(sfxHit);
        score += 15; // small reward per hit; main reward is the power-up
        continue; // this bullet is gone
      }
    }

    for (let ei = enemies.length - 1; ei >= 0; ei--){
      const e = enemies[ei];
      const rx = e.x - e.w/2, ry = e.y - e.h/2;

      if (circleRect(b.x, b.y, b.r, rx, ry, e.w, e.h)){
        enemies.splice(ei, 1);
        // v1.22: compactEnemyGrid() disabled (it made the game too easy by collapsing targets into one firing lane).
        // compactEnemyGrid();
        bullets.splice(bi, 1);
        score += 10;
        playSfx(sfxHit);
        break;
      }
    }
  }

  // enemy bullet -> player collision
  const prx = player.x - player.w/2, pry = player.y - player.h/2;
  for (let i = enemyBullets.length - 1; i >= 0; i--){
    const b = enemyBullets[i];
    if (circleRect(b.x, b.y, b.r, prx, pry, player.w, player.h)){
      enemyBullets.splice(i, 1);
      damagePlayer();
    }
  }

  // enemy contact damage
  if (player.invuln <= 0){
    for (const e of enemies){
      const rx = e.x - e.w/2, ry = e.y - e.h/2;
      const overlap =
        prx < rx + e.w &&
        prx + player.w > rx &&
        pry < ry + e.h &&
        pry + player.h > ry;
      if (overlap){ damagePlayer(); break; }
    }
  }

  enemyTryShoot(dt);

  // wave clear
  if (enemies.length === 0){
    wave += 1;
    showWaveBanner(wave);

    resetFormation();
    spawnEnemies();
    trySpawnUFO();
  }
}

function draw(){
  drawStarfield();

  // v1.13: Wave banner popup
  if (gameState === STATE.PLAYING && waveBanner.t > 0){
    const p = Math.min(1, waveBanner.t / 1.35);
    const alpha = Math.min(1, 0.2 + p);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.font = "bold 48px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#00ff66";
    ctx.shadowColor = "rgba(0,255,102,0.35)";
    ctx.shadowBlur = 12;
    ctx.fillText(waveBanner.text, canvas.width/2, canvas.height*0.25);
    ctx.restore();
  }

  // player flicker on invulnerability
  const flicker = player.invuln > 0 && Math.floor(time * 20) % 2 === 0;
  if (gameState === STATE.PLAYING){
    if (!flicker){
      ctx.drawImage(playerImg, player.x - player.w/2, player.y - player.h/2, player.w, player.h);
    }
  } else {
    ctx.drawImage(playerImg, player.x - player.w/2, player.y - player.h/2, player.w, player.h);
  }

// v1.19: aim indicator (yellow triangle orbiting around player, pointing where you're aiming)
if (gameState === STATE.PLAYING){
  const a = aimAngleSmoothed;
  const orbitR = player.w * 0.62;
  const tx = player.x + Math.cos(a) * orbitR;
  const ty = player.y + Math.sin(a) * orbitR;

  ctx.save();
  ctx.translate(tx, ty);
  ctx.rotate(a); // point outward
  ctx.fillStyle = "rgba(255,255,0,0.95)";
  ctx.beginPath();
  ctx.moveTo(16, 0);     // tip
  ctx.lineTo(-8, -7);    // base left
  ctx.lineTo(-8, 7);     // base right
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}


  // v1.25: Draw UFO (tiny fast bonus target)
  if (ufo){
    ctx.save();
    ctx.translate(ufo.x, ufo.y);

    // Fade
    ctx.globalAlpha = (ufo.alpha != null ? ufo.alpha : 1);

    // Color ladder: strobe -> red -> green -> blue
    let fill = "#fff";
    let stroke = "#000";
    if (ufo.stage === 0){
      const strobe = (Math.floor(time * 22) % 2) === 0;
      fill = strobe ? "#fff" : "#000";
      stroke = strobe ? "#000" : "#fff";
    } else if (ufo.stage === 1){
      fill = "#f00"; stroke = "#fff";
    } else if (ufo.stage === 2){
      fill = "#0f0"; stroke = "#000";
    } else {
      fill = "#00f"; stroke = "#fff";
    }

    ctx.fillStyle = fill;
    ctx.beginPath();
    ctx.ellipse(0, 0, 14, 7, 0, 0, Math.PI * 2);
    ctx.fill();

    // tiny outline so it doesn't vanish on stars
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.restore();
  }

  // enemies
  for (const e of enemies){
    ctx.drawImage(e.img, e.x - e.w/2, e.y - e.h/2, e.w, e.h);
  }

  // bullets (player)
  // v1.21: draw as simple circles (no text/letter-like shapes)
  ctx.fillStyle = "#ff0";
  for (const b of bullets){
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fill();
  }

  // bullets (enemy)
  ctx.fillStyle = "#0a6";
  for (const b of enemyBullets){
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.fill();
  }

  // v1.25: Bomb power-up slot (earned by destroying the UFO: 3 hits then fade)
  if (gameState === STATE.PLAYING && hasBomb){
    const pad = 18;
    const box = 48;
    const x = canvas.width - pad - box;
    const y = canvas.height - pad - box;

    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(x, y, box, box);
    ctx.strokeStyle = "rgba(0,255,0,0.45)";
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, box, box);

    ctx.globalAlpha = 1;
    ctx.font = "28px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#fff";
    ctx.fillText("", x + box/2, y + box/2 + 1);
    ctx.restore();
  }


  overlay.innerHTML =
    `Galaga-ish Clone v1.25<br>` +
    `State: ${gameState}<br>` +
    `Score: ${score} | Lives: ${lives} | Wave: ${wave}<br>` +
    `Enemies: ${enemies.length} (${ENEMY_ROWS}x${ENEMY_COLS})<br>` +
    `Enemy pool: ${enemyImages.length || 0} images<br>` +
    `Bullets: ${bullets.length} | Enemy Bullets: ${enemyBullets.length}<br>` +
    `Fire CD: ${fireCooldown.toFixed(2)}s (target ${getPlayerFireCooldown().toFixed(2)}s)<br>` +
    `Player: ${player.w}px | Gap: ${FORMATION_PLAYER_GAP}px<br>` +
    `ESC: Menu`;
}

let lastT = performance.now();
function loop(t){
  const dt = Math.min(0.033, (t - lastT) / 1000);
  lastT = t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

/* =======================
   Boot
======================= */
player.x = canvas.width / 2;
player.y = canvas.height - PLAYER_BOTTOM_MARGIN;

// v1.19: default aim straight up until the player moves the pointer
aimX = player.x;
aimY = player.y - 200;
aimAngle = -Math.PI/2;
aimAngleSmoothed = -Math.PI/2;

resetStarfield();
resize(); // also resets starfield + anchors player
showMenu();
spawnEnemies();

requestAnimationFrame(loop);
</script>
</body>
</html>
