<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Bananaman Shooter v1.82</title>
<style>
  html, body { margin:0; padding:0; background:black; overflow:hidden; color:#0f0; font-family:monospace; }
  canvas { display:block; }
  #overlay{
    position:absolute; top:10px; left:10px; font-size:14px; line-height:1.4; pointer-events:none;
    text-shadow:0 0 6px rgba(0,255,0,0.35);
   display:none; /* HUD hidden by default (toggle with /) */
  }


  #uiRoot{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
  .panel{
    pointer-events:auto;
    width:min(520px, 92vw);
    border:1px solid rgba(0,255,0,0.35);
    border-radius:14px;
    background: rgba(0,0,0,0.72);
    box-shadow: 0 0 28px rgba(0,255,0,0.08);
    padding: 18px 18px 16px;
    text-align:center;
  }
  .title{ font-size:26px; letter-spacing:1px; margin:4px 0 10px; }
  .subimg{
    width:120px; height:120px; display:block; margin:0 auto 10px;
    image-rendering:pixelated; filter: drop-shadow(0 0 8px rgba(0,255,0,0.18));
  }
  .btnRow{ display:flex; gap:10px; justify-content:center; margin-top:12px; flex-wrap:wrap; }
  button{
    font-family:monospace; color:#0f0; background:rgba(0,0,0,0.55);
    border:1px solid rgba(0,255,0,0.45);
    padding:10px 14px; border-radius:12px; cursor:pointer; min-width:160px;
  }
  button:hover{ background: rgba(0,255,0,0.08); }
  .smallBtn{ min-width:120px; padding:8px 12px; border-radius:10px; }
  .optionsGrid{ display:grid; grid-template-columns:1fr; gap:12px; text-align:left; margin-top:10px; }
  .optRow{ border:1px solid rgba(0,255,0,0.2); border-radius:12px; padding:10px 12px; background: rgba(0,0,0,0.35); }
  .optLabel{ display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; font-size:14px; }
  input[type="range"]{ width:100%; accent-color:#00ff66; }
  .hint{ opacity:0.8; font-size:12px; margin-top:10px; line-height:1.35; }

  /* OPTIONS MENU: keep it on-screen, scroll if needed */
  #optionsMenu.panel{ max-height:88vh; overflow:auto; }
  #optionsMenu .title{ font-size:22px; margin:2px 0 8px; }
  #optionsMenu .optionsGrid{ gap:8px; }
  #optionsMenu .optRow{ padding:8px 10px; }
  #optionsMenu .optLabel{ margin-bottom:6px; }
  #optionsMenu .hint{ margin-top:6px; line-height:1.25; }

  @media (max-height: 700px){
    #optionsMenu.panel{ padding:12px; }
    #optionsMenu .title{ font-size:20px; }
    #optionsMenu .optionsGrid{ gap:6px; }
    #optionsMenu .optRow{ padding:7px 9px; }
  }

  .statusLine{ margin-top:10px; font-size:12px; opacity:0.9; }

  /* =======================
     HUD Corner Slots (v1.82)
  ======================= */
  .cornerSlot{
    position:absolute;
    min-width:120px;
    height:86px;
    padding:8px 10px;
    border:2px solid rgba(0,255,0,0.55);
    border-radius:12px;
    background: rgba(0,0,0,0.55);
    box-shadow: 0 0 18px rgba(0,255,0,0.10);
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    gap:4px;
    pointer-events:none;
  }
  .cornerSlot .subtxt{
    font-family: "Courier New", monospace;
    font-size:12px;
    line-height:1;
    opacity:0.95;
    color:#0f0;
    text-align:center;
  }
  #livesSlot img{
    width:40px; height:40px;
    image-rendering:pixelated;
    filter: drop-shadow(0 0 8px rgba(0,255,0,0.20));
  }


  .livesButton{
    flex-direction:row;
    justify-content:center;
    gap:8px;
  }
  .livesLabel{
    font-family:"Courier New", monospace;
    font-size:12px;
    color:#00ff66;
    opacity:0.95;
    white-space:nowrap;
  }

  #deathOverlay{
    position:absolute;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background: rgba(255,0,0,0.22);
    pointer-events:auto;
  }
  #deathPanel{
    width:min(520px, 92vw);
    border:3px solid rgba(255,0,0,0.65);
    border-radius:16px;
    background: rgba(0,0,0,0.72);
    padding: 18px 18px 16px;
    text-align:center;
    box-shadow: 0 0 36px rgba(255,0,0,0.14);
  }
  #deathTitle{
    font-family:"Courier New", monospace;
    font-weight:900;
    font-size:56px;
    letter-spacing:2px;
    color:#ff4444;
    text-shadow: 0 0 10px rgba(255,0,0,0.25);
  }
  #btnRestart{
    margin-top:14px;
    font-family:"Courier New", monospace;
    font-size:20px;
    font-weight:800;
    color:#ffdddd;
    background: rgba(0,0,0,0.55);
    border:2px solid rgba(255,0,0,0.55);
    padding:10px 18px;
    border-radius:14px;
    cursor:pointer;
  }
  #btnRestart:hover{ background: rgba(255,0,0,0.10); }



  #pauseOverlay{
    position:absolute;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background: rgba(0,0,0,0.55);
    pointer-events:none;
    z-index: 90;
  }
  #pausePanel{
    width:min(520px, 92vw);
    border:3px solid rgba(0,255,0,0.65);
    border-radius:16px;
    background: rgba(0,0,0,0.72);
    padding: 18px 18px 16px;
    text-align:center;
    box-shadow: 0 0 36px rgba(0,255,0,0.14);
  
  box-sizing: border-box;
  max-width: min(520px, 92vw);
  width: min(520px, 92vw);

  position: relative;

  pointer-events: auto;
}
  #pauseTitle{
    font-family:"Courier New", monospace;
    font-weight:900;
    font-size:56px;
    letter-spacing:2px;
    color:#00ff66;
    text-shadow: 0 0 10px rgba(0,255,0,0.25);
  }
  #pauseHint{
    margin-top:10px;
    font-family:monospace;
    font-size:14px;
    opacity:0.9;
    color:#b6ffcf;
  }


  /* v1.82: keep HUD off the menu and keep menu clickable */
  #uiRoot{ z-index: 50; }
  #deathOverlay{ z-index: 100; }
  #livesSlot{ display:none; }
  #powerupSlot{ display:none; }


/* Centered wave label (replaces old Stage/Waves HUD) */
/* Centered wave label (final) */
#stageHud{
  position: absolute;
  top: 8px;
  left: 0;
  width: 100%;
  text-align: center;
  font: bold 20px monospace;
  z-index: 50;
  text-shadow: 0 0 8px rgba(0,0,0,0.65);
  pointer-events: none;
}

/* Accuracy score (top-left, 2x wave counter) */
#accuracyScore{
  position:absolute;
  top:10px;
  left:14px;
  font-family:monospace;
  font-weight:900;
  font-size:40px;
  color:#ffd400;
  text-shadow:0 0 8px rgba(0,0,0,0.65);
  pointer-events:none;
  z-index:60;
  user-select:none;
}

#timerHud{
  position:absolute;
  top:10px;
  right:14px;
  font-family:monospace;
  font-weight:800;
  font-size:18px;
  color:#ffffff;
  opacity:0.95;
  text-shadow:0 0 8px rgba(0,0,0,0.65);
  pointer-events:none;
  z-index:60;
  user-select:none;
}


/* =======================
   Invert Colors Mode
======================= */
body.invert-colors {
  filter: invert(1) hue-rotate(180deg);
}
</style>

</head>
<body>
<canvas id="game"></canvas>
<div id="overlay"></div>

<div id="stageHud" style="
  position:absolute;
  top:10px;
  left:10px;
  font-family:monospace;
  font-size:14px;
  color:#00ff66;
  text-shadow:0 0 6px rgba(0,255,0,0.35);
  pointer-events:none;
  z-index:20;
"></div>
<div id="accuracyScore">0</div>
<div id="timerHud">0.0s</div>


<div id="livesSlot" class="cornerSlot livesButton" style="left:14px; bottom:14px;">
  <span class="livesLabel">LIVES:</span>
  <img src="/media/images/gifs/bananarama.gif" alt="lives"/>
  <div id="livesText" class="subtxt">x3</div>
</div>

<div id="powerupSlot" class="cornerSlot" style="right:14px; bottom:14px; display:none;">
  <div id="powerupEmoji" style="font-size:34px; line-height:1;">üí•</div>
  <div id="powerupHint" class="subtxt">Press Q</div>
</div>

<div id="deathOverlay">
  <div id="deathPanel">
    <div id="deathTitle">YOU DIED</div>
    <button id="btnRestart">Restart</button>
  </div>
</div>


<div id="pauseOverlay">
  <div id="pausePanel">
    

    <div id="pauseTitle">PAUSED</div>
    <div id="pauseHint">Press ESC to resume</div>

    <!-- v1.82: Pause command input -->
    <input id="pauseCommand" type="text" autocomplete="off" spellcheck="false"
      placeholder="Type a command‚Ä¶ (e.g. /background_color navy)" style="width: 100%;
        max-width: 420px;
        box-sizing: border-box;
        margin-top: 14px;
        padding: 10px 12px;
        font-family: monospace;
        font-size: 16px;
        color: #00ff66;
        background: rgba(0,0,0,0.65);
        border: 2px solid rgba(0,255,0,0.45);
        border-radius: 12px;
        outline: none;
        pointer-events: auto;" />

    <div id="pauseCmdSuggest" style="width: 100%;
      max-width: 420px;
      box-sizing: border-box;
      margin: 8px auto 0;
      text-align: left;
      font-family: monospace;
      font-size: 14px;
      color: #b6ffcf;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(0,255,0,0.25);
      border-radius: 12px;
      padding: 8px 10px;
      display: none;
      pointer-events: auto;
      max-height: 180px;
      overflow: auto;
      box-shadow: 0 0 18px rgba(0,255,0,0.08);"></div>
    <button id="btnPauseQuit" style="
      margin-top:16px;
      font-family:monospace;
      font-size:18px;
      font-weight:800;
      color:#0f0;
      background: rgba(0,0,0,0.55);
      border:2px solid rgba(0,255,0,0.55);
      padding:10px 18px;
      border-radius:14px;
      cursor:pointer;
      pointer-events:auto;
    ">Quit to Menu</button>
  </div>
</div>


<div id="uiRoot">
  <div id="startMenu" class="panel">
    <div class="title">Bananaman Shooter <span style="font-size:14px; opacity:0.75;">(v1.82)</span></div>
    <img class="subimg" src="/media/images/gifs/bananarama.gif" alt="bananarama" />
    <div class="hint">Move: A/D or ‚¨Ö‚û° (or Left Stick/D-Pad) ¬∑ Aim: Mouse/Touch (or Right Stick) ¬∑ Shoot: Space/Click (or RT/A) ¬∑ Bomb: Q (or X/RB) ¬∑ Shield: RMB (or LB/LT) ¬∑ Pause: ESC (or Start) ¬∑ HUD: / (or View)</div>
    <div class="btnRow">
      <button id="btnStart">Start Game</button>
      <button id="btnOptions">Options</button>
    </div>
    <div id="assetStatus" class="statusLine">Loading enemy images...</div>
  </div>

  <div id="optionsMenu" class="panel" style="display:none;">
    <div class="title">OPTIONS</div>

    
    <div class="optionsGrid">
      <div class="optRow">
        <div class="optLabel"><span>Starting Lives</span><span id="livesVal">3</span></div>
        <input id="livesSlider" type="range" min="0" max="20" value="3" step="1" />
      </div>

      <div class="optRow">
        <div class="optLabel"><span>Starting Hearts</span><span id="heartsVal">4</span></div>
        <input id="heartsSlider" type="range" min="1" max="12" value="4" step="1" />
        <div class="hint">Hearts = max hits per life. More hearts = smaller damage per hit.</div>
      </div>

      <div class="optRow">
        <div class="optLabel"><span>Starting Shields</span><span id="shieldsVal">0</span></div>
        <input id="shieldsSlider" type="range" min="0" max="10" value="0" step="1" />
        <div class="hint">Shields act like extra one-hit armor pips (üõ°Ô∏è) next to your hearts.</div>
      </div>

      <div class="optRow">
        <div class="optLabel"><span>Starting Bombs</span><span id="bombsVal">0</span></div>
        <input id="bombsSlider" type="range" min="0" max="20" value="0" step="1" />
      </div>


      <div class="optRow">
        <div class="optLabel"><span>Game Speed</span><span id="speedVal">5</span></div>
        <input id="speedSlider" type="range" min="1" max="10" value="5" step="1" />
        <div class="hint">5 = normal. 1 = slow-mo. 10 = turbo.</div>
      </div>

      <div class="optRow" style="gap:10px;">
        <label style="display:flex; align-items:center; gap:10px; font-size:14px; opacity:0.95; cursor:pointer;">
          <input id="infiniteToggle" type="checkbox" style="transform:scale(1.2);" />
          <span>Infinite (no damage, no resource consumption)</span>
        </label>
        <div class="hint">For testing, chaos, or avoiding consequences. Pick one.</div>

      <div class="optRow" style="gap:10px;">
        <label style="display:flex; align-items:center; gap:10px; font-size:14px; opacity:0.95; cursor:pointer;">
          <input id="invertColorsCheckbox" type="checkbox" style="transform:scale(1.2);" />
          <span>Invert Colors</span>
        </label>
        <div class="hint">Flips all colors for night mode, screenshots, or chaos.</div>
      </div>

      
      <div class="optRow" style="gap:10px;">
        <label style="display:flex; align-items:center; gap:10px; font-size:14px; opacity:0.95; cursor:pointer;">
          <input id="bossModeCheckbox" type="checkbox" style="transform:scale(1.2);" />
          <span>Boss Mode (start on Wave 11)</span>
        </label>
        <div class="hint">Starts you on the Wave 11 boss fight for practice/testing.</div>
      </div>

</div>
    </div>

    <div class="btnRow" style="margin-top:14px;">
      <button id="btnBack" class="smallBtn">Back</button>
      <button id="btnApply" class="smallBtn">Apply</button>
    </div>
  </div>
</div>

<script>
/* ======================================================================
  PROJECT CHANGELOG / REMOVAL LOG
========================================================================
[REMOVAL LOG]

- 2025-12-23 | v1.82
  Added: Native Xbox controller support via Gamepad API (move/aim/shoot/shield/bomb/pause + menu navigation).


- 2025-12-17 | v1.82
  Fixed: Game not starting / enemy images not loading due to runtime error.
  Cause: resize() called resetStarfield() before starLayers const initialized (TDZ).
  Fix: Initialize starfield definitions before resize() runs; make resize() safe.

- 2025-12-17 | v1.82
  Undo: v1.82 "simplified demo" version (removed menus/options/combat/etc.).
  Reason: User requested undo; restored full game build.
  Added: Player size increase + enforced vertical padding between formation and player.
  Location: player sizing, spawnEnemies baseY, update() formation Y clamp.

- 2025-12-17 | v1.82
  Added: Responsive desktop spacing so enemy formation uses screen width better.
  Added: Hard top-of-screen clamp so enemies stay visible even after step-downs.
  Tweaked: Reduced enemy base size + breathing scale to prevent overlap on desktop.
  Tweaked: Formation edge detection uses predicted next position to avoid clipping.


- 2025-12-17 | v1.82
  Added: Galaga-like enemy descent (continuous downward pressure) + predictable wobble.
  Tweaked: Enemy formation clamped to ~top half of screen (prevents encroaching into player zone).
  Tweaked: Increased base enemy spacing (X/Y) for clearer separation.
  Added: Wave banner ("WAVE 1", "WAVE 2", etc.) shown on start and after wave clears.
  Tweaked: Difficulty scaling per wave (enemy horizontal speed, descent speed, step-down).


- 2025-12-17 | v1.82
  Added: Wave spawn scaling: Wave 1 = 1 enemy, then doubles each wave (capped).
  Tweaked: FUN MODE: more lives, slower enemy pressure, slower swoops, faster bullets, gentler scaling.
  Added: Dynamic formation packing: auto-cols/rows + auto enemy sizing to fit top-zone area.
  Kept: Galaga-style 'swoop' attackers: individual enemies break formation, dive toward the player, then return.
  Kept: Main formation stays in the top zone; only swoopers can enter player space.
  Tweaked: Player fire rate increases each wave (cooldown decreases).


- 2025-12-17 | v1.82
  Tweaked: Player bullets are slightly larger than enemy bullets (visual clarity).
  Added: Player bullets can collide with enemy bullets; both are deleted on contact (counter-shot mechanic).

- 2025-12-17 | v1.82
  Added: Always-on player health bar under the player.
  Changed: Health replaces lives. Each enemy hit drains 25% health (4 hits total).
  Added: On death, player explodes into violent pixel-dust particles and returns to menu.



- 2025-12-17 | v1.82
  Fix: Restored any accidentally removed gameplay systems while adding UI and powerups.
  Kept: 360¬∞ aim + orbit triangle, straight bullets, bullet-vs-bullet cancel, Galaga formation + swoops, wave sizing 1/2/4/6/..., HUD toggle, menus/options.
  Added: Lives box (bottom-left), powerup slot with 'Press Q', YOU DIED overlay + Restart reset, UFO 25% wave spawn with 3-hit color cycle + fade granting üí•, Q bomb drop (+ flash then AoE + knockback), health bar (4 hits per life), pixel-dust death.
- 2025-12-19 | v1.82
  Changed: üí• bomb is now a short-range shot (spawns ahead of player in aim direction).
  Changed: Bomb detonates immediately on first enemy contact and can multi-kill enemies in the blast radius.

- 2025-12-19 | v1.82
  Added: Bomb-killing a dragon.gif enemy grants a one-time +25% "armor" pip next to the hearts HUD.
  Behavior: The armor absorbs the next hit (any damage) and then flips to ‚ùå briefly.

====================================================================== */


/* =======================
   Paths (EDIT IF NEEDED)
======================= */
const GIF_BASE = "/media/images/gifs/";
const AUDIO_HIT = "/media/audio/hitmarker.mp3";
const AUDIO_OOF = "/media/audio/oof.mp3";


/* =======================
   Audio
======================= */
const AUDIO_BG_MUSIC = "/media/audio/spaceinvaders.mp3";
const AUDIO_DEATH_YELL = "/media/audio/link-yell.mp3";

// Background music (loops). We start it on the first user interaction (autoplay rules).
const musicBg = new Audio(AUDIO_BG_MUSIC);
musicBg.loop = true;
musicBg.preload = "auto";
musicBg.volume = 0.6;

// Death yell (plays once when GAME OVER screen appears)
const sfxDeath = new Audio(AUDIO_DEATH_YELL);
sfxDeath.preload = "auto";
sfxDeath.volume = 0.9;

// Global mute toggle (M key)
let audioMuted = false;

function applyMuteState(){
  const m = !!audioMuted;
  musicBg.muted = m;
  sfxDeath.muted = m;
  sfxHit.muted = m;
  sfxOof.muted = m;
}

function tryPlayWithRetry(audioEl, retries=20, delayMs=80){
  if (!audioEl || audioMuted) return;
  try{
    audioEl.muted = !!audioMuted;
  }catch(e){}
  try{
    const p = audioEl.play();
    if (p && typeof p.catch === "function"){
      p.catch(() => {
        // Some browsers reject play() briefly even when audio is "unlocked".
        // We retry a handful of times so the sound lands as soon as it's allowed.
        if (retries > 0){
          setTimeout(() => tryPlayWithRetry(audioEl, retries - 1, delayMs), delayMs);
        }
      });
    }
  }catch(e){
    if (retries > 0){
      setTimeout(() => tryPlayWithRetry(audioEl, retries - 1, delayMs), delayMs);
    }
  }
}

function ensureMusicPlaying(restart=false){
  // Start/resume looping background music immediately when gameplay begins.
  // "restart=true" forces it back to the beginning.
  try{
    if (restart){
      musicBg.currentTime = 0;
    }
    musicBg.loop = true;
  }catch(e){}
  if (audioMuted) return;
  try{
    // If already playing and not restarting, leave it alone.
    if (!restart && !musicBg.paused) return;
    musicBg.play().catch(()=>{});
  }catch(e){}
}

function stopMusic(){
  try{
    musicBg.pause();
    musicBg.currentTime = 0;
  }catch(e){}
}

function playDeathYell(){
  if (audioMuted) return;
  try{
    sfxDeath.currentTime = 0;
  }catch(e){}
  // Try immediately, then retry briefly to avoid "plays only after next keypress" behavior.
  tryPlayWithRetry(sfxDeath, 30, 60);
}

/* =======================
   Player Firing Tuning
======================= */
const BASE_PLAYER_FIRE_COOLDOWN = 0.26; // seconds (wave scaling reduces this)
const PLAYER_BULLET_SPEED  = 8.0; // pixels per frame-ish (magnitude); direction comes from aim

function getPlayerFireCooldown(){
  // v1.82: player shoots faster every wave (lower cooldown)
  return Math.max(0.14, BASE_PLAYER_FIRE_COOLDOWN * Math.pow(0.94, (wave-1)));
}

/* =======================
   Canvas + Globals
======================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");


// v1.82: Starfield background color override (default is black)
var starfieldBgOverride = null; // CSS color string (e.g. "navy" or "#0b1020") or null
// =======================
// Post FX: chromatic aberration + gentle hue drift (beat-reactive)
// =======================
const fxCanvas = document.createElement("canvas");
const fxCtx = fxCanvas.getContext("2d");

function resizeFX(){
  fxCanvas.width = canvas.width;
  fxCanvas.height = canvas.height;
}

// Audio analysis (uses the looping background music)
let audioCtx = null;
let analyser = null;
let freqData = null;
let beatLevel = 0; // smoothed 0..1

function initAudioAnalyser(){
  if (analyser || !musicBg) return;
  try{
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 256;
    freqData = new Uint8Array(analyser.frequencyBinCount);

    const srcNode = audioCtx.createMediaElementSource(musicBg);
    srcNode.connect(analyser);
    analyser.connect(audioCtx.destination);
  }catch(e){
    // If the browser refuses (some do), we silently run FX in "ambient" mode.
    analyser = null;
  }
}

function getBeat(){
  // Gentle smoothing: quick rise, slow fall (prevents strobe)
  let v = 0;
  if (analyser && freqData){
    analyser.getByteFrequencyData(freqData);
    let sum = 0;
    for (let i = 0; i < freqData.length; i++) sum += freqData[i];
    v = (sum / freqData.length) / 255; // 0..1
  } else {
    // fallback "ambient pulse" if audio analysis unavailable
    v = 0.10 + 0.06 * Math.sin(time * 1.7);
  }

  // Smooth
  const attack = 0.45;
  const release = 0.08;
  if (v > beatLevel) beatLevel += (v - beatLevel) * attack;
  else beatLevel += (v - beatLevel) * release;

  return Math.max(0, Math.min(1, beatLevel));
}

function applyChromaticAberration(beat){
  const w = canvas.width, h = canvas.height;
  if (!w || !h) return;

  // Subtle offsets: ~1..4px
  const shift = 1.2 + beat * 2.8;

  // Slow hue drift; beat adds a gentle push
  const hue = (time * 10 + beat * 55) % 360;

  fxCtx.clearRect(0,0,w,h);

  // Base image with hue shift
  fxCtx.filter = `hue-rotate(${hue}deg)`;
  fxCtx.drawImage(canvas, 0, 0);

  // Light channel separation glow
  fxCtx.globalCompositeOperation = "screen";

  fxCtx.filter = `hue-rotate(${hue + 25}deg)`;
  fxCtx.drawImage(canvas, -shift, 0);

  fxCtx.filter = `hue-rotate(${hue + 55}deg)`;
  fxCtx.drawImage(canvas, shift, 0);

  fxCtx.globalCompositeOperation = "source-over";
  fxCtx.filter = "none";

  // Copy back
  ctx.clearRect(0,0,w,h);
  ctx.drawImage(fxCanvas, 0, 0);
}

const overlay = document.getElementById("overlay");
const livesSlot = document.getElementById("livesSlot");
const livesText = document.getElementById("livesText");
const powerupSlot = document.getElementById("powerupSlot");
const powerupHint = document.getElementById("powerupHint");
;
const deathOverlay = document.getElementById("deathOverlay");
const btnRestart = document.getElementById("btnRestart");

let hudVisible = false;

// =======================
// Pause (v1.82)
// - ESC toggles pause while playing.
// - Freezes gameplay updates and input-driven actions.
// =======================
const pauseOverlay = document.getElementById("pauseOverlay");

const pauseCommand = document.getElementById("pauseCommand");
const pauseCloseBtn = document.getElementById("pauseCloseBtn");
if (pauseCloseBtn){
  pauseCloseBtn.addEventListener("click", () => {
    // Resume gameplay
    if (typeof togglePause === "function") togglePause();
  });
}
const pauseCmdSuggest = document.getElementById("pauseCmdSuggest");
let isPaused = false;
const btnPauseQuit = document.getElementById("btnPauseQuit");
if (btnPauseQuit){
  btnPauseQuit.addEventListener("click", () => {
    // Unpause and return to start menu
    setPaused(false);
    stopMusic();
    showMenu();
  });
}

function setPaused(p){
  isPaused = !!p;
  if (pauseOverlay) pauseOverlay.style.display = isPaused ? "flex" : "none";

  // v1.82: focus the command input when paused
  if (pauseCommand){
    if (isPaused){
      setTimeout(()=>{ try{ pauseCommand.focus(); }catch(e){} }, 0);
    } else {
      try{ pauseCommand.blur(); }catch(e){}
      pauseCommand.value = "";
      if (pauseCmdSuggest){ pauseCmdSuggest.style.display = "none"; pauseCmdSuggest.innerHTML = ""; }
    }
  }

  // v1.82: pause ALSO pauses the looping music (resume continues from same timestamp)
  try{
    if (isPaused){
      if (!musicBg.paused) musicBg.pause();
    } else {
      // only resume if we're in gameplay and not muted
      if (gameState === STATE.PLAYING && !audioMuted) musicBg.play().catch(()=>{});
    }
  }catch(e){}

  // When pausing, clear held movement keys so you don't "drift" on resume.
  if (isPaused){
    for (const k in keys) keys[k] = false;
  }
}


// v1.82: /background_color autocomplete + executor
const BG_CMD = "/background_color";
const BG_COLORS = [
  "black","white","navy","midnightblue","darkslateblue","indigo","purple","darkmagenta",
  "maroon","darkred","crimson","firebrick",
  "darkgreen","seagreen","teal","darkcyan",
  "darkslategray","dimgray","slategray",
  "#000000","#0b1020","#111827","#1f2937","#0f172a","#020617",
  "#300000","#001a33","#002b36","#003300","#1a0033","#2a0030"
];

let bgSuggestOpen = false;
let bgSuggestIndex = 0;
let bgSuggestList = [];

function bgPrefix(v){ return String(v||"").startsWith(BG_CMD + " "); }
function bgTyped(v){ return bgPrefix(v) ? String(v||"").slice((BG_CMD + " ").length) : ""; }
function norm(s){ return String(s||"").trim().toLowerCase(); }

function buildBgList(typed){
  const t = norm(typed);
  const list = BG_COLORS.filter(c => norm(c).startsWith(t));

  // v1.82: if the user is typing a hex-like token, keep it as a selectable suggestion
  // Example: "/background_color #1a2b" should let them continue typing without being "corrected" to a named color.
  const looksHexy = /^#?[0-9a-fA-F]{1,8}$/.test(String(typed||"").trim());
  if (looksHexy && t.length){
    const token = String(typed||"").trim().startsWith("#") ? String(typed||"").trim() : ("#" + String(typed||"").trim());
    const out = [token];
    for (const c of (list.length ? list : BG_COLORS)) if (!out.includes(c)) out.push(c);
    return out;
  }

  return list.length ? list : BG_COLORS.slice();
}

function renderBgSuggest(){
  if (!pauseCmdSuggest) return;
  if (!bgSuggestOpen){
    pauseCmdSuggest.style.display = "none";
    pauseCmdSuggest.innerHTML = "";
    return;
  }
  pauseCmdSuggest.style.display = "block";
  pauseCmdSuggest.innerHTML = bgSuggestList.map((c,i)=>{
    const active = (i===bgSuggestIndex);
    return `<div data-i="${i}" style="padding:6px 6px;border-radius:8px;${active ? 'background: rgba(0,255,102,0.12); outline:1px solid rgba(0,255,102,0.25);' : ''}">
      <span style="display:inline-block;width:12px;height:12px;border-radius:3px;margin-right:8px;vertical-align:middle;background:${c};border:1px solid rgba(255,255,255,0.18);"></span>
      <span>${c}</span>
    </div>`;
  }).join("");
  const activeEl = pauseCmdSuggest.querySelector(`div[data-i="${bgSuggestIndex}"]`);
  if (activeEl && activeEl.scrollIntoView) activeEl.scrollIntoView({ block: "nearest" });
}

function openBgSuggestFromValue(v){
  bgSuggestOpen = true;
  bgSuggestList = buildBgList(bgTyped(v));
  bgSuggestIndex = 0;
  renderBgSuggest();
}
function closeBgSuggest(){ bgSuggestOpen = false; renderBgSuggest(); }

function applyBgChoiceToInput(){
  if (!pauseCommand) return;
  if (!bgSuggestOpen || !bgSuggestList.length) return;
  const chosen = bgSuggestList[bgSuggestIndex] || bgSuggestList[0];
  pauseCommand.value = BG_CMD + " " + chosen;
}

function cycleBgChoice(dir){
  if (!bgSuggestOpen) return;
  const n = bgSuggestList.length;
  if (!n) return;
  bgSuggestIndex = (bgSuggestIndex + dir) % n;
  if (bgSuggestIndex < 0) bgSuggestIndex += n;
  renderBgSuggest();
}

function execPauseCommand(cmd){
  const raw = String(cmd||"").trim();
  if (!raw) return;

  

  // /invert -> toggle invert colors mode (same as Options menu)
  if (raw === "/invert"){
    document.body.classList.toggle("invert-colors");
    return;
  }
if (raw.startsWith(BG_CMD)){
    const arg = raw.slice(BG_CMD.length).trim();
    
    // v1.82: allow named colors OR any valid hex code (#RGB, #RRGGBB, #RRGGBBAA), with or without leading "#"
    if (!arg){
      starfieldBgOverride = null;
      return;
    }

    const hexMatch = arg.match(/^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/);
    if (hexMatch){
      starfieldBgOverride = "#" + hexMatch[1];
      return;
    }

    // fall back to letting the browser try to interpret it as a CSS color name/value
    starfieldBgOverride = arg;
return;
  }

  // future commands go here
  try{ console.log("[PAUSE CMD]", raw); }catch(e){}
}



// v1.82: Pause command input listeners
if (pauseCommand){
  pauseCommand.addEventListener("keydown", (ev) => {
    // Prevent gameplay binds while typing
    ev.stopPropagation();

    // Autocomplete cycling when suggestions are open
    if (bgSuggestOpen && (ev.key === "Tab" || ev.key === "ArrowDown" || ev.key === "ArrowUp")){
      if (ev.key === "ArrowUp") cycleBgChoice(-1);
      else cycleBgChoice(1);
      applyBgChoiceToInput();
      ev.preventDefault();
      return;
    }

    if (ev.key === "Enter"){
      const cmd = (pauseCommand.value || "").trim();
      if (cmd) execPauseCommand(cmd);
      pauseCommand.value = "";
      closeBgSuggest();
      ev.preventDefault();
      return;
    }

    // Let Esc unpause even when focused
    if (ev.key === "Escape"){
      ev.preventDefault();
      closeBgSuggest();
      togglePause();
      return;
    }
  });

  pauseCommand.addEventListener("input", () => {
    const v = pauseCommand.value || "";
    if (bgPrefix(v)) openBgSuggestFromValue(v);
    else closeBgSuggest();
  });
}

if (pauseCmdSuggest){
  pauseCmdSuggest.addEventListener("mousedown", (ev) => {
    const row = ev.target && ev.target.closest ? ev.target.closest("div[data-i]") : null;
    if (!row) return;
    const i = parseInt(row.getAttribute("data-i"), 10);
    if (!isNaN(i)){
      bgSuggestIndex = i;
      applyBgChoiceToInput();
      renderBgSuggest();
    }
    ev.preventDefault();
  });
}

function togglePause(){
  if (gameState !== STATE.PLAYING) return;
  if (isDead) return; // don't pause during death freeze/respawn
  if (deathOverlay && deathOverlay.style.display === "flex") return; // don't pause on GAME OVER
  setPaused(!isPaused);
}


// =======================
// Right-Click Shield (v1.82)
// - Hold RIGHT MOUSE to raise a neon rainbow shield ring.
// - Shield blocks/bounces enemy contact + enemy bullets.
// - Uses "shield HP" so bullets don't erase it instantly.
// - Shield persists while held; only drops on release or when HP is depleted.
// - 30s cooldown after releasing or after shield breaks.
// =======================
let shieldActive = false;
let shieldHolding = false;

// HP model (more sane than "3 hits" when bullets are flying)
let shieldHP = 0;
const SHIELD_HP_MAX = 120;             // "reasonable amount" of damage before it breaks
const SHIELD_BULLET_DMG = 6;           // bullets nibble, they don't annihilate
const SHIELD_COLLISION_DMG = 18;       // ramming the shield costs more
let shieldCooldown = 0;                // seconds remaining
const SHIELD_COOLDOWN_SECS = 30;
const SHIELD_RADIUS_MULT = 0.78;       // relative to player size

// If focus/pointer events get weird, don't insta-drop the shield.
// Give a short grace period before forcing it off.
let shieldHoldGrace = 0;
const SHIELD_HOLD_GRACE_SECS = 0.25;

function canActivateShield(){
  return (gameState === STATE.PLAYING && !isDead && shieldCooldown <= 0 && !shieldActive);
}
function startShield(){
  shieldActive = true;
  // v1.82: If you let go earlier, keep remaining HP for next time.
  // Only refill to full when it was fully broken (shieldHP == 0) and cooldown has expired.
  if (shieldHP <= 0) shieldHP = SHIELD_HP_MAX;
  shieldHoldGrace = SHIELD_HOLD_GRACE_SECS;
}
function stopShield(startCooldown=false){
  // v1.82: Releasing shield should NOT trigger cooldown and should NOT erase remaining HP.
  if (shieldActive){
    shieldActive = false;
    shieldHoldGrace = 0;
    if (startCooldown) shieldCooldown = SHIELD_COOLDOWN_SECS;
  }
}
function shieldApplyDamage(dmg){
  if (!shieldActive) return;
  shieldHP = Math.max(0, shieldHP - Math.max(0, dmg));
  if (shieldHP <= 0){
    // v1.82: Cooldown ONLY when the shield breaks.
    stopShield(false);
  }
}
 // v1.82: HUD hidden by default; toggle with / (Slash)

let time = 0;
let score = 0;
let shotsFired = 0;
let hitsConnected = 0;
let damageDealt = 0;
let runTimer = 0; // seconds since Start Game
// v1.82: "Spectral Funk" tuning knob (because humans love naming sliders like they're mixtapes).
// 1000 = baseline. Higher = spicier enemies (faster patterns + smarter shots). Lower = chill mode.
const SPECTRAL_FUNK = 1000;
const FUNK = Math.max(0.25, Math.min(2.5, SPECTRAL_FUNK / 1000));

let lives = 0; // extra lives (decremented when health hits 0)
let frogKills = 0; // counts frog kills; every 3 frogs awards +1 life
let health = 1.0; // 0..1 (4 hits -> 0)
let MAX_HEARTS = 4; // v1.82: configurable hearts per life
let HIT_DAMAGE = 0.25; // 25% per hit (4 hearts = one life)

// =======================
// Dragon Bomb-Kill Armor (v1.82)
// - If a dragon.gif enemy is killed by the BOMB blast, grant a one-time +25% armor.
// - Armor absorbs the next hit, then turns into an ‚ùå briefly next to the hearts HUD.
// =======================
let bonusArmor = 0;              // 0 or 0.25
let bonusArmorBrokenT = 0;       // seconds remaining to show ‚ùå
let shieldPips = 0;            // v1.82: extra one-hit armor pips
let isDead = false;
let deathTimer = 0;
let deathGameOver = false;
let deathYellPlayed = false;
const deathParticles = [];


let wave = 1;
let firstBossSpawned = false; // track first boss size



function getStageInfo(wave){
  if (wave <= 10){
    return { stage: 1, start: 0, end: 10 };
  } else if (wave <= 20){
    return { stage: 2, start: 11, end: 20 };
  } else {
    return { stage: 3, start: 21, end: 30 };
  }
}


// v1.82: formation dimensions are dynamic per wave (wave 1 = 1 enemy, then doubles)
let formationCols = 1;
let formationRows = 1;
// v1.82: debug-only numbers shown in the HUD overlay
let ENEMY_COLS = formationCols;
let ENEMY_ROWS = formationRows;
// v1.82: wave banner (big text popup)
let waveBanner = { text:"", t:0, color:"#00ff66" };

function getWaveLabel(n){
  // Wave label rules:
  // - Waves 1-10: "Wave N"
  // - Wave 11: "Boss Mode" (red)
  // - Waves 12-21: "INSANITY WAVE: K" where K = n-11
  if (n === 11) return { text:"Boss Mode", color:"#ff3333" };
  if (n >= 12 && n <= 21) return { text:"INSANITY WAVE: " + (n - 11), color:"#ffffff" };
  return { text:"Wave " + n, color:"#ffffff" };
}

function showWaveBanner(n){
  const lab = getWaveLabel(n);
  waveBanner.text = lab.text;
  waveBanner.color = lab.color;
  waveBanner.t = 1.35;
}

const STATE = { MENU:"menu", OPTIONS:"options", PLAYING:"playing", WIN:"win" };
let gameState = STATE.MENU;
let gameWon = false;

// Powerup state (v1.82)
let ufo = null;
let bomb = null;
let bombsCount = 0;
let infiniteModeActive = false;


/* =======================
   Utility
======================= */
// =======================
// Accuracy Scoring (v1.82)
// - shotsFired: player bullets spawned
// - hitsConnected: player bullet hits that dealt damage
// - damageDealt: sum of bullet damage that landed
// Score awards scale with accuracy so spray-and-pray pays less.
// =======================
function getAccuracy(){
  if (shotsFired <= 0) return 0;
  return Math.max(0, Math.min(1, hitsConnected / shotsFired));
}

function getAccuracyMultiplier(){
  // 0% -> 0.55x, 100% -> 1.75x (gentle, not punitive)
  const a = getAccuracy();
  return 0.55 + a * 1.20;
}

function awardScore(basePoints){
  score += Math.round(Math.max(0, basePoints) * getAccuracyMultiplier());
}

const accuracyScoreEl = document.getElementById("accuracyScore");
const timerHud = document.getElementById("timerHud");
function updateAccuracyScoreHUD(){
  if (!accuracyScoreEl) return;
  if (gameState === STATE.PLAYING) accuracyScoreEl.style.display = "block";
  else accuracyScoreEl.style.display = "none";
  accuracyScoreEl.textContent = String(Math.floor(score));
}

function updateTimerHUD(){
  if (!timerHud) return;
  // Show timer only while actually playing
  if (gameState !== STATE.PLAYING){
    timerHud.style.display = "none";
    return;
  }
  timerHud.style.display = "block";
  timerHud.textContent = runTimer.toFixed(1) + "s";
}

function rand(min, max){ return min + Math.random() * (max - min); }

function drawInvertedTriangle(x, y, r){
  // Upside-down equilateral triangle around (x,y)
  const a0 = Math.PI/2; // point down
  ctx.beginPath();
  for (let i = 0; i 

<div id="heartsHud" style="
position:fixed;
bottom:12px;
left:50%;
transform:translateX(-50%);
font-size:28px;
letter-spacing:6px;
pointer-events:none;
z-index:9999;
">‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è</div>
</body>

</html>
