<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shooter Game v0.03</title>

  <style>
    /* v0.01–v0.03 baseline styling */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #050608;
      color: #ffffff;
      font-family: system-ui;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    /* Full-window container for game */
    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    /* Canvas stretches to container, logical size handled in JS */
    #game {
      width: 100%;
      height: 100%;
      display: block;
      background: #111;
      border: 2px solid #444;
    }

    /* Overlay UI */
    #ui {
      position: absolute;
      left: 10px;
      top: 10px;
      text-shadow: 0 0 4px black;
      pointer-events: none;
      z-index: 10;
      font-size: 14px;
    }

    #gameOverMessage {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: bold;
      color: #ff5555;
      text-shadow: 0 0 10px black;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      z-index: 20;
    }
  </style>
</head>

<body>
  <div id="gameContainer">
    <canvas id="game"></canvas>

    <div id="ui">
      <div>shooter-game v0.03</div>
      <div>WASD = move | Mouse = aim | LMB = shoot | R = restart</div>
      <div>HP: <span id="hpDisplay">100</span></div>
      <div>Score: <span id="scoreDisplay">0</span></div>
    </div>

    <div id="gameOverMessage">GAME OVER</div>
  </div>

  <script>
    // ================================================================
    // Shooter Game v0.03 (FULL FILE)
    //
    // Changes from v0.02:
    //  - Virtual space increased to 1200x800 to feel less cramped.
    //  - Player/enemy sizes slightly reduced.
    //  - Player contact damage now uses a cooldown, not continuous drain.
    //  - Bullet-enemy collision slightly more generous.
    //  - Enemy spawn rate and speed tuned for smoother pressure.
    // ================================================================

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const hpDisplay = document.getElementById("hpDisplay");
    const scoreDisplay = document.getElementById("scoreDisplay");
    const gameOverMessage = document.getElementById("gameOverMessage");

    // v0.03: Larger logical playfield = more breathing room
    const VIRTUAL_WIDTH = 1200;
    const VIRTUAL_HEIGHT = 800;

    // Logical space used for all gameplay calculations
    const WIDTH = VIRTUAL_WIDTH;
    const HEIGHT = VIRTUAL_HEIGHT;

    // Real canvas resizer (physical pixels match CSS)
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // Map logic coordinates → screen coordinates
    function sx(x) { return (x / VIRTUAL_WIDTH) * canvas.width; }
    function sy(y) { return (y / VIRTUAL_HEIGHT) * canvas.height; }

    // =================================================================
    // GAME STATE
    // =================================================================
    const player = {
      x: WIDTH / 2,
      y: HEIGHT / 2,
      radius: 12,         // v0.03: a bit smaller = less "fat hitbox" feel
      speed: 260,         // faster to compensate for bigger arena
      angle: 0,
      hp: 100,
      maxHp: 100
    };

    const bullets = [];
    const enemies = [];
    const keys = { w: false, a: false, s: false, d: false };

    const mouse = { x: WIDTH / 2, y: HEIGHT / 2, isDown: false };

    let score = 0;
    let isGameOver = false;

    // Shooting control
    let lastShotTime = 0;
    const SHOT_COOLDOWN = 0.15;

    // Enemy spawning
    let enemySpawnTimer = 0;
    const ENEMY_SPAWN_INTERVAL = 1.6; // v0.03: a bit slower to reduce chaos

    // v0.03: Player contact damage with cooldown for smoother feel
    let playerHitTimer = 0;
    const PLAYER_CONTACT_DAMAGE = 15;    // damage per hit
    const PLAYER_HIT_COOLDOWN = 0.7;     // seconds between contact hits

    // =================================================================
    // INPUT HANDLERS
    // =================================================================
    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = true;
      if (k === "a") keys.a = true;
      if (k === "s") keys.s = true;
      if (k === "d") keys.d = true;
      if (k === "r" && isGameOver) location.reload();
    });

    window.addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = false;
      if (k === "a") keys.a = false;
      if (k === "s") keys.s = false;
      if (k === "d") keys.d = false;
    });

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      // Convert from screen space -> virtual space
      const nx = (e.clientX - rect.left) / canvas.width;
      const ny = (e.clientY - rect.top) / canvas.height;
      mouse.x = nx * VIRTUAL_WIDTH;
      mouse.y = ny * VIRTUAL_HEIGHT;
    });

    canvas.addEventListener("mousedown", (e) => {
      if (e.button === 0) mouse.isDown = true;
    });

    canvas.addEventListener("mouseup", (e) => {
      if (e.button === 0) mouse.isDown = false;
    });

    // =================================================================
    // SHOOTING / ENEMY SPAWNING
    // =================================================================
    function shootBullet() {
      const dx = mouse.x - player.x;
      const dy = mouse.y - player.y;
      const len = Math.hypot(dx, dy) || 1;
      const dirX = dx / len;
      const dirY = dy / len;

      const bulletSpeed = 600; // v0.03: slightly faster to match larger space

      bullets.push({
        x: player.x,
        y: player.y,
        radius: 4,
        vx: dirX * bulletSpeed,
        vy: dirY * bulletSpeed,
        life: 1.8
      });
    }

    function spawnEnemy() {
      const edge = Math.floor(Math.random() * 4);
      let x, y;

      if (edge === 0) { x = Math.random() * WIDTH; y = -40; }
      else if (edge === 1) { x = WIDTH + 40; y = Math.random() * HEIGHT; }
      else if (edge === 2) { x = Math.random() * WIDTH; y = HEIGHT + 40; }
      else { x = -40; y = Math.random() * HEIGHT; }

      enemies.push({
        x,
        y,
        radius: 14,                     // v0.03: smaller enemies
        speed: 90 + Math.random() * 35, // tuned a bit slower
        hp: 3
      });
    }

    // =================================================================
    // UPDATE LOOP
    // =================================================================
    function update(dt) {
      if (isGameOver) return;

      // v0.03: tick down the contact hit cooldown
      playerHitTimer = Math.max(0, playerHitTimer - dt);

      // Player facing
      const dmx = mouse.x - player.x;
      const dmy = mouse.y - player.y;
      player.angle = Math.atan2(dmy, dmx);

      // Movement
      let mvx = 0, mvy = 0;
      if (keys.w) mvy -= 1;
      if (keys.s) mvy += 1;
      if (keys.a) mvx -= 1;
      if (keys.d) mvx += 1;

      const mag = Math.hypot(mvx, mvy) || 1;
      mvx /= mag;
      mvy /= mag;

      player.x += mvx * player.speed * dt;
      player.y += mvy * player.speed * dt;

      // Keep player inside logical bounds
      player.x = Math.max(player.radius, Math.min(WIDTH - player.radius, player.x));
      player.y = Math.max(player.radius, Math.min(HEIGHT - player.radius, player.y));

      // Shooting cooldown
      if (mouse.isDown) {
        const t = performance.now() / 1000;
        if (t - lastShotTime >= SHOT_COOLDOWN) {
          shootBullet();
          lastShotTime = t;
        }
      }

      // Bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        b.life -= dt;

        if (
          b.life <= 0 ||
          b.x < -100 || b.x > WIDTH + 100 ||
          b.y < -100 || b.y > HEIGHT + 100
        ) {
          bullets.splice(i, 1);
        }
      }

      // Spawn enemies
      enemySpawnTimer += dt;
      if (enemySpawnTimer >= ENEMY_SPAWN_INTERVAL) {
        enemySpawnTimer = 0;
        spawnEnemy();
      }

      // Enemies update
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];

        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const dist = Math.hypot(dx, dy) || 1;
        const dirX = dx / dist;
        const dirY = dy / dist;

        e.x += dirX * e.speed * dt;
        e.y += dirY * e.speed * dt;

        // Player contact with cooldown-based damage
        const combinedR = player.radius + e.radius;
        if (dist < combinedR && playerHitTimer === 0 && !isGameOver) {
          player.hp -= PLAYER_CONTACT_DAMAGE;
          playerHitTimer = PLAYER_HIT_COOLDOWN;

          if (player.hp <= 0) {
            player.hp = 0;
            handleGameOver();
          }
        }

        // Bullet collisions
        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          const distBE = Math.hypot(e.x - b.x, e.y - b.y);

          // v0.03: slightly more generous collision check
          const collisionRadius = e.radius + b.radius * 1.3;

          if (distBE < collisionRadius) {
            bullets.splice(j, 1);
            e.hp -= 1;

            if (e.hp <= 0) {
              enemies.splice(i, 1);
              score += 10;
              break;
            }
          }
        }
      }

      // UI updates
      hpDisplay.textContent = Math.max(0, player.hp).toFixed(0);
      scoreDisplay.textContent = score;
    }

    // =================================================================
    // DRAW LOOP (scaled using sx(), sy())
    // =================================================================
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Background gradient
      const g = ctx.createRadialGradient(
        canvas.width / 2, canvas.height / 2, 0,
        canvas.width / 2, canvas.height / 2,
        Math.max(canvas.width, canvas.height)
      );
      g.addColorStop(0, "#151515");
      g.addColorStop(1, "#050505");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const scaleFactor = canvas.width / VIRTUAL_WIDTH;

      // Bullets
      for (const b of bullets) {
        ctx.beginPath();
        ctx.arc(
          sx(b.x),
          sy(b.y),
          b.radius * scaleFactor,
          0,
          Math.PI * 2
        );
        ctx.fillStyle = "#ffdd55";
        ctx.fill();
      }

      // Enemies
      for (const e of enemies) {
        const rr = e.radius * scaleFactor;
        ctx.beginPath();
        ctx.arc(sx(e.x), sy(e.y), rr, 0, Math.PI * 2);
        ctx.fillStyle = "#ff4444";
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#880000";
        ctx.stroke();
      }

      // Player
      const pr = player.radius * scaleFactor;
      ctx.beginPath();
      ctx.arc(sx(player.x), sy(player.y), pr, 0, Math.PI * 2);
      ctx.fillStyle = "#55aaff";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#fff";
      ctx.stroke();

      // Player gun direction
      const gunLen = player.radius + 10;
      const gx = player.x + Math.cos(player.angle) * gunLen;
      const gy = player.y + Math.sin(player.angle) * gunLen;

      ctx.beginPath();
      ctx.moveTo(sx(player.x), sy(player.y));
      ctx.lineTo(sx(gx), sy(gy));
      ctx.strokeStyle = "#fff";
      ctx.stroke();

      if (isGameOver) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    // =================================================================
    // GAME OVER
    // =================================================================
    function handleGameOver() {
      isGameOver = true;
      gameOverMessage.style.opacity = 1;
    }

    // =================================================================
    // MAIN LOOP
    // =================================================================
    let lastTime = performance.now();

    function gameLoop(t) {
      const dt = (t - lastTime) / 1000;
      lastTime = t;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);

  </script>
</body>
</html>
