<!doctype html>
<!--
  shooter-game.html v0.2.4
  Features carried over:
    - Tailwind UI, Options (difficulty + speed), health system, bullets, enemies
    - Enemy size scales HP & damage (big = tougher/harder hits, small = faster/weaker)
  New in 0.2.4:
    - Hold Alt to drag HUD widgets (Stats and Health) independently
    - Snap to nearest screen corner with a pulse animation when released near a corner
-->
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bananaman Shooter</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
@keyframes snapPulse {
  0% { transform: scale(1); box-shadow: 0 0 0px rgba(0,255,150,0); }
  50% { transform: scale(1.1); box-shadow: 0 0 20px rgba(0,255,150,0.8); }
  100% { transform: scale(1); box-shadow: 0 0 0px rgba(0,255,150,0); }
}
.snap-anim { animation: snapPulse 0.25s ease-out; }
</style>
</head>
<body class="m-0 h-screen bg-[#0b0b0b] text-gray-200 font-sans overflow-hidden select-none">
<canvas id="game-canvas" class="fixed inset-0 w-full h-full block"></canvas>

<!-- Main Menu -->
<div id="main-menu" class="fixed inset-0 flex items-center justify-center pointer-events-auto">
  <div class="bg-neutral-900/90 border border-white/10 rounded-2xl shadow-2xl p-8 w-[min(92vw,560px)] text-center">
    <h1 class="text-yellow-300 text-4xl md:text-5xl font-extrabold mb-1 drop-shadow-md">Bananaman Shooter</h1>
    <p class="text-sm opacity-70 mb-6">v0.2.4</p>
    <button id="btn-start" class="w-full my-2 py-3 rounded-xl border border-white/20 bg-white/10 hover:bg-white/20 transition">Start Game</button>
    <button id="btn-options" class="w-full my-2 py-3 rounded-xl border border-white/20 bg-white/10 hover:bg-white/20 transition">Options</button>
  </div>
</div>

<!-- Options Menu -->
<div id="options-menu" class="hidden fixed inset-0 flex items-center justify-center pointer-events-auto">
  <div class="bg-neutral-900/90 border border-white/10 rounded-2xl shadow-2xl p-8 w-[min(92vw,560px)] text-center">
    <h2 class="text-yellow-300 text-3xl font-bold mb-4">Options</h2>

    <p class="mb-2">Difficulty: <span id="diff-label" class="font-semibold">Normal</span></p>
    <input id="diff-slider" type="range" min="1" max="3" step="1" value="2" class="w-4/5 accent-yellow-400">
    <p id="diff-desc" class="text-sm opacity-75 mb-4">Enemies deal standard damage.</p>

    <p class="mb-2">Game Speed: <span id="speed-label" class="font-semibold">1.0x</span></p>
    <input id="speed-slider" type="range" min="1" max="10" step="1" value="1" class="w-4/5 accent-pink-400">
    <p id="speed-desc" class="text-sm opacity-75 mb-6">Adjusts overall game speed (1x–5x).</p>

    <button id="btn-back" class="w-full py-3 rounded-xl border border-white/20 bg-white/10 hover:bg-white/20 transition">Back</button>
  </div>
</div>

<!-- HUD (both are draggable with Alt) -->
<div id="hud-stats" class="hidden fixed top-2 left-2 bg-neutral-800/70 text-sm px-3 py-2 rounded-lg border border-white/10 cursor-move">
  Kills: <span id="killcount">0</span> | Wave: <span id="wavecount">0</span>
</div>

<div id="healthbar" class="hidden fixed top-12 left-2 w-52 h-5 border border-white relative bg-red-950 rounded cursor-move">
  <div id="healthfill" class="absolute left-0 top-0 h-full w-full bg-red-500 transition-[width] duration-200 rounded"></div>
  <div id="healthtext" class="absolute w-full text-center text-xs text-white top-[2px]">100%</div>
</div>

<div id="you-died" class="fixed inset-0 flex items-center justify-center text-red-600 font-extrabold text-6xl drop-shadow-[0_0_40px_#ff0000] bg-black/80 opacity-0 transition-opacity duration-1000 pointer-events-none">
  YOU DIED
</div>

<div class="fixed bottom-2 right-3 text-xs opacity-70 bg-neutral-900/70 border border-white/10 px-2 py-1 rounded">
  Move: WASD • Aim: Mouse • Shoot: Click/Space • ESC: Menu • Hold Alt to drag HUD
</div>

<script>
/* ---------------- Core DOM ---------------- */
const canvas=document.getElementById('game-canvas');
const ctx=canvas.getContext('2d',{alpha:false});

const mainMenu=document.getElementById('main-menu');
const optionsMenu=document.getElementById('options-menu');
const btnStart=document.getElementById('btn-start');
const btnOptions=document.getElementById('btn-options');
const btnBack=document.getElementById('btn-back');

const diffSlider=document.getElementById('diff-slider');
const diffLabel=document.getElementById('diff-label');
const diffDesc=document.getElementById('diff-desc');
const speedSlider=document.getElementById('speed-slider');
const speedLabel=document.getElementById('speed-label');

const hudStats=document.getElementById('hud-stats');
const killEl=document.getElementById('killcount');
const waveEl=document.getElementById('wavecount');

const healthBar=document.getElementById('healthbar');
const healthFill=document.getElementById('healthfill');
const healthText=document.getElementById('healthtext');

const deathScreen=document.getElementById('you-died');

/* ---------------- Assets ---------------- */
const enemyGifs=[
 'bananarama.gif','dancing-guy.gif','dancingzoidberg.gif','dragon.gif','eyes.gif','fatspiderman.gif',
 'firework.gif','frog.gif','keyboard_smash.gif','skeleton.gif'
].map(n=>`/media/images/gifs/${n}`);

/* ---------------- State ---------------- */
const State={
  screen:'menu',rafId:null,lastFrame:0,
  mouse:{x:innerWidth/2,y:innerHeight/2},
  player:{x:0,y:0,size:96,speed:280,hp:100,hitFlash:0},
  bananaImg:new Image(),bananaLoaded:false,
  keys:{},bullets:[],enemies:[],
  wave:0,kills:0,nextKillTarget:10,clearTimer:0,
  difficulty:2,speedMultiplier:1
};
State.bananaImg.src='/media/images/gifs/bananarama.gif';
State.bananaImg.onload=()=>State.bananaLoaded=true;

/* ---------------- Canvas Fit ---------------- */
function fitCanvas(){
  const dpr=Math.min(devicePixelRatio||1,2);
  canvas.width=Math.floor(innerWidth*dpr);
  canvas.height=Math.floor(innerHeight*dpr);
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(dpr,dpr);
  if(State.screen==='menu'){ State.player.x=innerWidth/2; State.player.y=innerHeight/2; }
}
addEventListener('resize',fitCanvas); fitCanvas();

/* ---------------- Background ---------------- */
function drawBackground(){
  ctx.fillStyle='#0e0e10';ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.save();ctx.globalAlpha=.35;ctx.strokeStyle='#2aff8a';
  const s=32;
  for(let x=0;x<innerWidth;x+=s){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,innerHeight);ctx.stroke();}
  for(let y=0;y<innerHeight;y+=s){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(innerWidth,y);ctx.stroke();}
  ctx.restore();
}

/* ---------------- Player ---------------- */
function updatePlayer(dt){
  const p=State.player;
  if(State.keys['w'])p.y-=p.speed*dt;
  if(State.keys['s'])p.y+=p.speed*dt;
  if(State.keys['a'])p.x-=p.speed*dt;
  if(State.keys['d'])p.x+=p.speed*dt;
  p.x=Math.max(p.size/2,Math.min(innerWidth-p.size/2,p.x));
  p.y=Math.max(p.size/2,Math.min(innerHeight-p.size/2,p.y));
}
function drawPlayer(){
  const p=State.player;
  ctx.save();
  if(p.hitFlash>0){ctx.globalAlpha=0.5;ctx.filter='brightness(200%) saturate(200%)';}
  if(State.bananaLoaded){ctx.drawImage(State.bananaImg,p.x-p.size/2,p.y-p.size/2,p.size,p.size);}
  else{ctx.fillStyle='#ffe066';ctx.beginPath();ctx.arc(p.x,p.y,p.size/2,0,Math.PI*2);ctx.fill();}
  ctx.restore();
}
function drawArrow(){
  const p=State.player,dx=State.mouse.x-p.x,dy=State.mouse.y-p.y,angle=Math.atan2(dy,dx);
  const r=p.size*0.4,ax=p.x+Math.cos(angle)*r,ay=p.y+Math.sin(angle)*r;
  ctx.save();ctx.translate(ax,ay);ctx.rotate(angle);
  ctx.fillStyle='#ff3333';ctx.shadowColor='#ff0000';ctx.shadowBlur=8;
  ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(-10,-4);ctx.lineTo(-10,4);ctx.closePath();ctx.fill();ctx.restore();
}

/* ---------------- Bullets ---------------- */
function shootBullet(){
  const p=State.player,dx=State.mouse.x-p.x,dy=State.mouse.y-p.y,a=Math.atan2(dy,dx),spd=700;
  State.bullets.push({x:p.x,y:p.y,vx:Math.cos(a)*spd,vy:Math.sin(a)*spd});
}
function updateBullets(dt){
  State.bullets.forEach(b=>{b.x+=b.vx*dt;b.y+=b.vy*dt;});
  State.bullets=State.bullets.filter(b=>b.x>0&&b.x<innerWidth&&b.y>0&&b.y<innerHeight);
}
function drawBullets(){
  ctx.fillStyle='#ff3333';
  for(const b of State.bullets){ctx.beginPath();ctx.arc(b.x,b.y,4,0,Math.PI*2);ctx.fill();}
}

/* ---------------- Enemies (size→hp & dmg) ---------------- */
function spawnWave(){
  State.wave++;
  waveEl.textContent=State.wave;
  const count=Math.min(5+State.wave*2,60);
  for(let i=0;i<count;i++){
    const side=Math.floor(Math.random()*4);
    let x,y;
    if(side===0){x=Math.random()*innerWidth;y=-60;}
    else if(side===1){x=innerWidth+60;y=Math.random()*innerHeight;}
    else if(side===2){x=Math.random()*innerWidth;y=innerHeight+60;}
    else{x=-60;y=Math.random()*innerHeight;}
    const img=new Image();img.src=enemyGifs[Math.floor(Math.random()*enemyGifs.length)];
    const size=40+Math.random()*100;
    const baseSpeed=(80+State.wave*10)*(80/size); // small = faster
    const hp=2+size/40;                             // big = more hp
    const dmg=(5+Math.random()*10)*(size/80);      // big = harder hits
    State.enemies.push({x,y,img,size,speed:baseSpeed,hitCooldown:0,pulse:0,hp,dmg});
  }
  State.nextKillTarget+=10+State.wave*5;
}
function updateEnemies(dt){
  const p=State.player;
  for(const e of State.enemies){
    const dx=p.x-e.x,dy=p.y-e.y,dist=Math.hypot(dx,dy)||1;
    e.x+=dx/dist*e.speed*dt;
    e.y+=dy/dist*e.speed*dt;
    if(e.hitCooldown>0)e.hitCooldown-=dt;
    if(e.pulse>0)e.pulse-=dt*3;
  }
}
function drawEnemies(){
  for(const e of State.enemies){
    const pulseScale=1+(e.pulse||0)*0.2;
    ctx.save();
    ctx.globalAlpha=Math.max(0.4,Math.min(1,e.hp/10));
    if(e.img.complete)ctx.drawImage(e.img,e.x-e.size/2*pulseScale,e.y-e.size/2*pulseScale,e.size*pulseScale,e.size*pulseScale);
    ctx.restore();
  }
}

/* ---------------- Collisions ---------------- */
function checkCollisions(dt){
  const p=State.player;
  // bullets → enemies
  for(let i=State.enemies.length-1;i>=0;i--){
    const e=State.enemies[i];
    for(let j=State.bullets.length-1;j>=0;j--){
      const b=State.bullets[j];
      const dx=b.x-e.x,dy=b.y-e.y,dist=Math.hypot(dx,dy);
      if(dist<e.size/2+4){
        e.hp-=1; e.pulse=1;
        State.bullets.splice(j,1);
        if(e.hp<=0){
          State.enemies.splice(i,1);
          State.kills++; killEl.textContent=State.kills;
          if(State.kills>=State.nextKillTarget)spawnWave();
        }
        break;
      }
    }
  }
  // enemies → player
  for(const e of State.enemies){
    const dx=p.x-e.x,dy=p.y-e.y,dist=Math.hypot(dx,dy);
    if(dist<(p.size/2+e.size/2)*0.7 && e.hitCooldown<=0){
      e.hitCooldown=1; e.pulse=1;
      applyDamage(e.dmg);
    }
  }
  // auto-wave if cleared
  if(State.enemies.length===0&&State.screen==='playing'){
    State.clearTimer+=dt;
    if(State.clearTimer>3){spawnWave();State.clearTimer=0;}
  } else State.clearTimer=0;
}

/* ---------------- Damage / Health ---------------- */
function applyDamage(dmg){
  const p=State.player;
  if(State.difficulty===1)dmg*=0.5; // Easy
  if(State.difficulty===3)dmg=9999; // Hard = one-hit
  p.hp=Math.max(0,p.hp-dmg);
  p.hitFlash=0.3;
  updateHealthBar();
  if(p.hp<=0)die();
}
function updateHealthBar(){
  const p=State.player;
  const pct=Math.floor(Math.max(0,Math.min(100,p.hp)));
  healthFill.style.width=pct+'%';
  healthText.textContent=pct+'%';
  if(pct<40){ if(healthFill.classList.contains('bg-red-500')) healthFill.classList.replace('bg-red-500','bg-red-700'); }
  else { if(healthFill.classList.contains('bg-red-700')) healthFill.classList.replace('bg-red-700','bg-red-500'); }
}
function die(){
  State.screen='dead';
  deathScreen.classList.add('opacity-100');
  cancelAnimationFrame(State.rafId);
}

/* ---------------- Main Loop ---------------- */
function loop(ts){
  let dt=State.lastFrame?(ts-State.lastFrame)/1000:0;
  State.lastFrame=ts;
  dt*=State.speedMultiplier;
  updatePlayer(dt); updateBullets(dt); updateEnemies(dt); checkCollisions(dt);
  const p=State.player; if(p.hitFlash>0)p.hitFlash-=dt;
  drawBackground(); drawPlayer(); drawArrow(); drawBullets(); drawEnemies();
  if(State.screen==='playing')State.rafId=requestAnimationFrame(loop);
}

/* ---------------- Game Flow ---------------- */
function startGame(){
  mainMenu.classList.add('hidden');
  optionsMenu.classList.add('hidden');
  hudStats.classList.remove('hidden');
  healthBar.classList.remove('hidden');
  deathScreen.classList.remove('opacity-100');
  Object.assign(State,{
    screen:'playing',lastFrame:0,bullets:[],enemies:[],
    wave:0,kills:0,nextKillTarget:10,clearTimer:0,
    player:{...State.player,hp:100,hitFlash:0}
  });
  killEl.textContent='0'; waveEl.textContent='0'; updateHealthBar(); spawnWave();
  if(!State.rafId)State.rafId=requestAnimationFrame(loop);
}
function returnToMenu(){
  if(State.rafId)cancelAnimationFrame(State.rafId);
  State.rafId=null; State.screen='menu';
  mainMenu.classList.remove('hidden');
  optionsMenu.classList.add('hidden');
  hudStats.classList.add('hidden');
  healthBar.classList.add('hidden');
}

/* ---------------- Inputs ---------------- */
btnStart.addEventListener('click',startGame);
btnOptions.addEventListener('click',()=>{mainMenu.classList.add('hidden'); optionsMenu.classList.remove('hidden');});
btnBack.addEventListener('click',()=>{optionsMenu.classList.add('hidden'); mainMenu.classList.remove('hidden');});

diffSlider.addEventListener('input',()=>{
  const val=parseInt(diffSlider.value);
  State.difficulty=val;
  if(val===1){diffLabel.textContent='Easy';diffDesc.textContent='Enemies deal half damage.';}
  if(val===2){diffLabel.textContent='Normal';diffDesc.textContent='Enemies deal standard damage.';}
  if(val===3){diffLabel.textContent='Hard';diffDesc.textContent='Enemies kill instantly.';}
});
speedSlider.addEventListener('input',()=>{
  const val=parseInt(speedSlider.value);
  const mult=1+(val-1)*0.444; // 1–10 → 1.0x–5.0x
  State.speedMultiplier=mult;
  speedLabel.textContent=mult.toFixed(1)+'x';
});

addEventListener('keydown',e=>{
  State.keys[e.key.toLowerCase()]=true;
  if(e.key===' ')shootBullet();
  if(e.key==='Escape'&&State.screen==='playing')returnToMenu();
});
addEventListener('keyup',e=>State.keys[e.key.toLowerCase()]=false);
canvas.addEventListener('mousedown',e=>{
  // ignore clicks on HUD when Alt-dragging
  if(e.altKey) return;
  shootBullet();
});
addEventListener('mousemove',e=>{State.mouse.x=e.clientX; State.mouse.y=e.clientY;});

/* ---------------- HUD Drag + Snap (Alt) ---------------- */
const huds=[hudStats,healthBar];
let dragging=null, dragDX=0, dragDY=0;

function clearCornerClasses(el){
  el.classList.remove('top-2','left-2','right-2','bottom-2');
}
function startDrag(el, e){
  if(!e.altKey) return;
  dragging=el;
  el.style.transition='none';
  el.classList.add('ring-2','ring-green-400/60');
  clearCornerClasses(el);
  // move to fixed positioning if corner classes were providing position
  const r=el.getBoundingClientRect();
  el.style.position='fixed';
  el.style.left=r.left+'px';
  el.style.top=r.top+'px';
  dragDX=e.clientX - r.left;
  dragDY=e.clientY - r.top;
  e.preventDefault();
}
function duringDrag(e){
  if(!dragging || !e.altKey) return;
  dragging.style.left=(e.clientX - dragDX)+'px';
  dragging.style.top=(e.clientY - dragDY)+'px';
}
function endDrag(){
  if(!dragging) return;
  const el=dragging;
  const r=el.getBoundingClientRect();
  const W=innerWidth, H=innerHeight;
  const margin=8; // tailwind 2 = 0.5rem ~ 8px
  const snapDist=40;
  // compute target positions for corners
  const targets=[
    {x:margin,y:margin, classes:['top-2','left-2']},
    {x:W - r.width - margin, y:margin, classes:['top-2','right-2']},
    {x:margin, y:H - r.height - margin, classes:['bottom-2','left-2']},
    {x:W - r.width - margin, y:H - r.height - margin, classes:['bottom-2','right-2']},
  ];
  let snapped=false;
  for(const t of targets){
    if(Math.abs(r.left - t.x) < snapDist && Math.abs(r.top - t.y) < snapDist){
      // snap via inline left/top (most reliable across classes)
      el.style.left=t.x+'px';
      el.style.top=t.y+'px';
      // optional: also reflect with classes (purely cosmetic)
      clearCornerClasses(el);
      t.classes.forEach(c=>el.classList.add(c));
      el.classList.add('snap-anim');
      setTimeout(()=>el.classList.remove('snap-anim'),250);
      snapped=true;
      break;
    }
  }
  el.classList.remove('ring-2','ring-green-400/60');
  el.style.transition='';
  dragging=null;
}

for(const el of huds){
  el.addEventListener('mousedown', e=>startDrag(el,e));
}

window.addEventListener('mousemove', duringDrag);
window.addEventListener('mouseup', endDrag);

/* ---------------- Boot ---------------- */
drawBackground(); mainMenu.classList.remove('hidden');
</script>
</body>
</html>
