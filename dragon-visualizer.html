<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Recursive Fractal + Acid Rorschach</title>
<style>
    html,body {
        margin:0; padding:0;
        background:#000;
        overflow:hidden;
        font-family:sans-serif;
    }
    canvas {
        position:fixed;
        inset:0;
        width:100vw;
        height:100vh;
    }
    #ui {
        position:fixed;
        top:50%; left:50%;
        transform:translate(-50%,-50%);
        padding:24px 32px;
        background:rgba(10,0,20,0.8);
        border-radius:14px;
        border:1px solid rgba(255,255,255,0.2);
        color:#0ff;
        text-align:center;
        z-index:10;
        box-shadow:0 0 30px #0ff;
    }
    #ui.hidden {
        opacity:0; pointer-events:none;
        transform:translate(-50%,-60%);
        transition:0.7s;
    }
    button {
        padding:10px 20px;
        border:none; border-radius:999px;
        background:linear-gradient(135deg,#0ff,#f0f);
        color:#000;
        font-weight:600;
        cursor:pointer;
        box-shadow:0 0 12px #0ff;
    }
    input { display:none; }
</style>
</head>
<body>

<canvas id="c"></canvas>

<div id="ui">
    <h2 style="margin:0 0 10px;">Fractal + Acid Rorschach</h2>
    <p style="color:#ccc;font-size:0.9rem;margin-bottom:14px;">
        Upload an MP3 to awaken the ink-demon.
    </p>
    <button id="uploadBtn">Choose Audio</button>
    <input type="file" id="fileInput" accept="audio/*">
</div>

<script>
(() => {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;

    addEventListener("resize", () => {
        w = canvas.width = innerWidth;
        h = canvas.height = innerHeight;
    });

    const ui = document.getElementById("ui");
    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("fileInput");

    uploadBtn.onclick = () => fileInput.click();

    let audioCtx, source, analyser, data;
    let start = 0;

    // ------------------------------------
    // Smooth Perlin-like noise generator
    // ------------------------------------
    function noise(x, y, t) {
        return (
            Math.sin(x*0.02 + t*0.0003) +
            Math.sin(y*0.018 - t*0.00022) +
            Math.sin((x+y)*0.01 + t*0.00017)
        ) * 0.5;
    }

    // ------------------------------------
    // Draw acid Rorschach blot
    // ------------------------------------
    function drawInkBlot(bins, t) {
        const img = ctx.getImageData(0,0,w,h);
        const d = img.data;

        let low = bins[4] / 255;  
        let mid = bins[100] / 255;  
        let hi  = bins[300] / 255;  

        let pulse = (low*0.5 + mid*0.7 + hi*1.3);

        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w/2; x++) {

                const nx = x - w/4;
                const ny = y - h/2;

                const n = noise(nx*0.9, ny*0.9, t) * 0.6 +
                          noise(nx*0.5, ny*0.5, t*1.5) * 0.4;

                let v = Math.abs(n);
                v = Math.pow(v, 1.3 - pulse*0.6); // melt effect

                const hue = (t*0.01 + v*300) % 360;
                const sat = 40 + v*60;
                const lit = 10 + v*50 + pulse*20;

                const color = hslToRgb(hue/360, sat/100, lit/100);

                const idxL = (y*w + x)*4;
                const idxR = (y*w + (w-x-1))*4;

                d[idxL]   = color[0];
                d[idxL+1] = color[1];
                d[idxL+2] = color[2];
                d[idxL+3] = 255;

                d[idxR]   = color[0];
                d[idxR+1] = color[1];
                d[idxR+2] = color[2];
                d[idxR+3] = 255;
            }
        }

        ctx.putImageData(img,0,0);
    }

    // ------------------------------------
    // Helper: HSL to RGB
    // ------------------------------------
    function hslToRgb(h, s, l){
        if (s === 0) return [l*255,l*255,l*255];
        const hue2rgb = (p, q, t) => {
            if (t<0) t+=1;
            if (t>1) t-=1;
            if (t<1/6) return p + (q-p)*6*t;
            if (t<1/2) return q;
            if (t<2/3) return p + (q-p)*(2/3-t)*6;
            return p;
        };
        const q = l < .5 ? l*(1+s) : l+l*s-l*s;
        const p = 2*l-q;
        return [
            hue2rgb(p,q,h+1/3)*255,
            hue2rgb(p,q,h)*255,
            hue2rgb(p,q,h-1/3)*255
        ];
    }

    // ------------------------------------
    // Recursive spoke fractal (same as before)
    // ------------------------------------
    function drawRecursive(cx, cy, radius, bins, t, depth, maxDepth, rotOffset) {
        if (depth > maxDepth) return;

        const count = bins.length;
        const spokes = 360;

        for (let i = 0; i < spokes; i++) {
            const p = i/spokes;
            const idx = Math.floor(p*count);
            const amp = bins[idx]/255;

            const len = radius*(1 + amp*2.1*(depth+1));
            const a = p*Math.PI*2 + rotOffset + t*0.0004;

            const x = cx + Math.cos(a)*len;
            const y = cy + Math.sin(a)*len;

            const hue = (p*360 + depth*80 + t*0.02) % 360;
            ctx.strokeStyle = `hsla(${hue},100%,60%,${0.45-depth*0.12})`;
            ctx.lineWidth = 1 + amp*3;

            ctx.beginPath();
            ctx.moveTo(cx,cy);
            ctx.lineTo(x,y);
            ctx.stroke();
        }

        drawRecursive(
            cx,cy,
            radius*(0.45 + Math.sin(t*0.001 + depth)*0.05),
            bins,t,
            depth+1,maxDepth,
            rotOffset*1.32 + (depth+1)*0.7
        );
    }

    // ------------------------------------
    // Main render loop
    // ------------------------------------
    function render() {
        requestAnimationFrame(render);
        analyser.getByteFrequencyData(data);

        const t = performance.now() - start;
        drawInkBlot(data, t);

        const cx = w/2;
        const cy = h/2;
        const low = data[1]/255;
        const baseR = Math.min(w,h)*(0.12 + low*0.2);

        drawRecursive(cx,cy,baseR,data,t,0,3,0.2);
    }

    // ------------------------------------
    // When file chosen
    // ------------------------------------
    fileInput.onchange = async () => {
        const file = fileInput.files[0];
        if (!file) return;

        const array = await file.arrayBuffer();
        if (!audioCtx) audioCtx = new AudioContext();
        if (audioCtx.state === "suspended") await audioCtx.resume();
        const decoded = await audioCtx.decodeAudioData(array);

        if (source) source.stop();
        source = audioCtx.createBufferSource();
        source.buffer = decoded;

        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        data = new Uint8Array(analyser.frequencyBinCount);

        source.connect(analyser);
        analyser.connect(audioCtx.destination);
        source.start();

        ui.classList.add("hidden");
        start = performance.now();
        render();
    };
})();
</script>

</body>
</html>
