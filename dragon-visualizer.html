<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Recursive Neon Fractal + Splats</title>
<style>
    html,body {
        margin:0; padding:0;
        background:#000;
        overflow:hidden;
        font-family:sans-serif;
        user-select:none;
    }
    canvas {
        position:fixed;
        inset:0;
        width:100vw;
        height:100vh;
    }
    #ui {
        position:fixed;
        top:50%; left:50%;
        transform:translate(-50%,-50%);
        padding:24px 32px;
        background:rgba(10,0,20,0.8);
        border-radius:14px;
        border:1px solid rgba(255,255,255,0.2);
        color:#0ff; text-align:center;
        z-index:10;
        box-shadow:0 0 30px #0ff;
    }
    #ui.hidden {
        opacity:0; pointer-events:none;
        transform:translate(-50%,-60%);
        transition:0.7s;
    }
    button {
        padding:10px 20px;
        border:none; border-radius:999px;
        background:linear-gradient(135deg,#0ff,#f0f);
        color:#000;
        font-weight:600;
        cursor:pointer;
        box-shadow:0 0 12px #0ff;
    }
    input { display:none; }
</style>
</head>
<body>

<canvas id="c"></canvas>

<div id="ui">
    <h2 style="margin:0 0 10px;">Recursive Fractal + Paint Splats</h2>
    <p style="color:#ccc;font-size:0.9rem;margin-bottom:14px;">
        Upload an MP3 and unleash the chaos.
    </p>
    <button id="uploadBtn">Choose Audio</button>
    <input type="file" id="fileInput" accept="audio/*">
</div>

<script>
(() => {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;

    addEventListener("resize", () => {
        w = canvas.width = innerWidth;
        h = canvas.height = innerHeight;
    });

    const ui = document.getElementById("ui");
    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("fileInput");
    uploadBtn.onclick = () => fileInput.click();

    let audioCtx, source, analyser, data;
    let start = 0;

    // ------------------------------
    //  PAINT SPLAT SYSTEM
    // ------------------------------
    const splats = [];

    function spawnSplat(x, y, hue, amp) {
        splats.push({
            x, y,
            hue,
            radius: 40 + amp * 180,
            life: 1.0,
            shape: Math.floor(Math.random() * 3), // random shape type
            rotation: Math.random() * Math.PI * 2
        });
    }

    function drawSplats() {
        for (let i = splats.length - 1; i >= 0; i--) {
            const s = splats[i];
            s.life -= 0.003;
            if (s.life <= 0) {
                splats.splice(i, 1);
                continue;
            }

            ctx.save();
            ctx.globalAlpha = s.life * 0.7;

            ctx.translate(s.x, s.y);
            ctx.rotate(s.rotation);

            const grad = ctx.createRadialGradient(0,0,0,0,0,s.radius);
            grad.addColorStop(0, `hsla(${s.hue},100%,65%,${s.life})`);
            grad.addColorStop(1, `hsla(${s.hue},100%,40%,0)`);

            ctx.fillStyle = grad;

            if (s.shape === 0) {
                // Blob
                ctx.beginPath();
                ctx.ellipse(0,0, s.radius*0.8, s.radius, 0,0,Math.PI*2);
                ctx.fill();
            }
            else if (s.shape === 1) {
                // Spiky splat
                ctx.beginPath();
                for (let a=0; a<Math.PI*2; a+=Math.PI/12) {
                    const r = s.radius * (0.6 + Math.random()*0.5);
                    ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
                }
                ctx.closePath();
                ctx.fill();
            }
            else {
                // Paint flick scatter
                for (let p=0; p<40; p++) {
                    const a = Math.random()*Math.PI*2;
                    const r = Math.random()*s.radius;
                    ctx.fillRect(
                        Math.cos(a)*r,
                        Math.sin(a)*r,
                        3 + Math.random()*6,
                        3 + Math.random()*6
                    );
                }
            }

            ctx.restore();
        }
    }

    // ------------------------------------------------
    // AUDIO LOADING
    // ------------------------------------------------
    fileInput.onchange = async () => {
        const file = fileInput.files[0];
        if (!file) return;

        const arrayBuffer = await file.arrayBuffer();

        if (!audioCtx) audioCtx = new AudioContext();
        if (audioCtx.state === "suspended") await audioCtx.resume();

        const decoded = await audioCtx.decodeAudioData(arrayBuffer);
        if (source) source.stop();

        source = audioCtx.createBufferSource();
        source.buffer = decoded;

        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        data = new Uint8Array(analyser.frequencyBinCount);

        source.connect(analyser);
        analyser.connect(audioCtx.destination);
        source.start();

        ui.classList.add("hidden");
        start = performance.now();
        render();
    };

    // ------------------------------------------------
    // RECURSIVE SPOKE FRACTAL
    // ------------------------------------------------
    function drawRecursiveSpokes(cx, cy, radius, bins, t, depth, maxDepth, rotOffset) {
        if (depth > maxDepth) return;

        const count = bins.length;
        const spokes = 360;

        for (let i = 0; i < spokes; i++) {
            const p = i / spokes;
            const idx = Math.floor(p * count);
            const amp = bins[idx] / 255;

            const len = radius * (1 + amp * 2.1 * (depth+1));

            const angle = p * Math.PI * 2 + rotOffset + t*0.0004;

            const x = cx + Math.cos(angle)*len;
            const y = cy + Math.sin(angle)*len;

            const hue = (p*360 + depth*80 + t*0.02) % 360;

            ctx.strokeStyle = `hsla(${hue},100%,60%,${0.45-depth*0.12})`;
            ctx.lineWidth = 1 + amp*3;

            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(x, y);
            ctx.stroke();

            // occasional tiny sparkle nodes
            if (depth===0 && amp>0.6 && Math.random()<0.2) {
                ctx.fillStyle = `hsla(${hue},100%,70%,1)`;
                ctx.beginPath();
                ctx.arc(x,y,2+amp*5,0,Math.PI*2);
                ctx.fill();
            }
        }

        // recursive call
        drawRecursiveSpokes(
            cx, cy,
            radius * (0.45 + Math.sin(t*0.001+depth)*0.05),
            bins, t,
            depth+1, maxDepth,
            rotOffset*1.32 + (depth+1)*0.7
        );
    }

    // ------------------------------------------------
    // MAIN RENDER LOOP
    // ------------------------------------------------
    function render() {
        requestAnimationFrame(render);
        analyser.getByteFrequencyData(data);

        const t = performance.now() - start;

        // fade background slightly
        ctx.fillStyle = "rgba(0,0,0,0.12)";
        ctx.fillRect(0, 0, w, h);

        const cx = w/2;
        const cy = h/2;

        // detect strong bins for splats
        for (let i = 20; i < 200; i+=4) {
            const amp = data[i] / 255;
            if (amp > 0.62 && Math.random() < amp*0.3) {
                const angle = (i/data.length) * Math.PI*2;
                const dist = 50 + Math.random()*200;
                const x = cx + Math.cos(angle)*dist;
                const y = cy + Math.sin(angle)*dist;
                const hue = (i / data.length) * 360;
                spawnSplat(x,y,hue,amp);
            }
        }

        // paint splats FIRST (behind fractal)
        drawSplats();

        // fractal on top
        const low = data[1] / 255;
        const baseR = Math.min(w,h)*(0.12 + low*0.2);
        drawRecursiveSpokes(cx,cy,baseR,data,t,0,3,0.3);
    }
})();
</script>

</body>
</html>
