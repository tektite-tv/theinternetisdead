<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Recursive Neon Spoke Fractal</title>
<style>
    html,body {
        margin:0;
        padding:0;
        background:#000;
        overflow:hidden;
        font-family:sans-serif;
        user-select:none;
    }
    #c {
        position:fixed;
        inset:0;
        width:100vw;
        height:100vh;
        display:block;
    }
    #ui {
        position:fixed;
        top:50%; left:50%;
        transform:translate(-50%,-50%);
        padding:24px 32px;
        background:rgba(10,0,20,0.8);
        border-radius:12px;
        border:1px solid rgba(255,255,255,0.2);
        color:#0ff;
        text-align:center;
        z-index:10;
        box-shadow:0 0 30px #0ff;
    }
    #ui.hidden {
        opacity:0;
        pointer-events:none;
        transform:translate(-50%,-60%);
        transition:0.7s;
    }
    button {
        padding:10px 20px;
        border:none;
        border-radius:999px;
        background:linear-gradient(135deg,#0ff,#f0f);
        color:#000;
        font-weight:600;
        cursor:pointer;
        box-shadow:0 0 12px #0ff;
    }
    input { display:none; }
</style>
</head>
<body>

<canvas id="c"></canvas>

<div id="ui">
    <h2 style="margin:0 0 10px;">Recursive Rainbow Bloom</h2>
    <p style="color:#ccc;font-size:0.9rem;margin-bottom:14px;">
        Upload an MP3 and let the recursion begin.
    </p>
    <button id="uploadBtn">Choose Audio</button>
    <input type="file" id="fileInput" accept="audio/*">
</div>

<script>
(() => {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;

    addEventListener("resize", () => {
        w = canvas.width = innerWidth;
        h = canvas.height = innerHeight;
    });

    const ui = document.getElementById("ui");
    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("fileInput");

    uploadBtn.onclick = () => fileInput.click();

    let audioCtx, source, analyser, data;
    let start = 0;

    fileInput.onchange = async () => {
        const file = fileInput.files[0];
        if (!file) return;

        const array = await file.arrayBuffer();
        if (!audioCtx) audioCtx = new AudioContext();
        if (audioCtx.state === "suspended") await audioCtx.resume();

        const decoded = await audioCtx.decodeAudioData(array);
        if (source) source.stop();
        source = audioCtx.createBufferSource();
        source.buffer = decoded;

        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        data = new Uint8Array(analyser.frequencyBinCount);

        source.connect(analyser);
        analyser.connect(audioCtx.destination);
        source.start();

        ui.classList.add("hidden");
        start = performance.now();
        render();
    };

    // --------------------------
    // RECURSIVE SPOKE ENGINE
    // --------------------------

    function drawRecursiveSpokes(cx, cy, radius, bins, t, depth, maxDepth, rotOffset) {
        if (depth > maxDepth) return;

        const count = bins.length;
        const spokeCount = 360; // fixed for smoother wheel

        for (let i = 0; i < spokeCount; i++) {
            const p = i / spokeCount;

            // pick a frequency bin based on radial position
            const idx = Math.floor(p * count);
            const amp = bins[idx] / 255;

            const len = radius * (1 + amp * 2.2 * (1 + depth * 0.5));

            const angle = p * Math.PI * 2 + t * 0.0004 + rotOffset;

            const x = cx + Math.cos(angle) * len;
            const y = cy + Math.sin(angle) * len;

            const hue = (p * 360 + t * 0.02 + depth * 90) % 360;

            ctx.strokeStyle = `hsla(${hue},100%,60%,${0.45 - depth*0.15})`;
            ctx.lineWidth = 1 + amp * 3;

            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(x, y);
            ctx.stroke();

            // Tiny recursive spark nodes
            if (depth === 0 && amp > 0.5) {
                ctx.fillStyle = `hsla(${hue},100%,70%,0.9)`;
                ctx.beginPath();
                ctx.arc(x, y, 2 + amp * 6, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Spawn next recursion layer with:
        // - Smaller radius
        // - Slight rotation change
        // - More chaos
        const nextR = radius * (0.45 + Math.sin(t * 0.001 + depth) * 0.05);
        const nextOffset = rotOffset * 1.3 + (depth + 1) * 0.7;

        drawRecursiveSpokes(cx, cy, nextR, bins, t, depth + 1, maxDepth, nextOffset);
    }

    // --------------------------
    // MAIN LOOP
    // --------------------------

    function render() {
        requestAnimationFrame(render);

        analyser.getByteFrequencyData(data);
        const t = performance.now() - start;

        // Persistent trails
        ctx.fillStyle = "rgba(0,0,0,0.08)";
        ctx.fillRect(0, 0, w, h);

        const cx = w / 2;
        const cy = h / 2;

        const low = data[1] / 255;
        const baseR = Math.min(w, h) * (0.12 + low * 0.2);

        drawRecursiveSpokes(cx, cy, baseR, data, t, 0, 3, 0.3);
    }
})();
</script>

</body>
</html>
