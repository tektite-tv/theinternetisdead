<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>CRT Hypernova Dragon Visualizer</title>
<style>
    html,body{
        margin:0;
        padding:0;
        background:#000;
        overflow:hidden;
        font-family:sans-serif;
        color:#0ff;
    }
    canvas{
        position:fixed;
        inset:0;
        width:100vw;
        height:100vh;
        display:block;
    }
    #ui{
        position:fixed;
        top:50%;left:50%;
        transform:translate(-50%,-50%);
        padding:22px 28px;
        background:rgba(5,5,15,0.9);
        border-radius:14px;
        border:1px solid rgba(0,255,255,0.3);
        box-shadow:0 0 25px rgba(0,255,255,0.5);
        text-align:center;
        z-index:20;
    }
    #ui.hidden{
        opacity:0;
        pointer-events:none;
        transform:translate(-50%,-60%);
        transition:0.7s;
    }
    button{
        padding:9px 18px;
        border:none;
        border-radius:999px;
        background:linear-gradient(135deg,#0ff,#6f6bff);
        color:#000;
        font-weight:600;
        cursor:pointer;
        box-shadow:0 0 12px rgba(0,255,255,0.7);
    }
    input{display:none;}

    /* CRT overlay */
    #crt{
        pointer-events:none;
        position:fixed;
        inset:0;
        z-index:40;
        mix-blend-mode:soft-light;
    }
    #crt::before{
        content:"";
        position:absolute;
        inset:0;
        background:
            repeating-linear-gradient(
                to bottom,
                rgba(255,255,255,0.03) 0px,
                rgba(255,255,255,0.03) 1px,
                transparent 2px,
                transparent 3px
            );
    }
    #crt::after{
        content:"";
        position:absolute;
        inset:0;
        background:
            radial-gradient(circle at 50% 50%, transparent 0%, transparent 55%, rgba(0,0,0,0.85) 100%);
        mix-blend-mode:multiply;
    }
</style>
</head>
<body>

<canvas id="main"></canvas>
<canvas id="rorschach"></canvas>
<div id="crt"></div>

<div id="ui">
    <h2 style="margin:0 0 8px;">CRT Hypernova Dragon</h2>
    <p style="margin:0 0 14px;font-size:0.9rem;color:#cfd9ff;">
        Upload an audio file. The core grows, then detonates at the end.<br>
        Neon spirals, CRT stars, cursed void included.
    </p>
    <button id="uploadBtn">Choose Audio</button>
    <input type="file" id="fileInput" accept="audio/*">
    <div style="margin-top:8px;font-size:0.8rem;color:#aaa;">If everything explodes, that means it’s working.</div>
</div>

<script>
(() => {
    const main = document.getElementById("main");
    const ctx = main.getContext("2d");

    const rCanvas = document.getElementById("rorschach");
    const rctx = rCanvas.getContext("2d");

    function resizeAll() {
        main.width = rCanvas.width = window.innerWidth;
        main.height = rCanvas.height = window.innerHeight;
    }
    resizeAll();
    window.addEventListener("resize", resizeAll);

    const ui = document.getElementById("ui");
    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("fileInput");
    uploadBtn.onclick = () => fileInput.click();

    let audioCtx, analyser, data, source;
    let audioDuration = 0;
    let audioStartTime = 0;
    let startTime = 0;

    let running = false;
    let supernovaState = "idle";
    let supernovaStart = 0;
    let afterglowStart = 0;
    let coreRadiusAtTrigger = 0;

    // -----------------------
    // RORSCHACH BACKGROUND
    // -----------------------
    const rBuf = document.createElement("canvas");
    let rWidth = 320;
    let rHeight = 180;
    rBuf.width = rWidth;
    rBuf.height = rHeight;
    const rBufCtx = rBuf.getContext("2d");

    function hslToRgb(h,s,l){
        if (s===0) return [l*255,l*255,l*255];
        const hue2rgb = (p,q,t)=>{
            if(t<0)t+=1;if(t>1)t-=1;
            if(t<1/6)return p+(q-p)*6*t;
            if(t<1/2)return q;
            if(t<2/3)return p+(q-p)*(2/3-t)*6;
            return p;
        };
        const q = l<0.5?l*(1+s):l+s-l*s;
        const p = 2*l-q;
        return [
            hue2rgb(p,q,h+1/3)*255,
            hue2rgb(p,q,h)*255,
            hue2rgb(p,q,h-1/3)*255
        ];
    }

    function drawRorschach(bins,t){
        const L=bins.length;
        const mid=bins[Math.floor(L*0.35)]/255;
        const hi =bins[Math.floor(L*0.7)]/255;

        const img=rBufCtx.getImageData(0,0,rWidth,rHeight);
        const d=img.data;
        const cx=rWidth/2;
        const cy=rHeight/2;

        const drift=Math.sin(t*0.002)*3;
        const grain=0.12+hi*0.22;

        for(let y=0;y<rHeight;y++){
            const dy=y-cy+Math.sin((y+t*0.01)*0.05)*4*mid;
            for(let x=0;x<rWidth/2;x++){
                const dx=(x-cx/2)+drift;

                const n=(
                    Math.sin(dx*0.04+t*0.0008)+
                    Math.sin(dy*0.035-t*0.0005)+
                    Math.sin((dx+dy)*0.015+t*0.0011)
                )*0.5;

                let v=Math.abs(n);
                v=Math.pow(v,1.5-mid*0.4);
                v+=Math.random()*grain-grain*0.5;

                const hue=(200+v*200+hi*90)%360;
                const sat=25+v*35;
                const lit=4+v*32;

                const rgb=hslToRgb(hue/360,sat/100,lit/100);

                const idxL=(y*rWidth+x)*4;
                const idxR=(y*rWidth+(rWidth-x-1))*4;

                d[idxL]=rgb[0];
                d[idxL+1]=rgb[1];
                d[idxL+2]=rgb[2];
                d[idxL+3]=255;

                d[idxR]=rgb[0];
                d[idxR+1]=rgb[1];
                d[idxR+2]=rgb[2];
                d[idxR+3]=255;
            }
        }
        rBufCtx.putImageData(img,0,0);

        rctx.save();
        rctx.globalAlpha=0.9;
        rctx.imageSmoothingEnabled=true;
        rctx.clearRect(0,0,rCanvas.width,rCanvas.height);
        rctx.drawImage(rBuf,0,0,rCanvas.width,rCanvas.height);
        rctx.restore();
    }

    // -----------------------
    // CRT STARFIELD
    // -----------------------
    const STAR_COUNT=260;
    let stars=[];
    function initStars(){
        stars=[];
        const cx=main.width/2;
        const cy=main.height/2;
        for(let i=0;i<STAR_COUNT;i++){
            const angle=Math.random()*Math.PI*2;
            const dist=Math.random()*Math.max(main.width,main.height)*0.5;
            stars.push({
                angle,
                dist,
                depth:Math.random(),
                flicker:Math.random()*Math.PI*2,
                px:cx,py:cy,x:cx,y:cy
            });
        }
    }
    initStars();

    function drawStars(low,mid,hi,t,blast=1){
        const cx=main.width/2;
        const cy=main.height/2;

        ctx.save();
        ctx.lineCap="round";

        const speed=(0.15+low*0.5)*blast;
        const streak=(0.5+hi*2.0)*blast;

        for(const s of stars){
            s.px=s.x; s.py=s.y;

            const layer=speed*(0.25+(1-s.depth)*1.2);
            s.dist+=layer;

            const maxDist=Math.max(main.width,main.height)*0.75;
            if(s.dist>maxDist){
                s.dist=Math.random()*40;
                s.angle=Math.random()*Math.PI*2;
            }

            const jitter=mid*0.1*Math.sin(t*0.003+s.flicker);
            const ang=s.angle+jitter;

            s.x=cx+Math.cos(ang)*s.dist;
            s.y=cy+Math.sin(ang)*s.dist;

            const hue=(190+(1-s.depth)*40+hi*60)%360;
            const sat=30+hi*30;
            const light=35+(1-s.depth)*40+mid*10;

            ctx.strokeStyle=`hsla(${hue},${sat}%,${light}%,${0.3+hi*0.25})`;
            ctx.lineWidth=(1-s.depth)*1.4;

            ctx.beginPath();
            ctx.moveTo(s.px,s.py);
            const sx=cx+Math.cos(ang)*(s.dist-streak*4*(1-s.depth));
            const sy=cy+Math.sin(ang)*(s.dist-streak*4*(1-s.depth));
            ctx.lineTo(sx,sy);
            ctx.stroke();
        }

        ctx.restore();
    }

    // -----------------------
    // FRACTAL
    // -----------------------
    function drawWheel(cx,cy,r,bins,t,d,maxD,rot,phase){
        if(d>maxD)return;

        const spokes=200;
        const L=bins.length;

        for(let i=0;i<spokes;i++){
            const p=i/spokes;
            const idx=Math.floor(p*L);
            const amp=bins[idx]/255;

            const len=r*(1+amp*1.6*(d+1));
            const a=p*Math.PI*2+rot+phase+t*(0.00032+d*0.00004);
            const x=cx+Math.cos(a)*len;
            const y=cy+Math.sin(a)*len;

            const hue=(190+p*60+d*35+phase*90/Math.PI)%360;
            const sat=35+amp*20;
            const light=30+amp*20;

            ctx.strokeStyle=`hsla(${hue},${sat}%,${light}%,${0.15+amp*0.2-d*0.03})`;
            ctx.lineWidth=0.6+amp*1.8;

            ctx.beginPath();
            ctx.moveTo(cx,cy);
            ctx.lineTo(x,y);
            ctx.stroke();
        }

        drawWheel(cx,cy,r*(0.52+Math.sin(t*0.001+d)*0.03),bins,t,d+1,maxD,rot*1.18+(d+1)*0.5,phase);
    }

    function drawFractal(bins,t){
        const cx=main.width/2;
        const cy=main.height/2;
        const low=bins[2]/255;
        const r=Math.min(main.width,main.height)*(0.12+low*0.17);

        ctx.save();
        ctx.translate(cx,cy);
        ctx.rotate(Math.sin(t*0.0011)*0.1);
        ctx.translate(-cx,-cy);

        ctx.globalCompositeOperation="screen";

        drawWheel(cx,cy,r,bins,t,0,2,0.15,0);
        drawWheel(cx,cy,r*0.85,bins,t,0,2,-0.2,Math.PI/3);

        ctx.restore();
        ctx.globalCompositeOperation="source-over";
    }

    // -----------------------
    // NEON SPIRAL BURSTS
    // -----------------------
    const bursts=[];
    function spawnBurst(mid,hi){
        const cx=main.width/2;
        const cy=main.height/2;
        const maxR=Math.max(main.width,main.height)*(1.1+Math.random()*0.5);
        bursts.push({
            radius:maxR,
            angle:Math.random()*Math.PI*2,
            spin:(Math.random()*0.04+0.015)*(Math.random()<0.5?-1:1),
            shrink:0.985-hi*0.01,
            hueOffset:Math.random()*360,
            thickness:1.3+Math.random()*2.5,
            life:1,
            cx,cy
        });
    }

    function updateAndDrawBursts(coreR,bins,t,mid,hi){
        for(let i=bursts.length-1;i>=0;i--){
            const b=bursts[i];
            b.angle+=b.spin;
            b.radius*=b.shrink;
            b.life-=0.004-hi*0.001;

            const progress=Math.max(0,1-b.radius/(Math.max(main.width,main.height)*1.2));

            const hue=(b.hueOffset+progress*360+t*0.03)%360;
            const sat=70+hi*20;
            const light=50+mid*20;
            const alpha=0.2+(1-progress)*0.3;

            const x=b.cx+Math.cos(b.angle)*b.radius;
            const y=b.cy+Math.sin(b.angle)*b.radius;

            ctx.save();
            ctx.globalCompositeOperation="screen";
            ctx.strokeStyle=`hsla(${hue},${sat}%,${light}%,${alpha})`;
            ctx.lineWidth=b.thickness;

            ctx.beginPath();
            const tailR=b.radius+60;
            const tx=b.cx+Math.cos(b.angle+0.3)*tailR;
            const ty=b.cy+Math.sin(b.angle+0.3)*tailR;
            ctx.moveTo(tx,ty);
            ctx.lineTo(x,y);
            ctx.stroke();
            ctx.restore();

            if(b.radius<coreR+10||b.life<=0){
                bursts.splice(i,1);
            }
        }
    }

    // -----------------------
    // ⚪  HARD-EDGE CORE w/ BLOOM + VOID MASK + WARP
    // -----------------------
    function drawCore(progress,amp,t){
        const cx=main.width/2;
        const cy=main.height/2;

        const base=8;
        const maxExtra=Math.min(main.width,main.height)*0.22;
        const pulse=1+amp*0.55*Math.sin(t*0.012*(1+amp*2));
        const radius=base+maxExtra*progress*pulse;

        // 1. Darkness well
        ctx.save();
        ctx.globalCompositeOperation="multiply";
        const darkGrad=ctx.createRadialGradient(cx,cy,0,cx,cy,radius*2.2);
        darkGrad.addColorStop(0,"rgba(0,0,0,0.75)");
        darkGrad.addColorStop(0.5,"rgba(0,0,0,0.45)");
        darkGrad.addColorStop(1,"rgba(0,0,0,0)");
        ctx.fillStyle=darkGrad;
        ctx.beginPath();
        ctx.arc(cx,cy,radius*2.2,0,Math.PI*2);
        ctx.fill();
        ctx.restore();

        // 2. Hard white star
        ctx.save();
        ctx.globalCompositeOperation="lighter";
        ctx.fillStyle="rgba(255,255,255,0.95)";
        ctx.beginPath();
        ctx.arc(cx,cy,radius*0.55,0,Math.PI*2);
        ctx.fill();
        ctx.restore();

        // 3. Bloom glow
        ctx.save();
        ctx.globalCompositeOperation="screen";
        const glow=ctx.createRadialGradient(cx,cy,0,cx,cy,radius*2.4);
        glow.addColorStop(0,"rgba(255,255,255,1)");
        glow.addColorStop(0.2,"rgba(255,255,255,0.7)");
        glow.addColorStop(0.4,"rgba(180,220,255,0.45)");
        glow.addColorStop(1,"rgba(120,160,255,0)");
        ctx.fillStyle=glow;
        ctx.beginPath();
        ctx.arc(cx,cy,radius*2.4,0,Math.PI*2);
        ctx.fill();
        ctx.restore();

        // 4. Lens warp ring
        ctx.save();
        ctx.globalCompositeOperation="overlay";
        ctx.strokeStyle="rgba(255,255,255,0.25)";
        ctx.lineWidth=2+amp*3;
        ctx.beginPath();
        ctx.arc(cx,cy,radius*1.35,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();

        return radius;
    }

    // -----------------------
    // SUPERNOVA SEQUENCES
    // -----------------------
    function startSupernova(coreRNow){
        if(supernovaState!=="normal") return;
        supernovaState="exploding";
        supernovaStart=performance.now();
        coreRadiusAtTrigger=coreRNow;
    }

    function renderSupernova(now,bins){
        const t=now-supernovaStart;
        const dur=1800;
        const k=Math.min(t/dur,1);
        const cx=main.width/2;
        const cy=main.height/2;

        ctx.fillStyle=`rgba(255,255,255,${(1-k)*0.9})`;
        ctx.fillRect(0,0,main.width,main.height);

        const shock=Math.max(main.width,main.height)*0.9;
        const r=coreRadiusAtTrigger+shock*k;
        const ringW=40*(1-k)+10;

        const hueBase=(performance.now()*0.15)%360;
        ctx.save();
        ctx.globalCompositeOperation="screen";
        ctx.lineWidth=ringW;
        ctx.strokeStyle=`hsla(${hueBase},100%,70%,${1-k})`;
        ctx.beginPath();
        ctx.arc(cx,cy,r,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();

        const L=bins.length;
        let low=0,mid=0,hi=0,lc=0,mc=0,hc=0;
        for(let i=0;i<L;i++){
            const v=bins[i];
            if(i<L*0.15){low+=v;lc++}
            else if(i<L*0.5){mid+=v;mc++}
            else{hi+=v;hc++}
        }
        low=lc?low/(lc*255):0;
        mid=mc?mid/(mc*255):0;
        hi =hc?hi /(hc *255):0;
        drawStars(low,mid,hi,performance.now()-startTime,3.5);

        if(k>=1){
            supernovaState="afterglow";
            afterglowStart=performance.now();
        }
    }

    function renderAfterglow(now){
        const t=now-afterglowStart;
        const dur=900;
        const k=Math.min(t/dur,1);

        const img=ctx.createImageData(main.width,main.height);
        const d=img.data;
        const density=0.9-k*0.9;

        for(let i=0;i<d.length;i+=4){
            const n=(Math.random()<density*0.02)?255:0;
            d[i]=d[i+1]=d[i+2]=n;
            d[i+3]=255;
        }
        ctx.putImageData(img,0,0);

        ctx.fillStyle=`rgba(0,0,0,${k})`;
        ctx.fillRect(0,0,main.width,main.height);

        if(k>=1){
            supernovaState="done";
            running=false;
        }
    }

    // -----------------------
    // MAIN RENDER LOOP
    // -----------------------
    function render(){
        if(!running)return;
        requestAnimationFrame(render);

        analyser.getByteFrequencyData(data);
        const now=performance.now();
        const t=now-startTime;

        const L=data.length;
        let low=0,mid=0,hi=0,lc=0,mc=0,hc=0;
        for(let i=0;i<L;i++){
            const v=data[i];
            if(i<L*0.15){low+=v;lc++}
            else if(i<L*0.5){mid+=v;mc++}
            else{hi+=v;hc++}
        }
        low=lc?low/(lc*255):0;
        mid=mc?mid/(mc*255):0;
        hi =hc?hi /(hc *255):0;
        const amp=(low+mid+hi)/3;

        const audioTime=audioCtx?(audioCtx.currentTime-audioStartTime):0;
        const progress=audioDuration>0?Math.min(audioTime/audioDuration,1):0;

        if(supernovaState==="normal"&&progress>=0.995){
            const coreR=drawCore(progress,amp,t);
            startSupernova(coreR);
        }

        if(supernovaState==="exploding"){
            ctx.clearRect(0,0,main.width,main.height);
            renderSupernova(now,data);
            return;
        }

        if(supernovaState==="afterglow"){
            renderAfterglow(now);
            return;
        }

        // NORMAL RENDER ORDER
        drawRorschach(data,t);
        ctx.drawImage(rCanvas,0,0);

        const cx=main.width/2, cy=main.height/2;
        const glow=ctx.createRadialGradient(cx,cy,0,cx,cy,Math.max(main.width,main.height)*0.7);
        glow.addColorStop(0,"rgba(5,10,20,0.8)");
        glow.addColorStop(1,"rgba(0,0,0,1)");
        ctx.fillStyle="rgba(0,0,0,0.6)";
        ctx.fillRect(0,0,main.width,main.height);
        ctx.fillStyle=glow;
        ctx.fillRect(0,0,main.width,main.height);

        drawStars(low,mid,hi,t);
        drawFractal(data,t);

        if(Math.random()< (0.009+hi*0.018) && progress>0.02){
            spawnBurst(mid,hi);
        }

        const coreR=drawCore(progress,amp,t);

        updateAndDrawBursts(coreR,data,t,mid,hi);
    }

    // -----------------------
    // AUDIO SETUP
    // -----------------------
    fileInput.onchange = async()=>{
        const file=fileInput.files[0];
        if(!file)return;

        const buffer=await file.arrayBuffer();
        if(!audioCtx)audioCtx=new AudioContext();
        if(audioCtx.state==="suspended")await audioCtx.resume();

        const decoded=await audioCtx.decodeAudioData(buffer);
        if(source)source.stop();

        source=audioCtx.createBufferSource();
        source.buffer=decoded;
        audioDuration=decoded.duration||0;

        analyser=audioCtx.createAnalyser();
        analyser.fftSize=1024;
        data=new Uint8Array(analyser.frequencyBinCount);

        source.connect(analyser);
        analyser.connect(audioCtx.destination);

        source.onended=()=>{
            if(supernovaState==="normal"){
                const coreR=Math.min(main.width,main.height)*0.2;
                startSupernova(coreR);
                startTime=performance.now();
                running=true;
                requestAnimationFrame(render);
            }
        };

        audioStartTime=audioCtx.currentTime;
        source.start();

        ui.classList.add("hidden");
        initStars();
        startTime=performance.now();
        running=true;
        supernovaState="normal";
        bursts.length=0;

        requestAnimationFrame(render);
    };
})();
</script>

</body>
</html>
