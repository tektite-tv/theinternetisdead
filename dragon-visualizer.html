<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>CRT Void Dragon Visualizer</title>
<style>
    html,body{
        margin:0;
        padding:0;
        background:#000;
        overflow:hidden;
        font-family:sans-serif;
        color:#0ff;
    }
    canvas{
        position:fixed;
        inset:0;
        width:100vw;
        height:100vh;
        display:block;
    }
    #ui{
        position:fixed;
        top:50%;left:50%;
        transform:translate(-50%,-50%);
        padding:22px 28px;
        background:rgba(5,5,15,0.9);
        border-radius:14px;
        border:1px solid rgba(0,255,255,0.3);
        box-shadow:0 0 25px rgba(0,255,255,0.5);
        text-align:center;
        z-index:20;
    }
    #ui.hidden{
        opacity:0;
        pointer-events:none;
        transform:translate(-50%,-60%);
        transition:0.7s;
    }
    button{
        padding:9px 18px;
        border:none;
        border-radius:999px;
        background:linear-gradient(135deg,#0ff,#6f6bff);
        color:#000;
        font-weight:600;
        cursor:pointer;
        box-shadow:0 0 12px rgba(0,255,255,0.7);
    }
    input{display:none;}

    /* CRT overlay */
    #crt{
        pointer-events:none;
        position:fixed;
        inset:0;
        z-index:25;
        mix-blend-mode:soft-light;
    }
    #crt::before{
        content:"";
        position:absolute;
        inset:0;
        background:
            repeating-linear-gradient(
                to bottom,
                rgba(255,255,255,0.03) 0px,
                rgba(255,255,255,0.03) 1px,
                transparent 2px,
                transparent 3px
            );
    }
    #crt::after{
        content:"";
        position:absolute;
        inset:0;
        background:
            radial-gradient(circle at 50% 50%, transparent 0%, transparent 55%, rgba(0,0,0,0.85) 100%);
        mix-blend-mode:multiply;
    }
</style>
</head>
<body>

<canvas id="c"></canvas>
<canvas id="r"></canvas> <!-- RORSCHACH layer -->
<div id="crt"></div>

<div id="ui">
    <h2 style="margin:0 0 8px;">CRT Void Dragon</h2>
    <p style="margin:0 0 14px;font-size:0.9rem;color:#cfd9ff;">
        Upload audio. VHS mirror void awaits.
    </p>
    <button id="uploadBtn">Choose Audio</button>
    <input type="file" id="fileInput" accept="audio/*">
    <div style="margin-top:8px;font-size:0.8rem;color:#aaa;">It will look cursed. That's intended.</div>
</div>

<script>
(() => {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    const rCanvas = document.getElementById("r");
    const rctx = rCanvas.getContext("2d");

    function resizeAll() {
        canvas.width = rCanvas.width = window.innerWidth;
        canvas.height = rCanvas.height = window.innerHeight;
    }
    resizeAll();
    window.addEventListener('resize', resizeAll);

    const ui = document.getElementById("ui");
    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("fileInput");
    uploadBtn.onclick = () => fileInput.click();

    let audioCtx, analyser, data, source;
    let start = 0;

    // -----------------------------
    // VHS RORSCHACH VOID
    // -----------------------------
    let rWidth = 320; // low-res buffer for VHS effect
    let rHeight = 180;
    const rBuf = document.createElement('canvas');
    rBuf.width = rWidth;
    rBuf.height = rHeight;
    const rBufCtx = rBuf.getContext('2d');

    function drawRorschach(bins, t) {
        const L = bins.length;
        const mid = bins[Math.floor(L*0.35)]/255;
        const hi  = bins[Math.floor(L*0.7)]/255;

        // VHS drift
        const drift = Math.sin(t*0.002)*3;

        const img = rBufCtx.getImageData(0,0,rWidth,rHeight);
        const d = img.data;
        const cx = rWidth/2;
        const cy = rHeight/2;

        // grain amount
        const grain = 0.15 + hi*0.25;

        for (let y=0; y<rHeight; y++) {
            const dy = y - cy + Math.sin((y+t*0.01)*0.05)*4*mid;
            for (let x=0; x<rWidth/2; x++) {
                const dx = (x - cx/2) + drift;

                // VHS-like wobbly sin noise
                const n = (
                    Math.sin((dx)*0.04 + t*0.0008) +
                    Math.sin((dy)*0.035 - t*0.0005) +
                    Math.sin((dx+dy)*0.015 + t*0.0011)
                ) * 0.5;

                let v = Math.abs(n);
                v = Math.pow(v, 1.5 - mid*0.4);

                // glitch-lines
                const glitch = (Math.random()<0.005+hi*0.01) ? (Math.random()*0.6) : 0;
                v += glitch;

                // grain
                v += (Math.random()*grain - grain*0.5);

                // color grading
                const hue = (200 + v*180 + hi*80) % 360;
                const sat = 20 + v*40;
                const lit = 5 + v*35;

                const rgb = hslToRgb(hue/360, sat/100, lit/100);

                const idxL = (y*rWidth + x)*4;
                const idxR = (y*rWidth + (rWidth-x-1))*4;

                d[idxL]   = rgb[0];
                d[idxL+1] = rgb[1];
                d[idxL+2] = rgb[2];
                d[idxL+3] = 255;

                d[idxR]   = rgb[0];
                d[idxR+1] = rgb[1];
                d[idxR+2] = rgb[2];
                d[idxR+3] = 255;
            }
        }
        rBufCtx.putImageData(img,0,0);

        // scale up to full res with smoothing
        rctx.save();
        rctx.globalAlpha = 0.85;
        rctx.imageSmoothingEnabled = true;
        rctx.clearRect(0,0,canvas.width,canvas.height);
        rctx.drawImage(rBuf, 0,0, canvas.width,canvas.height);
        rctx.restore();
    }

    function hslToRgb(h,s,l){
        if (s===0) return [l*255,l*255,l*255];
        const hue2rgb=(p,q,t)=>{
            if(t<0)t+=1;if(t>1)t-=1;
            if(t<1/6)return p+(q-p)*6*t;
            if(t<1/2)return q;
            if(t<2/3)return p+(q-p)*(2/3-t)*6;
            return p;
        };
        const q=l<0.5?l*(1+s):l+s-l*s;
        const p=2*l-q;
        const r=hue2rgb(p,q,h+1/3);
        const g=hue2rgb(p,q,h);
        const b=hue2rgb(p,q,h-1/3);
        return [r*255,g*255,b*255];
    }

    // -----------------------------
    // STARFIELD (same but tuned for darkness)
    // -----------------------------
    const STAR_COUNT = 260;
    let stars = [];
    function initStars() {
        stars = [];
        const cx = canvas.width/2;
        const cy = canvas.height/2;
        for(let i=0;i<STAR_COUNT;i++){
            const angle = Math.random()*Math.PI*2;
            const dist = Math.random()*Math.max(canvas.width,canvas.height)*0.5;
            stars.push({
                angle,
                dist,
                depth:Math.random(),
                flicker:Math.random()*Math.PI*2,
                px:cx,py:cy,x:cx,y:cy
            });
        }
    }
    initStars();

    function drawStars(low, mid, hi, t){
        const cx = canvas.width/2;
        const cy = canvas.height/2;

        ctx.save();
        ctx.lineCap="round";

        const speed = 0.15 + low*0.5;
        const streak = 0.5 + hi*2.0;

        for (let s of stars){
            s.px = s.x; s.py = s.y;

            const layer = speed*(0.25 + (1-s.depth)*1.2);
            s.dist += layer;

            const maxDist = Math.max(canvas.width,canvas.height)*0.75;
            if(s.dist>maxDist){
                s.dist = Math.random()*40;
                s.angle = Math.random()*Math.PI*2;
            }

            const jitter = mid*0.1*Math.sin(t*0.003+s.flicker);
            const ang = s.angle + jitter;

            s.x = cx + Math.cos(ang)*s.dist;
            s.y = cy + Math.sin(ang)*s.dist;

            const hue = (190 + (1-s.depth)*40 + hi*60) % 360;
            const sat = 30 + hi*30;
            const light = 35 + (1-s.depth)*40 + mid*10;

            ctx.strokeStyle=`hsla(${hue},${sat}%,${light}%,${0.3+hi*0.25})`;
            ctx.lineWidth=(1-s.depth)*1.4;

            ctx.beginPath();
            ctx.moveTo(s.px,s.py);
            const sx = cx + Math.cos(ang)*(s.dist - streak*4*(1-s.depth));
            const sy = cy + Math.sin(ang)*(s.dist - streak*4*(1-s.depth));
            ctx.lineTo(sx,sy);
            ctx.stroke();
        }

        ctx.restore();
    }

    // -----------------------------
    // FRACTAL REACTOR (cooler palette)
    // -----------------------------
    function drawWheel(cx,cy,r,bins,t,d,maxD,rot,phase){
        if(d>maxD) return;

        const spokes=200;
        const L=bins.length;

        for(let i=0;i<spokes;i++){
            const p=i/spokes;
            const idx=Math.floor(p*L);
            const amp=bins[idx]/255;

            const len = r*(1 + amp*1.6*(d+1));
            const a = p*Math.PI*2 + rot + phase + t*(0.00032+d*0.00004);
            const x = cx + Math.cos(a)*len;
            const y = cy + Math.sin(a)*len;

            const hue = (190 + p*60 + d*35 + phase*90/Math.PI) % 360;
            const sat = 35 + amp*20;
            const light = 30 + amp*20;

            ctx.strokeStyle=`hsla(${hue},${sat}%,${light}%,${0.15+amp*0.2-d*0.03})`;
            ctx.lineWidth=0.6+amp*1.8;

            ctx.beginPath();
            ctx.moveTo(cx,cy);
            ctx.lineTo(x,y);
            ctx.stroke();
        }

        drawWheel(cx,cy,r*(0.52+Math.sin(t*0.001+d)*0.03),bins,t,d+1,maxD,rot*1.18+(d+1)*0.5,phase);
    }

    function drawFractal(bins,t){
        const cx = canvas.width/2;
        const cy = canvas.height/2;
        const low=bins[2]/255;
        const r= Math.min(canvas.width,canvas.height)*(0.12+low*0.17);

        ctx.save();
        ctx.translate(cx,cy);
        ctx.rotate(Math.sin(t*0.0011)*0.1);
        ctx.translate(-cx,-cy);

        ctx.globalCompositeOperation="screen";

        drawWheel(cx,cy,r,bins,t,0,2,0.15,0);
        drawWheel(cx,cy,r*0.85,bins,t,0,2,-0.2,Math.PI/3);

        ctx.restore();
        ctx.globalCompositeOperation="source-over";
    }

    // -----------------------------
    // MAIN LOOP
    // -----------------------------
    function render(){
        requestAnimationFrame(render);
        if(!analyser) return;

        analyser.getByteFrequencyData(data);
        const t = performance.now() - start;

        // compute spectral bands
        const L=data.length;
        let low=0,mid=0,hi=0,lc=0,mc=0,hc=0;
        for(let i=0;i<L;i++){
            const v=data[i];
            if(i<L*0.15){ low+=v; lc++; }
            else if(i<L*0.5){ mid+=v; mc++; }
            else{ hi+=v; hc++; }
        }
        low=lc?low/(lc*255):0;
        mid=mc?mid/(mc*255):0;
        hi =hc?hi /(hc *255):0;

        // DRAW ORDER:
        // 1. VHS RORSCHACH
        drawRorschach(data,t);

        // 2. DARK SPACE BACKDROP
        ctx.fillStyle="rgba(0,0,0,0.6)";
        ctx.fillRect(0,0,canvas.width,canvas.height);

        // 3. STARFIELD
        drawStars(low,mid,hi,t);

        // 4. FRACTAL
        drawFractal(data,t);
    }

    // -----------------------------
    // AUDIO LOAD
    // -----------------------------
    fileInput.onchange = async ()=>{
        const file=fileInput.files[0];
        if(!file) return;

        const buf=await file.arrayBuffer();
        if(!audioCtx) audioCtx=new AudioContext();
        if(audioCtx.state==="suspended") await audioCtx.resume();

        const decoded=await audioCtx.decodeAudioData(buf);
        if(source) source.stop();

        source=audioCtx.createBufferSource();
        source.buffer=decoded;

        analyser=audioCtx.createAnalyser();
        analyser.fftSize=1024;
        data=new Uint8Array(analyser.frequencyBinCount);

        source.connect(analyser);
        analyser.connect(audioCtx.destination);
        source.start();

        ui.classList.add("hidden");
        start=performance.now();
        render();
    };
})();
</script>

</body>
</html>
