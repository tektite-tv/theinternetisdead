<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Ultra Chaos Dragon Visualizer</title>
<style>
    html,body{
        margin:0;
        padding:0;
        background:#000;
        overflow:hidden;
        font-family:sans-serif;
    }
    canvas{
        position:fixed;
        inset:0;
        width:100vw;
        height:100vh;
        display:block;
    }
    #ui{
        position:fixed;
        top:50%;left:50%;
        transform:translate(-50%,-50%);
        padding:24px 32px;
        background:rgba(10,0,20,0.85);
        border-radius:14px;
        border:1px solid rgba(255,255,255,0.25);
        color:#0ff;
        text-align:center;
        z-index:10;
        box-shadow:0 0 30px #0ff,0 0 60px #0ff;
    }
    #ui.hidden{
        opacity:0;
        pointer-events:none;
        transform:translate(-50%,-60%);
        transition:0.7s;
    }
    button{
        padding:10px 20px;
        border:none;
        border-radius:999px;
        background:linear-gradient(135deg,#0ff,#f0f);
        color:#000;
        font-weight:600;
        cursor:pointer;
        box-shadow:0 0 16px #0ff;
    }
    input{display:none;}
    #hint{
        font-size:0.8rem;
        color:#ccc;
        margin-top:10px;
    }
</style>
</head>
<body>

<canvas id="c"></canvas>

<div id="ui">
    <h2 style="margin:0 0 10px;">Ultra Chaos Dragon Visualizer</h2>
    <p style="color:#ccc;font-size:0.9rem;margin-bottom:14px;">
        Upload an MP3 / WAV / OGG.  
        GPU insurance not included.
    </p>
    <button id="uploadBtn">Choose Audio</button>
    <input type="file" id="fileInput" accept="audio/*">
    <div id="hint">If it stutters, you did this to yourself.</div>
</div>

<script>
(() => {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;

    addEventListener("resize", () => {
        w = canvas.width = innerWidth;
        h = canvas.height = innerHeight;
        setupBgCanvas();
    });

    const ui = document.getElementById("ui");
    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("fileInput");
    uploadBtn.onclick = () => fileInput.click();

    let audioCtx, source, analyser, data;
    let start = 0;

    // -------------------------------------------------------
    // LOW-RES RORSCHACH BACKGROUND (for speed-ish)
    // -------------------------------------------------------
    let bgCanvas, bgCtx, bw, bh;

    function setupBgCanvas() {
        const scale = 0.3; // lower = faster
        bw = Math.max(160, Math.floor(w * scale));
        bh = Math.max(120, Math.floor(h * scale));
        bgCanvas = document.createElement("canvas");
        bgCanvas.width = bw;
        bgCanvas.height = bh;
        bgCtx = bgCanvas.getContext("2d");
    }
    setupBgCanvas();

    function noise(x, y, t) {
        return (
            Math.sin(x*0.04 + t*0.0004) +
            Math.sin(y*0.035 - t*0.00023) +
            Math.sin((x+y)*0.02 + t*0.00019)
        ) * 0.5;
    }

    function hslToRgb(h, s, l){
        if (s === 0) return [l*255,l*255,l*255];
        const hue2rgb = (p, q, t) => {
            if (t<0) t+=1;
            if (t>1) t-=1;
            if (t<1/6) return p+(q-p)*6*t;
            if (t<1/2) return q;
            if (t<2/3) return p+(q-p)*(2/3-t)*6;
            return p;
        };
        const q = l < .5 ? l*(1+s) : l+l*s-l*s;
        const p = 2*l-q;
        return [
            hue2rgb(p,q,h+1/3)*255,
            hue2rgb(p,q,h)*255,
            hue2rgb(p,q,h-1/3)*255
        ];
    }

    function drawInkBlot(bins, t) {
        const img = bgCtx.getImageData(0,0,bw,bh);
        const d = img.data;

        const low = bins[4]/255;
        const mid = bins[80]/255;
        const hi  = bins[200]/255;
        const pulse = (low*0.6 + mid*0.9 + hi*1.4);

        const cx = bw/2;
        const cy = bh/2;

        for (let y = 0; y < bh; y++) {
            const dy = y - cy;
            for (let x = 0; x < bw/2; x++) {
                const dx = x - cx/2;

                let n = 0;
                n += noise(dx*1.0, dy*1.0, t) * 0.6;
                n += noise(dx*0.6, dy*0.6, t*1.6) * 0.4;

                let v = Math.abs(n);
                v = Math.pow(v, 1.2 - pulse*0.5);

                const hue = (t*0.012 + v*320 + hi*120) % 360;
                const sat = 35 + v*60 + hi*20;
                const lit = 8 + v*55 + pulse*25;

                const rgb = hslToRgb(hue/360, sat/100, lit/100);

                const idxL = (y*bw + x)*4;
                const idxR = (y*bw + (bw - x - 1))*4;

                d[idxL]   = rgb[0];
                d[idxL+1] = rgb[1];
                d[idxL+2] = rgb[2];
                d[idxL+3] = 255;

                d[idxR]   = rgb[0];
                d[idxR+1] = rgb[1];
                d[idxR+2] = rgb[2];
                d[idxR+3] = 255;
            }
        }

        bgCtx.putImageData(img,0,0);
        // draw to main canvas scaled up
        ctx.drawImage(bgCanvas, 0, 0, w, h);
    }

    // -------------------------------------------------------
    // RECURSIVE WHEELS OF DOOM
    // -------------------------------------------------------
    function drawWheel(cx, cy, radius, bins, t, depth, maxDepth, rotOffset, phase) {
        if (depth > maxDepth) return;

        const count = bins.length;
        const spokes = 300; // still dense, but not totally insane

        for (let i = 0; i < spokes; i++) {
            const p = i / spokes;
            const idx = Math.floor(p * count);
            const amp = bins[idx] / 255;

            const len = radius * (1 + amp * 2.5 * (depth + 1));

            const angle = p * Math.PI * 2 + rotOffset + phase + t * (0.00045 + depth*0.00005);

            const x = cx + Math.cos(angle) * len;
            const y = cy + Math.sin(angle) * len;

            const hue = (p*360 + depth*90 + phase*180/Math.PI + t*0.03) % 360;
            ctx.strokeStyle = `hsla(${hue},100%,60%,${0.5 - depth*0.11})`;
            ctx.lineWidth = 1 + amp * 3.5;

            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(x, y);
            ctx.stroke();

            // occasional glitch spokes
            if (depth === 0 && amp > 0.7 && Math.random() < 0.15) {
                const gAngle = angle + (Math.random() - 0.5) * 0.5;
                const gLen = len * (1.1 + Math.random()*0.6);
                const gx = cx + Math.cos(gAngle) * gLen;
                const gy = cy + Math.sin(gAngle) * gLen;
                ctx.strokeStyle = `hsla(${(hue+120)%360},100%,70%,0.7)`;
                ctx.lineWidth = 0.8 + Math.random()*2;
                ctx.beginPath();
                ctx.moveTo(cx,cy);
                ctx.lineTo(gx,gy);
                ctx.stroke();
            }
        }

        const nextR = radius * (0.5 + Math.sin(t*0.001 + depth)*0.07);
        const nextRot = rotOffset * 1.28 + (depth + 1) * 0.75;

        drawWheel(cx, cy, nextR, bins, t, depth+1, maxDepth, nextRot, phase);
    }

    function drawFractal(bins, t) {
        const cx = w/2;
        const cy = h/2;

        const low = bins[1] / 255;
        const baseR = Math.min(w, h) * (0.13 + low*0.23);

        ctx.save();
        // subtle overall wobble
        ctx.translate(cx, cy);
        ctx.rotate(Math.sin(t*0.0014) * 0.11);
        ctx.translate(-cx, -cy);

        // soft additive glow
        ctx.globalCompositeOperation = "lighter";

        // main wheel
        drawWheel(cx, cy, baseR, bins, t, 0, 3, 0.2, 0);

        // offset twin wheel for extra chaos
        drawWheel(cx, cy, baseR*0.9, bins, t, 0, 3, -0.35, Math.PI/3);

        ctx.restore();
        ctx.globalCompositeOperation = "source-over";
    }

    // -------------------------------------------------------
    // MAIN LOOP
    // -------------------------------------------------------
    function render() {
        requestAnimationFrame(render);
        analyser.getByteFrequencyData(data);
        const t = performance.now() - start;

        // Background first
        drawInkBlot(data, t);

        // Slight overall fade for trails
        ctx.fillStyle = "rgba(0,0,0,0.08)";
        ctx.fillRect(0,0,w,h);

        // Fractal on top
        drawFractal(data, t);
    }

    // -------------------------------------------------------
    // AUDIO SETUP
    // -------------------------------------------------------
    fileInput.onchange = async () => {
        const file = fileInput.files[0];
        if (!file) return;

        const array = await file.arrayBuffer();
        if (!audioCtx) audioCtx = new AudioContext();
        if (audioCtx.state === "suspended") await audioCtx.resume();

        const decoded = await audioCtx.decodeAudioData(array);
        if (source) source.stop();

        source = audioCtx.createBufferSource();
        source.buffer = decoded;

        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 1024; // still detailed, slightly lighter
        data = new Uint8Array(analyser.frequencyBinCount);

        source.connect(analyser);
        analyser.connect(audioCtx.destination);
        source.start();

        ui.classList.add("hidden");
        start = performance.now();
        render();
    };
})();
</script>
</body>
</html>
