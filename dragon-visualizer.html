<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>CRT Starfield Dragon Visualizer</title>
<style>
    html,body{
        margin:0;
        padding:0;
        background:#000;
        overflow:hidden;
        font-family:sans-serif;
        color:#0ff;
    }
    canvas{
        position:fixed;
        inset:0;
        width:100vw;
        height:100vh;
        display:block;
    }
    #ui{
        position:fixed;
        top:50%;left:50%;
        transform:translate(-50%,-50%);
        padding:22px 28px;
        background:rgba(5,5,15,0.9);
        border-radius:14px;
        border:1px solid rgba(0,255,255,0.3);
        box-shadow:0 0 25px rgba(0,255,255,0.5);
        text-align:center;
        z-index:20;
    }
    #ui.hidden{
        opacity:0;
        pointer-events:none;
        transform:translate(-50%,-60%);
        transition:0.7s;
    }
    button{
        padding:9px 18px;
        border:none;
        border-radius:999px;
        background:linear-gradient(135deg,#0ff,#6f6bff);
        color:#000;
        font-weight:600;
        cursor:pointer;
        box-shadow:0 0 12px rgba(0,255,255,0.7);
    }
    input{display:none;}
    #hint{
        margin-top:8px;
        font-size:0.8rem;
        color:#aaa;
    }
    /* CRT overlay */
    #crt{
        pointer-events:none;
        position:fixed;
        inset:0;
        z-index:15;
        mix-blend-mode:soft-light;
    }
    #crt::before,
    #crt::after{
        content:"";
        position:absolute;
        inset:0;
    }
    /* scanlines */
    #crt::before{
        background:
            repeating-linear-gradient(
                to bottom,
                rgba(255,255,255,0.04) 0px,
                rgba(255,255,255,0.04) 1px,
                transparent 2px,
                transparent 3px
            );
    }
    /* vignette */
    #crt::after{
        background:
            radial-gradient(circle at 50% 10%, rgba(255,255,255,0.05), transparent 55%),
            radial-gradient(circle at 50% 90%, rgba(255,255,255,0.02), transparent 60%),
            radial-gradient(circle at 50% 50%, transparent 0%, transparent 55%, rgba(0,0,0,0.8) 100%);
        mix-blend-mode:multiply;
    }
</style>
</head>
<body>

<canvas id="c"></canvas>
<div id="crt"></div>

<div id="ui">
    <h2 style="margin:0 0 8px;">CRT Starfield Dragon</h2>
    <p style="margin:0 0 14px;font-size:0.9rem;color:#cfd9ff;">
        Upload an audio file and drift into the void.<br>
        Cooler colors, less retina assault.
    </p>
    <button id="uploadBtn">Choose Audio</button>
    <input type="file" id="fileInput" accept="audio/*">
    <div id="hint">Tip: darker tracks look extra cursed.</div>
</div>

<script>
(() => {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;

    addEventListener("resize", () => {
        w = canvas.width = innerWidth;
        h = canvas.height = innerHeight;
        initStars();
    });

    const ui = document.getElementById("ui");
    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("fileInput");
    uploadBtn.onclick = () => fileInput.click();

    let audioCtx, analyser, source, data;
    let start = 0;

    // -----------------------------
    // STARFIELD
    // -----------------------------
    const STAR_COUNT_BASE = 320;
    let stars = [];

    function initStars() {
        const count = STAR_COUNT_BASE;
        stars = [];
        const cx = w/2;
        const cy = h/2;
        for (let i = 0; i < count; i++) {
            const angle = Math.random()*Math.PI*2;
            const dist = Math.random()*Math.max(w,h)*0.5;
            const x = cx + Math.cos(angle)*dist;
            const y = cy + Math.sin(angle)*dist;
            stars.push({
                angle,
                dist,
                x,
                y,
                px:x,
                py:y,
                depth:Math.random(),         // 0 = close, 1 = far
                flicker:Math.random()*Math.PI*2
            });
        }
    }
    initStars();

    function updateAndDrawStars(low, mid, hi, t) {
        const cx = w/2;
        const cy = h/2;
        const speedBase = 0.25 + low*0.6;
        const streakScale = 0.8 + hi*2.0;
        const colorShift = hi*80;

        ctx.save();
        ctx.lineCap = "round";

        for (let s of stars) {
            s.px = s.x;
            s.py = s.y;

            const layerSpeed = speedBase*(0.3 + (1-s.depth)*1.5);
            s.dist += layerSpeed;

            const maxDist = Math.max(w,h)*0.8;
            if (s.dist > maxDist) {
                // respawn near center
                s.dist = Math.random()*40;
                s.angle = Math.random()*Math.PI*2;
                s.px = cx;
                s.py = cy;
            }

            const jitter = (mid*0.15) * (Math.sin(t*0.002 + s.flicker)*0.5);
            const angle = s.angle + jitter;

            s.x = cx + Math.cos(angle)*s.dist;
            s.y = cy + Math.sin(angle)*s.dist;

            const brightness = 0.3 + (1-s.depth)*0.7 + hi*0.3;
            const hue = 190 + (1-s.depth)*40 + colorShift; // teal/blue
            const sat = 40 + hi*30;
            const light = 35 + brightness*35;

            ctx.strokeStyle = `hsla(${hue%360},${sat}%,${light}%,${0.35 + hi*0.25})`;
            ctx.lineWidth = (1-s.depth)*1.8;

            ctx.beginPath();
            ctx.moveTo(s.px, s.py);
            const sx = cx + Math.cos(angle)*(s.dist - streakScale*6*(1-s.depth));
            const sy = cy + Math.sin(angle)*(s.dist - streakScale*6*(1-s.depth));
            ctx.lineTo(sx, sy);
            ctx.stroke();
        }
        ctx.restore();
    }

    // -----------------------------
    // FRACTAL WHEEL (cooler palette)
    // -----------------------------
    function drawWheel(cx, cy, radius, bins, t, depth, maxDepth, rotOffset, phase) {
        if (depth > maxDepth) return;

        const count = bins.length;
        const spokes = 220;

        for (let i = 0; i < spokes; i++) {
            const p = i / spokes;
            const idx = Math.floor(p * count);
            const amp = bins[idx] / 255;

            const len = radius * (1 + amp*1.8*(depth+1));
            const angle = p*Math.PI*2 + rotOffset + phase + t*(0.00035 + depth*0.00004);

            const x = cx + Math.cos(angle)*len;
            const y = cy + Math.sin(angle)*len;

            // cooler CRT-ish palette
            const baseHue = 190; // cyan/blue
            const hue = (baseHue + p*80 + depth*40) % 360;
            const sat = 45 + amp*25;      // lower saturation
            const light = 40 + amp*20;    // avoid blinding white

            const alpha = 0.18 + amp*0.25 - depth*0.04;

            ctx.strokeStyle = `hsla(${hue},${sat}%,${light}%,${alpha})`;
            ctx.lineWidth = 0.8 + amp*2.4;

            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(x, y);
            ctx.stroke();
        }

        const nextR = radius*(0.55 + Math.sin(t*0.001 + depth)*0.04);
        const nextRot = rotOffset*1.2 + (depth+1)*0.6;
        drawWheel(cx,cy,nextR,bins,t,depth+1,maxDepth,nextRot,phase);
    }

    function drawFractal(bins, t) {
        const cx = w/2;
        const cy = h/2;

        const low = bins[2]/255;
        const baseR = Math.min(w,h)*(0.14 + low*0.18);

        ctx.save();
        ctx.translate(cx,cy);
        ctx.rotate(Math.sin(t*0.0012)*0.12);
        ctx.translate(-cx,-cy);

        ctx.globalCompositeOperation = "screen";

        drawWheel(cx,cy,baseR,bins,t,0,2,0.15,0);
        drawWheel(cx,cy,baseR*0.85,bins,t,0,2,-0.22,Math.PI/2.8);

        ctx.restore();
        ctx.globalCompositeOperation = "source-over";
    }

    // -----------------------------
    // MAIN LOOP
    // -----------------------------
    function render() {
        requestAnimationFrame(render);
        if (!analyser) return;

        analyser.getByteFrequencyData(data);
        const t = performance.now() - start;

        // simple dark background with subtle radial glow
        const cx = w/2, cy = h/2;
        const grad = ctx.createRadialGradient(
            cx,cy,0,
            cx,cy,Math.max(w,h)*0.7
        );
        grad.addColorStop(0,"rgba(5,10,20,0.8)");
        grad.addColorStop(1,"rgba(0,0,0,1)");
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(0,0,w,h);
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,w,h);

        // compute band energies
        const L = data.length;
        let low=0, mid=0, hi=0, lc=0, mc=0, hc=0;
        for (let i=0;i<L;i++){
            const v = data[i];
            if (i < L*0.15){ low+=v; lc++; }
            else if (i < L*0.5){ mid+=v; mc++; }
            else { hi+=v; hc++; }
        }
        low = lc? low/(lc*255):0;
        mid = mc? mid/(mc*255):0;
        hi  = hc? hi /(hc *255):0;

        // stars first
        updateAndDrawStars(low, mid, hi, t);

        // then fractal
        drawFractal(data, t);
    }

    // -----------------------------
    // AUDIO HANDLING
    // -----------------------------
    fileInput.onchange = async () => {
        const file = fileInput.files[0];
        if (!file) return;

        const buffer = await file.arrayBuffer();
        if (!audioCtx) audioCtx = new AudioContext();
        if (audioCtx.state === "suspended") await audioCtx.resume();

        const decoded = await audioCtx.decodeAudioData(buffer);
        if (source) source.stop();

        source = audioCtx.createBufferSource();
        source.buffer = decoded;

        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 1024;
        data = new Uint8Array(analyser.frequencyBinCount);

        source.connect(analyser);
        analyser.connect(audioCtx.destination);
        source.start();

        ui.classList.add("hidden");
        start = performance.now();
        render();
    };
})();
</script>
</body>
</html>
