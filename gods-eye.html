<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Fractal Square Bloom</title>
<style>
    body {
        margin: 0;
        background: black;
        overflow: hidden;
    }
    canvas {
        position: absolute;
        top: 0;
        left: 0;
    }
</style>
</head>
<body>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

// CONFIG (tuned for "looks cool" + performance)
const generations   = 18;      // how many rings
const shrinkFactor  = 0.65;    // size falloff per generation (your choice B=medium)
const baseRadius    = 40;      // spacing between rings (before global scale)
const zoomSpeed     = 0.008;   // how fast the whole thing blooms out
const spinSpeed     = 0.0025;  // global rotation
const twistPerGen   = Math.PI / 18; // extra twist per generation

let globalScale = 1;

// simple HSV-like color cycling, mapped to generation index
function colorForGen(gen) {
    const hue = (gen * 20) % 360;
    return `hsl(${hue}, 100%, 55%)`;
}

function drawFrame(time) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const cx = canvas.width  / 2;
    const cy = canvas.height / 2;

    // global spin & zoom-out
    const spin = time * spinSpeed;
    globalScale *= (1 + zoomSpeed);
    if (globalScale > 6) globalScale = 1;  // loop the bloom

    for (let gen = 0; gen < generations; gen++) {
        const t = gen / generations;

        // size shrinks by factor each generation, then globally scaled
        const size   = 40 * Math.pow(shrinkFactor, gen) * globalScale;
        const radius = baseRadius * gen * globalScale;

        const angleOffset = spin + gen * twistPerGen;
        const color       = colorForGen(gen);

        // four “vertex directions” (like the square's corners)
        for (let k = 0; k < 4; k++) {
            const dirAngle = angleOffset + k * (Math.PI / 2);

            const x = cx + Math.cos(dirAngle) * radius;
            const y = cy + Math.sin(dirAngle) * radius;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(dirAngle + angleOffset); // extra spin for kaleidoscope feel
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.rect(-size / 2, -size / 2, size, size);
            ctx.stroke();

            ctx.restore();
        }
    }

    requestAnimationFrame(drawFrame);
}

requestAnimationFrame(drawFrame);
</script>

</body>
</html>
