<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Breathing Fractal Bloom + Audio Reactive</title>
<style>
    body {
        margin: 0;
        background: black;
        overflow: hidden;
        font-family: sans-serif;
    }

    #uploadBox {
        position: fixed;
        top: 12px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 0, 128, 0.75);
        color: white;
        padding: 10px 18px;
        border-radius: 12px;
        cursor: pointer;
        font-size: 15px;
        z-index: 99999;
        user-select: none;
        opacity: 1;
        transition: opacity 0.7s ease;
    }
    #uploadBox.hidden {
        opacity: 0;
        pointer-events: none;
    }

    #file-input {
        display: none;
    }

    canvas {
        position: absolute;
        left: 0;
        top: 0;
    }
</style>
</head>
<body>

<div id="uploadBox">Upload MP3</div>
<input id="file-input" type="file" accept="audio/*">

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// === FRACTAL CONFIG ===
const layers = 4;
const rings = 32;
const squaresPerRing = 4;
const baseSize = 120;
const shrink = 0.85;
const twist = Math.PI / 12;
const driftSpeed = 0.00025;
const breatheSpeed = 0.0015;
const spinSpeed = 0.0006;
const glow = 12;

// === AUDIO + ANALYSER ===
let audioCtx = null;
let analyser = null;
let freqData = null;

// random weights for audio-reactive heatmap
const heatWeights = new Array(128).fill(0).map(() => Math.random() * 2.5);

function audioHeat() {
    if (!analyser) return 0;
    analyser.getByteFrequencyData(freqData);
    let total = 0;
    for (let i = 0; i < 128; i++) total += (freqData[i] / 255) * heatWeights[i];
    return Math.min(1, total / 128);
}

// === FILE UPLOAD LOGIC ===
const uploadBox = document.getElementById("uploadBox");
const fileInput = document.getElementById("file-input");

uploadBox.onclick = () => fileInput.click();

fileInput.onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    if (!audioCtx) audioCtx = new AudioContext();
    const arrayBuffer = await file.arrayBuffer();
    const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

    const source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 256;
    freqData = new Uint8Array(analyser.frequencyBinCount);

    source.connect(analyser);
    analyser.connect(audioCtx.destination);

    // fade out upload button
    uploadBox.classList.add("hidden");

    source.start(0);

    // fade it BACK IN when the audio ends
    source.onended = () => {
        setTimeout(() => {
            uploadBox.classList.remove("hidden");
        }, 1500); // appears 1.5s after music stops
    };
};

// === MAIN DRAW LOOP ===
function draw(time) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const cx = canvas.width / 2;
    const cy = canvas.height / 2;

    const breathe = 1 + Math.sin(time * breatheSpeed) * 0.20;
    const heat = audioHeat();
    const heatHueShift = heat * 180;

    for (let L = 0; L < layers; L++) {
        const layerDepth = 1 + L * 0.15;
        const angleBase = time * spinSpeed * (1 + L * 0.1);

        for (let r = 0; r < rings; r++) {
            const size = baseSize * Math.pow(shrink, r) * layerDepth * breathe;
            const radius = r * 18 * layerDepth * breathe;

            const hue = (r * 12 + L * 30 + heatHueShift + time * driftSpeed * 300) % 360;
            const color = `hsla(${hue}, 100%, 60%, ${0.55 + L * 0.1})`;

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.shadowColor = color;
            ctx.shadowBlur = glow;

            const ringTwist = angleBase + r * twist;

            for (let k = 0; k < squaresPerRing; k++) {
                const angle = ringTwist + k * (Math.PI / 2);

                const curve = Math.sin(r * 0.3 + time * 0.0009) * 10;

                const x = cx + Math.cos(angle) * (radius + curve);
                const y = cy + Math.sin(angle) * (radius + curve);

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle + ringTwist * 0.5);

                ctx.beginPath();
                ctx.rect(-size / 2, -size / 2, size, size);
                ctx.stroke();

                ctx.restore();
            }
        }
    }

    requestAnimationFrame(draw);
}

requestAnimationFrame(draw);
</script>

</body>
</html>
