<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Isometric Cube – Psychedelic Scanlines</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: black;
    height: 100%;
    width: 100%;
    touch-action: none;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<canvas id="trippy"></canvas>
<script>
const canvas = document.getElementById('trippy');
const ctx = canvas.getContext('2d');

let w, h;
let swipeX = 0, swipeY = 0;

// cube face polygons (arrays of {x,y})
let topFace = [];
let leftFace = [];
let rightFace = [];

function resize() {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
  computeCube();
}
window.addEventListener('resize', resize);
resize();

// swipe detection (touch)
let touchStart = null;
window.addEventListener('touchstart', e => {
  const t = e.touches[0];
  touchStart = { x: t.clientX, y: t.clientY };
});
window.addEventListener('touchmove', e => {
  if (!touchStart) return;
  const t = e.touches[0];
  swipeX = (t.clientX - touchStart.x) * 0.2;
  swipeY = (t.clientY - touchStart.y) * 0.2;
});

// mouse drag warp
let mouseDown = false;
let mouseStart = null;
window.addEventListener('mousedown', e => {
  mouseDown = true;
  mouseStart = { x: e.clientX, y: e.clientY };
});
window.addEventListener('mousemove', e => {
  if (!mouseDown || !mouseStart) return;
  swipeX = (e.clientX - mouseStart.x) * 0.2;
  swipeY = (e.clientY - mouseStart.y) * 0.2;
});
window.addEventListener('mouseup', () => {
  mouseDown = false;
  mouseStart = null;
});

// psychedelic scanline animation
function drawScanlines(time) {
  const freq = 0.005;
  for (let y = 0; y < h; y += 3) {
    const hue = (Math.sin(time * freq + y * 0.03) * 180 + 180) % 360;
    ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
    ctx.beginPath();
    const amplitude = 10 + Math.sin(time * 0.002 + y * 0.05) * 5;
    for (let x = 0; x < w; x += 10) {
      const yOffset = Math.sin(
        x * 0.05 +
        time * 0.005 +
        y +
        swipeX * 0.1 +
        swipeY * 0.1
      ) * amplitude;
      ctx.lineTo(x, y + yOffset);
    }
    ctx.stroke();
  }
}

function computeCube() {
  const cx = w / 2;
  const cy = h / 2;
  const size = Math.min(w, h) * 0.25;

  const iso = (x, y, z) => {
    return {
      x: cx + (x - y) * Math.cos(Math.PI / 6),
      y: cy + (x + y) * Math.sin(Math.PI / 6) - z
    };
  };

  // cube corners in 3D
  const p = {
    A: iso(0, 0, size),
    B: iso(size, 0, size),
    C: iso(size, size, size),
    D: iso(0, size, size),
    E: iso(0, 0, 0),
    F: iso(size, 0, 0),
    G: iso(size, size, 0),
    H: iso(0, size, 0)
  };

  // top face
  topFace = [p.A, p.B, p.C, p.D];

  // left face
  leftFace = [p.A, p.D, p.H, p.E];

  // right face
  rightFace = [p.B, p.C, p.G, p.F];
}

function drawFace(face, time) {
  if (!face || !face.length) return;
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(face[0].x, face[0].y);
  for (let i = 1; i < face.length; i++) {
    ctx.lineTo(face[i].x, face[i].y);
  }
  ctx.closePath();
  ctx.clip();

  drawScanlines(time);

  ctx.restore();
}

function strokeFace(face, color = 'white', width = 2) {
  if (!face || !face.length) return;
  ctx.save();
  ctx.lineWidth = width;
  ctx.strokeStyle = color;
  ctx.beginPath();
  ctx.moveTo(face[0].x, face[0].y);
  for (let i = 1; i < face.length; i++) {
    ctx.lineTo(face[i].x, face[i].y);
  }
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}

function animate(time) {
  ctx.fillStyle = "rgba(0,0,0,0.15)";
  ctx.fillRect(0, 0, w, h);

  // correct drawing order (back → front)
  drawFace(leftFace, time);
  drawFace(rightFace, time);
  drawFace(topFace, time);

  strokeFace(leftFace);
  strokeFace(rightFace);
  strokeFace(topFace);

  requestAnimationFrame(animate);
}

animate(0);
</script>
</body>
</html>
