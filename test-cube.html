<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Isometric Cube – Psychedelic Scanlines</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: black;
    height: 100%;
    width: 100%;
    touch-action: none;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<canvas id="trippy"></canvas>
<script>
const canvas = document.getElementById('trippy');
const ctx = canvas.getContext('2d');

let w, h;
let swipeX = 0, swipeY = 0;

// cube face polygons (arrays of {x,y})
let topFace = [];
let leftFace = [];
let rightFace = [];

function resize() {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
  computeCube();
}
window.addEventListener('resize', resize);
resize();

// swipe detection (touch)
let touchStart = null;
window.addEventListener('touchstart', e => {
  const t = e.touches[0];
  touchStart = { x: t.clientX, y: t.clientY };
});
window.addEventListener('touchmove', e => {
  if (!touchStart) return;
  const t = e.touches[0];
  swipeX = (t.clientX - touchStart.x) * 0.2;
  swipeY = (t.clientY - touchStart.y) * 0.2;
});

// mouse drag warp
let mouseDown = false;
let mouseStart = null;
window.addEventListener('mousedown', e => {
  mouseDown = true;
  mouseStart = { x: e.clientX, y: e.clientY };
});
window.addEventListener('mousemove', e => {
  if (!mouseDown || !mouseStart) return;
  swipeX = (e.clientX - mouseStart.x) * 0.2;
  swipeY = (e.clientY - mouseStart.y) * 0.2;
});
window.addEventListener('mouseup', () => {
  mouseDown = false;
  mouseStart = null;
});

// psychedelic scanline animation
function drawScanlines(time) {
  const freq = 0.005;
  for (let y = 0; y < h; y += 3) {
    const hue = (Math.sin(time * freq + y * 0.03) * 180 + 180) % 360;
    ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
    ctx.beginPath();
    const amplitude = 10 + Math.sin(time * 0.002 + y * 0.05) * 5;
    for (let x = 0; x < w; x += 10) {
      const yOffset = Math.sin(
        x * 0.05 +
        time * 0.005 +
        y +
        swipeX * 0.1 +
        swipeY * 0.1
      ) * amplitude;
      ctx.lineTo(x, y + yOffset);
    }
    ctx.stroke();
  }
}

// FIXED — clean, proper isometric cube geometry
function computeCube() {
  const cx = w / 2;
  const cy = h / 2;
  const s = Math.min(w, h) * 0.25;

  const angle = Math.PI / 6;
  const dx = Math.cos(angle) * s;
  const dy = Math.sin(angle) * s;

  // cube anchor (top center)
  const top = { x: cx, y: cy - s * 0.4 };

  // directions
  const up = { x: 0, y: -s };
  const right = { x: dx, y: dy };
  const left = { x: -dx, y: dy };
  const down = { x: 0, y: s };

  // top face corners
  const A = { x: top.x + left.x, y: top.y + left.y };
  const B = { x: top.x + right.x, y: top.y + right.y };
  const C = { x: B.x, y: B.y + s };
  const D = { x: A.x, y: A.y + s };

  // assign faces
  topFace = [A, B, top, top];
  leftFace = [
    A,
    D,
    { x: D.x, y: D.y + s },
    { x: A.x, y: A.y + s }
  ];
  rightFace = [
    B,
    C,
    { x: C.x, y: C.y + s },
    { x: B.x, y: B.y + s }
  ];
}

function drawFace(face, time) {
  if (!face || !face.length) return;
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(face[0].x, face[0].y);
  for (let i = 1; i < face.length; i++) {
    ctx.lineTo(face[i].x, face[i].y);
  }
  ctx.closePath();
  ctx.clip();

  drawScanlines(time);

  ctx.restore();
}

function strokeFace(face, color = 'white', width = 2) {
  if (!face || !face.length) return;
  ctx.save();
  ctx.lineWidth = width;
  ctx.strokeStyle = color;
  ctx.beginPath();
  ctx.moveTo(face[0].x, face[0].y);
  for (let i = 1; i < face.length; i++) {
    ctx.lineTo(face[i].x, face[i].y);
  }
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}

function animate(time) {
  ctx.fillStyle = "rgba(0,0,0,0.15)";
  ctx.fillRect(0, 0, w, h);

  // correct drawing order (back → front)
  drawFace(leftFace, time);
  drawFace(rightFace, time);
  drawFace(topFace, time);

  strokeFace(leftFace);
  strokeFace(rightFace);
  strokeFace(topFace);

  requestAnimationFrame(animate);
}

animate(0);
</script>
</body>
</html>
